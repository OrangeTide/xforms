@node Part III Choice Objects
@chapter Choice Objects

@ifnottex

@menu
* Menu Object:     Menu Object
* Choice Object:   Choice Object
* Browser Object:  Browser Object
@end menu

@end ifnottex


@node Menu Object
@section Menu Object

Also menus can be added to forms. These menus can be used to let the
user choose from many different possibilities. Each menu object has a
box with a label in it in the form. Whenever the user presses the
mouse inside the box (or moves the mouse on top of the box) a pop-up
menu appears. The user can then make a selection from the menu.

@ifnottex

@menu
* Adding Menu Objects:   Adding Menu Objects
* Menu Types:            Menu Types
* Menu Interaction:      Menu Interaction
* Other Menu Routines:   Other Menu Routines
* Menu Attributes:       Menu Attributes
* Remarks:               Menu Remarks
@end menu

@end ifnottex


@node Adding Menu Objects
@subsection Adding Menu Objects

To add a menu to a form use the routine
@findex fl_add_menu()
@example
FL_OBJECT *fl_add_menu(int type, FL_Coord x, FL_Coord y,
                       FL_Coord w, FL_Coord h, const char *label)
@end example
@noindent
It shows a box on the screen with the label centered in it.


@node Menu Types
@subsection Menu Types

The following types are available:
@table @code
@tindex @code{FL_PUSH_MENU}
@item FL_PUSH_MENU
The menu appears when the user presses a mouse button on it.
@tindex @code{FL_PULLDOWN_MENU}
@item FL_PULLDOWN_MENU
The menu appears when the user presses a mouse button on it.
@tindex @code{FL_TOUCH_MENU}
@item FL_TOUCH_MENU
The menu appears when the user move the mouse inside it.
@end table

@code{FL_PUSH_MENU} and @code{FL_PULLDOWN_MENU} behave rather similar.
When you click on a @code{FL_PUSH_MENU} per default a pop-up window
gets opened on top of the @code{FL_PUSH_MENU} menu's box that has a
label at the top, indicating the currently selected menu item. The
pop-up window stays open until you either select an item or press a
mouse button somewhere outside the pop-up window.

When you click on @code{FL_PULLDOWN_MENU} also a pop-up window is
shown, but directly below the menu's box. This pop-up window has
no label and it only stays open until you release the mouse button.

@code{FL_PUSH_MENU} and @code{FL_PULLDOWN_MENU} can be made even more
similar by using the @code{fl_set_menu_notitle()} function (see
below). This changes it's properties so that the pop-up window also
appears below the menu's box and that no label is shown in the pop-up
window. The only remaining difference then is that a
@code{FL_PUSH_MENU} only gets closed when a menu item is selected or
the user presses the mouse outside of the pop-up window while a
@code{FL_PULLDOWN_MENU} also gets closed when the mouse button is
released.


@node Menu Interaction
@subsection Menu Interaction

When the menu appears the user can make a selection using the left
mouse button or make no selection by clicking outside the menu (or by
simply releasing the mouse button in case of a @code{FL_PULLDOWN_MENU}
type menu. When he makes a selection the menu object is returned by
the interaction routines.

@node Other Menu Routines
@subsection Other Menu Routines

There are two ways to populate a menu, i.e.@: add items. The first
one is a bit more complex but allows for more flexibility, e.g.@:
later adding and removing items, associating callbacks with
individual items etc. For the more simple (and in many cases
sufficient) method see the function @code{fl_set_menu_entries()}.

To set the actual menu for a menu object, use the routine
@findex fl_set_menu()
@example
void fl_set_menu(FL_OBJECT *obj, const char *menustr, ...);
@end example
@noindent
@code{menustr} describes the menu in the form used by XPopups
(@pxref{XPopup}). In the simplest case, it just contains the texts fr
the menu items, separated by a bar (@code{'|'}), e.g.@:
@code{"First|Second|Third"}. But it's also possible to employ special
tags (@pxref{Creating XPopups}) that can be used to indicate special
attributes (radio, toggle and greyed-out, for example). Whenever the
user selects a menu item, a pointer to the menu object it belongs to
is returned to the application program.

Please note that if you call @code{fl_set_menu()} on a menu that
already contains items those items are removed. The function calls
@code{fl_clear_menu()} internally before the new items are added.

If you explicitely assign a menu item ID to a menu using the special
tag @code{%x} it is your responsibility to make sure that this ID
isn't already used by a different menu item in the same menu. Failure
to do so may make it impossible to use the menu properly. All
functions working on items expect the menu item ID as one of their
arguments.

In case you don't set menu item IDs they are assigned automatically
with the first item obtaining the menu item ID 1, the next 2 etc.,
i.e.@: it directly reflects the position of the item in the menu.

It is also possible to add menu items to an existing menu using a call
of
@findex fl_addto_menu()
@example
int fl_addto_menu(FL_OBJECT *obj, const char *menustr, ...);
@end example
@noindent
where @code{menustr} is a string of the same form as used in
@code{fl_set_menu()} (you can add one or more new menu items this
way).

Also routines exist to delete a particular menu item or change it:
@findex fl_delete_menu_item()
@findex fl_replace_menu_item()
@example
void fl_delete_menu_item(FL_OBJECT *obj, int miid);
void fl_replace_menu_item(FL_OBJECT *obj, int miid,
                           const char *menustr, ...);
@end example
@code{miid} is the menu item ID. @code{menustr} must be a string as
used in @code{fl_set_menu()} with the only difference that only a
single menu item can be specified.

Please note: when deleting a menu item all other items keep their
menu item IDs. The menu item ID of the deleted menu item isn't
re-used when new items are added later. Instead for each menu an
internal counter exists that gets incremented for each menu item
added and which value is used for the menu item ID unless one is
explicitely assigned to the menu item. The counter oly gets reset to 1
when the menu is cleared used @code{fl_clear_menu()}.

The menu item ID of a menu item changed by using
@code{fl_replace_menu_item()} does not change unless the library is
explicitely asked to via @code{%x} in @code{menustr}.

For most applications, the following routine may be easier to use at
the expense of somewhat restrictive value a menu item can have as
well as a loss of the ability to delete menu items or associate
callbacks with menu items. 
@findex fl_set_menu_entries()
@example
int fl_set_menu_entries(FL_OBJECT *obj, FL_PUP_ENTRY *ent);
@end example
@noindent
where @code{ent} is a pointer to an array of structure of the
following type, terminated by an element, where at least the
@code{text} member is a @code{NULL} pointer:
@tindex @code{FL_PUP_ENTRY}
@example
typedef struct @{
    const char *text;
    FL_PUP_CB callback;
    const char *shortcut;
    int mode;
@} FL_PUP_ENTRY;
@end example
The meaning of each member is explained in Section 21.3. For menus,
item callback function can be @code{NULL} if the menu callback handles
the interaction results. See demo program @file{popup.c} for an
example use of @code{fl_set_menu_entries()}.

The function @code{fl_set_menu_entries()} works by creating and
associating a popup menu with the menu object. The popup ID is
returned by the function. Whenever the function is called, the old
popup associated with the object (if one exists) is freed and a new
one is created. Although you can manipulate the menu either through the
menu API (but adding and removing menu items is not supported for
menus created this way ) or popup API, the application should not free
the popup directly and use @code{fl_clear_menu()} instead.


To clear the whole menu use
@findex fl_clear_menu()
@example
void fl_clear_menu(FL_OBJECT *obj);
@end example

To find the menu item selected by the user use
@findex fl_get_menu(
@example
int fl_get_menu(FL_OBJECT *obj);
@end example
@noindent
The the function returns the menu item ID. In the simplest possible
case this is just the position of the menu item (starting at 1). This
stops to be true when either IDs have been explicitely assigned to
items or items have been deleted. In that case the following rules
apply:
@enumerate
@item
A menu item ID may have been assigned to a menu item using @code{%xn}
in the string for the text of the menu item.
@item
Menu items can get associated with a callback function that is
executed when the menu item is selected. The callback function is of
type @code{FL_PUP_CB} and receives the menu item ID of the selected
menu. If such a callback is set for a menu item the return value of
@code{fl_get_menu()} is the return value of this function instead of
the menu item ID that would have been returned otherwise.
@end enumerate

To obtain the text of the item selected
@findex fl_get_menu_text()
@example
const char *fl_get_menu_text(FL_OBJECT *obj);
@end example

To obtain the text of any item, use the following routine
@findex fl_get_menu_item_text()
@example
const char *fl_get_menu_item_text(FL_OBJECT *obj, int miid);
@end example
@noindent
where @code{miid} is the menu item ID. If @code{n} isn't a valid menu
iem ID item @code{NULL} is returned.

To obtain the total number of menu items, use the function
@findex fl_get_menu_maxitems()
@example
int fl_get_menu_maxitems(FL_OBJECT *obj);
@end example

One can change the appearance of different menu items. In particular,
it is sometimes desirable to make grey-out menu items and make them
unselectable or to put boxes with and without checkmarks in front of
them. This can be done using the routine:
@findex fl_set_menu_item_mode()
@example
void fl_set_menu_item_mode(FL_OBJECT *obj, int miid, unsigned mode);
@end example
@noindent
@code{miid} is the menu index ID of the memu item you want to change.
@code{mode} represents the special properties you want to apply to the
chosen item. You can specify more than one at a time by adding or
bitwise OR-ing these values together. For this parameter, the
following symbolic constants exist:
@table @code
@tindex @code{FL_PUP_NONE}
@item FL_PUP_NONE
No special display characteristic, the default.
@tindex @code{FL_PUP_BOX}
@item FL_PUP_BOX
"Binary" entry, i.e.@: an entry that stands for a choice that can
be switched on and off. Displayed with an unchecked box to the
left.
@tindex @code{FL_PUP_RADIO}
@item FL_PUP_RADIO
"Radio" item belonging to a group, so that gets automatically
switched off when another item of the group is selected. Displayed
with a diamoned-shaped box at the left.
@tindex @code{FL_PUP_GREY}
@item FL_PUP_GREY
To be OR-ed with one of the above to make that item appear
greyed-out and disable it (i.e.@: not selectable anymore).
@tindex @code{FL_PUP_CHECK}
@item FL_PUP_CHECK
To be OR-ed with one of @code{FL_PUP_BOX} and @code{FL_PUP_RADIO}
to make the box to the left appear checked or pushed.
@end table

There is also a routine that can be used to obtain the current mode of
an item after interaction, mostly useful for toggle or radio items:
@findex fl_get_menu_item_mode()
@example
unsigned int fl_get_menu_item_mode(FL_OBJECT *obj, int miid);
@end example

It is often useful to define keyboard shortcuts for particular menu
items. For example, it would be nice to have @code{<Alt>s} behave like
selecting "Save" from a menu. This can be done using the following
routine:
@findex fl_set_menu_item_shortcut()
@example
void fl_set_menu_item_shortcut(FL_OBJECT *obj, int miid,
                               const char *str);
@end example
@noindent
@code{miid} is the menu item ID of the menu item under consideration.
@code{str} contains the shortcut for the item. (Actually, it can
contain more shortcuts for the same item.) @xref{Shortcuts}, for more
information about shortcuts.

Finally there is the routine:
@findex fl_show_menu_symbol()
@example
void fl_show_menu_symbol(FL_OBJECT *obj, int yes_no);
@end example
@noindent
With this routine you can indicate whether to show a menu symbol at
the right of the menu label. By default no symbol is shown.


@node Menu Attributes
@subsection Menu Attributes
Any boxtype can be used for a menu except for those of type
@code{FL_PULLDOWN_MENU}, for which @code{FL_NO_BOX} should not be
used.

The first color arguemt (@code{col1}) to @code{fl_set_object_color()}
controls the color of the menu's box when not open and the second
(@code{col2}) is the color when the menu is shown.

To change the font style and size used in the popup menus (not the menu
label), use the following routines
@findex fl_setpup_default_fontstyle()
@findex fl_setpup_default_fontsize()
@example
void fl_setpup_default_fontstyle(int style);
void fl_setpup_default_fontsize(int size);
@end example
@noindent
These settings apply to all menus at once.

If desired, you can attach an external popup to a menu object via the
following routine
@findex fl_set_menu_popup()
@example
void fl_set_menu_popup(FL_OBJECT *obj, int pupID);
@end example
@noindent
where @code{pupID} is the ID returned by @code{fl_newpup()} or
@code{fl_defpup()}. @xref{XPopup}, for more details on popup
creation.

For a menu created this way only @code{fl_get_menu()} and
@code{fl_get_menu_text()} work as expected. Other services such as
mode setting and query etc. should be done via the popup routines.

To obtain the popup ID associated with a menu, use the following routine
@findex fl_get_menu_popup()
@example
int fl_get_menu_popup(FL_OBJECT *obj);
@end example
@noindent
The function return the popup ID if the menu was created using
@code{fl_set_menu_popup()} or @code{fl_set_menu_entries()}, otherwise
it returns -1.


@node Menu Remarks
@subsection Remarks

See @file{menu.c} for an example of the use of menus. You can also use
@code{FL_MENU_BUTTON} to initiate a callback and use an XPopup
directly within the callback. See @file{pup.c} for an example of this
approach.


@node Choice Object
@section Choice Object

A choice object is an object that allows the user the choose among a
number of choices. The current choice is shown in the box of the
choice object. The user can either cycle through the list of choices
using the middle or right mouse button or get the list as a menu using
the left mouse button.

@ifnottex

@menu
* Adding Choice Objects:   Adding Choice Objects
* Choice Types:            Choice Types
* Choice Interaction:      Choice Interaction
* Other Choice Routines:   Other Choice Routines
* Choice Attributes:       Choice Attributes
* Remarks:                 Choice Remarks
@end menu

@end ifnottex


@node Adding Choice Objects
@subsection Adding Choice Objects

To add a choice object to a form use the routine
@findex fl_add_choice()
@example
FL_OBJECT *fl_add_choice(int type, FL_Coord x, FL_Coord y,
                         FL_Coord w, FL_Coord h, const char *label);
@end example
@noindent
It shows a box on the screen with the label to the left of it and the
current choice (empty in the beginning), centered in the box.

@node Choice Types
@subsection Choice Types

The following types are available:
@table @code
@tindex @code{FL_NORMAL_CHOICE}
@item FL_NORMAL_CHOICE
Middle/right mouse button shortcut.
@tindex @code{FL_NORMAL_CHOICE2}
@item FL_NORMAL_CHOICE2
Same as @code{FL_NORMAL_CHOICE} except drawn differently.
@tindex @code{FL_DROPLIST_CHOICE}
@item FL_DROPLIST_CHOICE
Menu is activated only by pressing and releasing on the arrow.
@end table
@c ???

@node Choice Interaction
@subsection Choice Interaction

There are two ways in which the user can pick a new choice. One way is
using the right or middle mouse button. Pressing and releasing the
right mouse button on the choice object selects the next choice in the
list. When pressing the middle mouse button the previous choice is
taken. Keeping the mouse pressed slowly cycles through the list. The
other way is to use the left mouse button. In this case a menu appears
from which the user can select the proper choice. In both cases,
whenever a choice is selected (even when it is the original one) the
object is returned to the application program.


@node Other Choice Routines
@subsection Other Choice Routines

There are a number of routines to change the list of possible choices.
To add a line to a choice object use
@findex fl_addto_choice()
@example
int fl_addto_choice(FL_OBJECT *obj, const char *text);
@end example
@noindent
The function returns the number of the new item. The items in the list
are numbered in the order in which they were inserted. The first item
has number 1, etc.

To delete a line use:
@findex fl_delete_choice()
@example
void fl_delete_choice(FL_OBJECT *obj, int line);
@end example

Whenever the application program wants to clear the complete list of
choices it should use the routine
@findex fl_clear_choice()
@example
void fl_clear_choice(FL_OBJECT *obj) 
@end example

One can also replace a line using
@findex fl_replace_choice()
@example
void fl_replace_choice(FL_OBJECT *obj, int line, const char *text);
@end example

To obtain the currently selected item in the choice object use the call
@findex fl_get_choice()
@example
int fl_get_choice(FL_OBJECT *obj);
@end example
@noindent
The function returns the number of the current choice (0 if there is
no choice).

You can also obtain the text of the currently selected choice item
using the call
@findex fl_get_choice_text()
@example
const char *fl_get_choice_text(FL_OBJECT *obj);
@end example
@@noindent
@code{NULL} is returned when there is no current choice.

To obtain the text of an arbitrary choice item, use the following routine
@findex fl_get_choice_item_text()
@example
const char *fl_get_choice_item_text(FL_OBJECT *obj, int n);
@end example

To obtain the total number of choice items, use the following function
@findex fl_get_choice_maxitems()
@example
int fl_get_choice_maxitems(FL_OBJECT *obj);
@end example

One can set various attributes of an item using the following routine
@findex fl_set_choice_item_mode()
@example
void fl_set_choice_item_mode(FL_OBJECT *obj, int numb, unsigned mode);
@end example
@noindent
Here @code{mode} is the same as that used for menu objects (see
above). See also @ref{XPopup}, for details.

You can use the follow routine to populate a choice object at once,
including mode and shortcut, by using
@findex fl_set_choice_entries()
@example
int fl_set_choice_entries(FL_OBJECT *obj, FL_PUP_ENTRY *entries);
@end example
@noindent
where @code{entries} is a pointer to a @code{FL_PUP_ENTRY} structure
(terminated by a @code{NULL} text field) as already described above
for the function @code{fl_set_menu_entries()}. Also see @ref{XPopup},
for more details. Please note that for choice objects no nested
entries are permitted and the item callback functions are ignored. The
function returns the number of items added to the choice object.

Finally, the application program can set the choice itself using the
call
@findex fl_set_choice()
@findex fl_set_choice_text()
@example
void fl_set_choice(FL_OBJECT *obj, int line);
void fl_set_choice_text(FL_OBJECT *obj, const char *txt)
@end example
@noindent
where @code{txt} must maych exactly one of the choice items.
For example, after the following choice is created
@example
fl_addto_choice(obj," item1 | item2 | item3 ");
@end example
@noindent
You can select the second item by either using
@example
fl_set_choice(obj, 2);
@end example
@noindent
or
@example
fl_set_choice_text(obj, " item2 ");
@end example
@noindent
Note the spaces in the text.


@node Choice Attributes
@subsection Choice Attributes

Don't use @code{FL_NO_BOX} as the boxtype for a choice object.

The first color argument (@code{col1} to @code{fl_set_object_color()}
controls the color of the box and the second (@code{col2}) the color
of the text in the box.

The current choice by default is shown centered in the box. To change
the alignment of the choice text in the box, use the following routine
@findex fl_set_choice_align()
@example
void fl_set_choice_align(FL_OBJECT *obj, int align);
@end example

To set the font size used inside the choice object use
@findex fl_set_choice_fontsize()
@example
void fl_set_choice_fontsize(FL_OBJECT *obj, int size);
@end example

To set the font style used inside the choice object use
@findex fl_set_choice_fontstyle()
@example
void fl_set_choice_fontstyle(FL_OBJECT *obj, int style);
@end example

Note that the above functions only change the font inside the choice
object, not the font used in the popup. To change the font used in the
popup, use the following routines
@findex fl_setpup_default_fontsize()
@findex fl_setpup_default_fontstyle()
@example
void fl_setpup_default_fontsize(int size);
void fl_setpup_default_fontstyle(int style)
@end example
noindent Note that these functions influence the ont settings of all
popups. @xref{Label Attributes and Fonts}, for details on font sizes
and styles.


@node Choice Remarks
@subsection Remarks

See @file{choice.c} for an example of the use of choice objects.


@node Browser Object
@section Browser Object

The browser object class is probably the most powerful that currently
exists in the Forms Library. A browser is a box that contains a number
of lines of text. If the text does not fit inside the box, a scrollbar
is automatically added so that the user can scroll through it. A
browser can be used for building up a help facility or to give
messages to the user.

It is possible to create a browser from which the user can select
lines. In this way the user can make its selections from a (possible)
long list of choices. Both single lines and multiple lines can be
selected, depending on the type of the browser.

@ifnottex

@menu
* Adding Browser Objects:   Adding Browser Objects
* Browser Types:            Browser Types
* Browser Interaction:      Browser Interaction
* Other Browser Routines:   Other Browser Routines
* Browser Attributes:       Browser Attributes
* Remarks:                  Browser Remarks
@end menu

@end ifnottex


@node Adding Browser Objects
@subsection Adding Browser Objects

Adding an object To add a browser to a form use the routine
@findex fl_add_browser()
@example
FL_OBJECT *fl_add_browser(int type, FL_Coord x, FL_Coord y,
                          FL_Coord w, FL_Coord h, const char *label);
@end example
@noindent
The meaning of the parameters is as usual. The label is placed below
the box by default.


@node Browser Types
@subsection Browser Types

The following types of browsers exist (see below for more information
about them):
@table @code
@tindex @code{FL_NORMAL_BROWSER}
@item FL_NORMAL_BROWSER
A browser in which no selections can be made.
@tindex @code{FL_SELECT_BROWSER}
@item FL_SELECT_BROWSER
In this case the user can make single line selections.
@tindex @code{FL_HOLD_BROWSER}
@item FL_HOLD_BROWSER
Same but the selection remains visible till the next selection.
@tindex @code{FL_MULTI_BROWSER}
@item FL_MULTI_BROWSER
Multiple selections can be made and remain visible till de-selected.
@end table

Hence, the differences only lie in how the selection process works.


@node Browser Interaction
@subsection Browser Interaction

The user can change the position of the slider or use keyboard cursor
keys (including @code{<Home>}, @code{<PageDown>}, etc.) to scroll
through the text. When he/she presses the left mouse below or above
the slider, the browser scrolls one page (actually one line less than
a page) down or up. Any other mouse button scrolls one line at a time.
When not using an @code{FL_NORMAL_BROWSER}, the user can also make
selections with the mouse by pointing to a line or by using the cursor
keys.

For @code{FL_SELECT_BROWSER}'s, as long as the user keeps the mouse
pressed, the current line under the mouse is highlighted. Whenever he
releases the mouse the highlighting disappears and the browser is
returned to the application program. The application program can now
figure out which line was selected using a call of
@code{fl_get_browser()} to be described below. It returns the number
of the last selected line. (Top line is line 1.)

An @code{FL_HOLD_BROWSER} works exactly the same except that, when the
mouse is released, the selection remains highlighted.

An @code{FL_MULTI_BROWSER} allows the user to select and de-select
multiple lines. Whenever he selects or de-selects a line the browser
is returned to the application program that can next figure out (using
@code{fl_get_browser()} described below) which line was selected. It
returns the number of the last selected line. When the last line was
de-selected it returns the negation of the line number. I.e., if line
10 was selected last the routine returns 10 and if line 10 was
de-selected last, it returns -10. When the user presses the mouse on a
non-selected line and then moves it with the mouse button still
pressed down, he will select all lines he touches with his mouse until
he releases it. All these lines will become highlighted. When the user
starts pressing the mouse on an already selected line he de-selects
lines rather than selecting them.


@node Other Browser Routines
@subsection Other Browser Routines

The maximum length of a line that can be added to a browser is by
default 2048 bytes
@tindex @code{FL_BROWSER_LINELENGTH}
(@code{FL_BROWSER_LINELENGTH}). However, if desired, the
application can enlarge this limit using the following routine
@findex fl_set_default_broswer_maxlinelength()
@example
int fl_set_default_broswer_maxlinelength(int new_length);
@end example
@noindent
The function returns the old limit. Note that the new length affects
all browsers.

There are a large number of routines to change the contents of a browser, select and de-select lines, etc.

To remove all lnes from a browser use
@findex fl_clear_browser()
@example
void fl_clear_browser(FL_OBJECT *obj);
@end example

To add a line to a browser use
@findex fl_add_browser_line()
@example
void fl_add_browser_line(FL_OBJECT *obj, const char *text);
@end example

A second way of adding a line to the browser is to use the call
@findex fl_addto_browser()
@example
void fl_addto_browser(FL_OBJECT *obj, const char *text);
@end example
@noindent
The difference to @code{fl_add_browser_line()} is that with this call
the browser will be shifted such that the newly appended line is
visible. This is useful when e.g.@: using the browser to display
messages.

Sometimes it may be more convenient to add characters to a browser
without implying the starting of a new line. To this end, the
following routine exists
@findex fl_addto_browser_chars()
@example
void fl_addto_browser_chars(FL_OBJECT *obj, const char *text);
@end example
@noindent
This function appends text to the last line in the browser without
advancing the line counter unless text contains embedded newline
characters (@code{'\n'}). In that case, the text before the embedded
newline is appended to the last line, and the line counter is
incremented. The characters after the newline, possibly with more
embedded newlines in it, are then added to the browser via means
similar to @code{fl_addto_browser()}.

You can also insert a line in front of a given line. All lines after
it will be shifted. Note that the top line is numbered 1 (not 0).
@findex fl_insert_browser_line()
@example
void fl_insert_browser_line(FL_OBJECT *obj, int line,
                            const char *text);
@end example
@noindent
Inserting into an empty browser or after the last line in the browser
is the same as adding a line with e.g. @: @code{fl_add_browser_line()}.

To delete a line (shifting the following lines) use:
@findex fl_delete_browser_line()
@example
void fl_delete_browser_line(FL_OBJECT *obj, int line);

@end example

One can also replace a line using
@findex fl_replace_browser_line()
@example
void fl_replace_browser_line(FL_OBJECT *obj, int line,
                             const char *text);
@end example

Making many changes to a visible browser at the same moment, i.e.,
clearing it and loading it with a number of new choices, is slow
because the browser is redrawn after each change. The Forms Library
has a mechanism for avoiding this using the calls
@code{fl_freeze_form()} and @code{fl_unfreeze_form()}. So a piece of
code that fills in a visible browser should preferably look like the
following
@example
fl_freeze_form(brow->form);
fl_clear_browser(brow);
fl_add_browser_line(brow,"line 1");
fl_add_browser_line(brow,"line 2");
...
fl_unfreeze_form(brow->form);
@end example
@noindent
where @code{brow->form}q is the form that contains the browser object
named @code{brow}.

To obtain the contents of a particular line in the browser, use
@findex fl_get_browser_line()
@example
const char *fl_get_browser_line(FL_OBJECT *obj, int line);
@end example
@noindent
It returns a pointer to the particular line of text.

It is possible to load an entire file into a browser using
@findex fl_load_browser()
@example
int fl_load_browser(FL_OBJECT *obj, const char *filename);
@end example
@noindent
The routine returns whether or not the file name was successfully
loaded. If the file name is an empty string the browser is simply
cleared. This routine is particularly useful when using the browser
for a help facility. You can create different help files and load the
needed one depending on context.

The application program can select or de-select lines in the browser.
To this end the following calls exist with the obvious meaning:
@findex fl_select_browser_line()
@findex fl_deselect_browser()
@findex fl_deselect_browser_line()
@example
void fl_select_browser_line(FL_OBJECT *obj, int line);
void fl_deselect_browser_line(FL_OBJECT *obj, int line);
void fl_deselect_browser(FL_OBJECT *obj);
@end example
@noindent
The last call de-selects all lines.

To check whether a line is selected, use the routine
@findex fl_isselected_browser_line()
@example
int fl_isselected_browser_line(FL_OBJECT *obj, int line);
@end example

The routine
@findex fl_get_browser_maxline()
@example
int fl_get_browser_maxline(FL_OBJECT *obj);
@end example
@noindent
returns the number of lines in the browser. For example, when the
application program wants to figure out which lines in a
@code{FL_MULTI_BROWSER} are selected code similar to the following can
be used:
@example
int total_lines = fl_get_browser_maxline(brow);
for (i = 1; i <= total_lines; i++)
    if (fl_isselected_browser_line(brow,i))
        /* Handle the selected line */
@end example

Sometimes it is useful to know how many lines are visible in the
browser. To this end, the following call can be used
@findex fl_get_browser_screenlines()
@example
int fl_get_browser_screenlines(FL_OBJECT *obj);
@end example

To obtain the last selection made by the user, e.g. when the browser
is returned, the application program can use the routine
@findex fl_get_browser()
@example
int fl_get_browser(FL_OBJECT *obj);
@end example
@noindent
It returns the line number of the last selection being made (0 if no
selection was made). When the last action was a de-selection (only for
@code{FL_MULTI_BROWSER}'s) the negative of the de-selected line number
is returned.

There are also calls to influence and query the top line shown in the
browser's box (i.e.@: influence the position of the slider).
@findex fl_set_browser_topline()
@findex fl_get_browser_topline()
@example
void fl_set_browser_topline(FL_OBJECT *obj, int line);
int fl_get_browser_topline(FL_OBJECT *obj);
@end example
@noindent
Note that the index of the top line is 1, not 0.

It is possible to register a callback function that gets called when a
line is double-clicked. To this end, the following function can be
used:
@findex fl_set_browser_dblclick_callback()
@example
void fl_set_browser_dblclick_callback(FL_OBJECT *obj,
                                      void (*cb)(FL_OBJECT *, long),
`                                     long data);
@end example
@noindent
Of course, double-click callbacks make most sense for
@code{FL_HOLD_BROWSER}s.

Finally there is a routine that can be used to programmatically scroll
the text horizontally
@findex fl_set_browser_xoffset()
@example
void fl_set_browser_xoffset(FL_OBJECT *obj, FL_Coord xoff);
@end example
@noindent
where @code{xoff} indicates how many pixels to scroll to the left
relative to the nominal position of the text lines.

There is also a function that can be used to obtain the current
xoffset if needed:
@findex fl_get_browser_xoffset()
@example
FL_Coord fl_get_browser_xoffset(FL_OBJECT *obj);
@end example

@node Browser Attributes
@subsection Browser Attributes

Never use the boxtype @code{FL_NO_BOX} for browsers.

The first color argument (@code{col1}) to @code{fl_set_object_color()}
controls the color of the browser's box, the second (@code{col2}) the
color of the selection. The text color is the same as the label color.

To set the font size used inside the browser use
@findex fl_set_browser_fontsize()
@example
void fl_set_browser_fontsize(FL_OBJECT *obj, int size);
@end example

To set the font style used inside the browser use
@findex fl_set_browser_fontstyle()
@example
void fl_set_browser_fontstyle(FL_OBJECT *obj, int style);
@end example
@noindent
@xref{Label Attributes and Fonts}, for details on font sizes and
styles.

It is possible to change the appearance of individual lines in the
browser. Whenever a line starts with the symbol @code{@@} the next
letter indicates the special characteristics associated with this line.
The following possibilities exist at the moment:
@table @code
@item f
Fixed width font.
@item n
Normal (Helvetica) font.
@item t
Times-Roman like font.
@item b
Boldface modifier.
@item i
Italics modifier.
@item l
Large (new size is @code{FL LARGE SIZE}).
@item m
Medium (new size is @code{FL MEDIUM SIZE}).
@item s
Small (new size is @code{FL SMALL SIZE}).
@item L
Large (new size = current size + 6)
@item M
Medium (new size = current size + 4)
@item S
Small (new size = current size - 2).
@item c
Centered.
@item r
Right aligned.
@item _
Draw underlined text.
@item -
An engraved separator. Text following @code{-} is ignored.
@item C
The next number indicates the color index for this line.
@item N
Non-selectable line (in selectable browsers).
@item @@
Regular @code{@@} character.
@end table

The modifiers (bold and itatic) work by adding @code{FL_BOLD_STYLE}
and @code{FL_ITALIC_STYLE} to the current active font index to look up
the font in the font table (you can modify the table using
@code{fl_set_font_name()}).

More than one option can be used by putting them next to each other.
For example, @code{"@@C1@@l@@f@@b@@cTitle"} will give you the red,
large, bold fixed font, centered word @code{"Title"}. As you can see
the font change requests accumulate and the order is important, i.e.,
@code{"@@f@@b@@i"} gives you a fixed bold italic font while
@code{"@@b@@i@@f"} gives you a (plain) fixed font.

One word of caution is required here: The line spacing inside the
browser is not changed! Hence, when using a large line, you had better
take care that there is an empty line above and below it.

In some cases the character @code{@@} might need to be placed at the
beginning of the lines without introducing the special meaning
mentioned above. In this case you can use @code{@@@@} or change the
special character to something other than @code{@@} using the
following routine
@findex fl_set_browser_specialkey()
@example
void fl_set_browser_specialkey(FL_OBJECT *obj, int key);
@end example

To align different text fields on a line, tab characters (@code{'\t'})
can be embedded in the text. See @code{fl_set_tabstop()} on how to set
tabstops.

There are two functions to turn the scrollbars on and off:
@findex fl_set_browser_hscrollbar()
@findex fl_set_browser_vscrollbar()
@example
void fl_set_browser_hscrollbar(FL_OBJECT *obj, int how);
void fl_set_browser_vscrollbar(FL_OBJECT *obj, int how);
@end example
@noindent
@code{how} can be set to the following values:
@table @code
@tindex @code{FL_ON}
@item FL_ON
Always on.
@tindex @code{FL_OFF}
@item FL_OFF
Always off.
@tindex @code{FL_AUTO}
@item FL_AUTO
On when needed (i.e., more lines/chars than could be shown)
@end table
@noindent
@code{FL_AUTO} is the default.

Sometimes, it may be desirable for the application to obtain the
scrollbar positions when they change (e.g., to use the scrollbars of
one browser to control other browsers). To this end, the following
routines are available
@tindex @code{FL_BROWSER_SCROLL_CALLBACK}
@findex fl_set_browser_hscroll_callback()
@findex fl_set_browser_vscroll_callback()
@example
typedef void (*FL_BROWSER_SCROLL_CALLBACK)(FL_OBJECT *, int, void *);
void fl_set_browser_hscroll_callback(FL_OBJECT *obj,
                                     FL_BROWSER_SCROLL_CALLBACK cb,
                                     void *cb_data);
void fl_set_browser_vscroll_callback(FL_OBJECT *obj,
                                     FL_BROWSER_SCROLL_CALLBACK cb,
                                     void *cb_data);
@end example
@noindent
After scroll callbacks are set whenever the scrollbar changes position
the callback function is called as
@example
cb(ob, offset, cb_data);
@end example
@noindent
The first argument to the callback function @code{cb} is the browser
object, the second argument is the new xoffset for the horizontal
scrollbar or the new top line for the vertical scrollbar. The third
argument is the callback data specified as the third argument in the
function calls to install the callback.

To uninstall a scroll callback, use a @code{NULL} pointer as the
callback function.

By default, the scrollbar size is determined based on the initial size
of the browser. To change the default, use the following routine
@findex fl_set_browser_scrollbarsize()
@example
void fl_set_browser_scrollbarsize(FL_OBJECT *obj, int hh, int vw);
@end example
@noindent
where @code{hh} is the horizontal scrollbar height and @code{vw} is
the vertical scrollbar width. Use reset to the default.

The default scrollbar type is @code{FL_THIN_SCROLLBAR}. There are two
ways you can change the default. One way is to use
@code{fl_set_defaults()} or @code{fl_set_scrollbar_type()}q to set the
application wide default, another way is to use
@code{fl_get_object_component()} to get the object handle to the
scrollbars and change the the object type forcibly. The first method
is preferred because the user can override the setting via resources.
Although the second method of changing the scrollbar type is not
recommended, the object handle obtained can be useful in changing the
scrollbar colors etc.

Finally there is a routine that can be used to obtain the browser size
in pixels for the text area
@findex fl_get_browser_dimension()
@example
void fl_get_browser_dimension(FL_OBJECT *obj, FL_Coord *x, FL_Coord *y,
                              FL_COORD *w, FL_COORD *h);
@end example
@noindent
where @code{x} and @code{y} are measured from the top-left corner of
the form (or the smallest enclosing window). To establish the
relationship between the text area (a function of scrollbar size,
border with and text margin), you can compare the browser size and
text area size.


@node Browser Remarks
@subsection Remarks

There is currently a limit of a maximum of 2048 bytes per line for
@code{fl_load_browser()}.

See @file{fbrowse1.c} for an example program using a
@code{FL_NORMAL_BROWSER} to view files. @file{browserall.c} shows all
different browsers. @file{browserop.c} shows the insertion and
deletion of lines in a @code{FL_HOLD_BROWSER}.

For the browser class, especially multi browsers, interaction via
callbacks is strongly recommended.
