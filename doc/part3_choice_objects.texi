@node Part III Choice Objects
@chapter Choice Objects

@ifnottex

@menu
* Select Object:   Select Object
* Menu Object:     Menu Object
* Browser Object:  Browser Object
@end menu

@end ifnottex


@node Select Object
@section Select Object

A select object is a rather simple object that allows the user to
pick alternatives from a linear list that pops up when he clicks on
the object. It remembers the last selected item, which is also
shown on top of the select object.

The select object internally uses a popup (@pxref{Part III Popups})
and thus it can be helpful to understand at lest some aspects of how
popups work to fully grasp the functionality of select objects.


@ifnottex

@menu
* Adding Select Objects:   Adding Select Objects
* Select Interaction:      Select Interaction
* Other Select Routines:   Other Select Routines
* Select Attributes:       Select Attributes
* Remarks:                 Select Remarks
@end menu

@end ifnottex


@node Adding Select Objects
@subsection Adding Select Objects

To add a select object to a form use
@findex fl_add_select()
@anchor{fl_add_select()}
@example
FL_OBJECT *fl_add_select(int type, FL_Coord x, FL_Coord y,
                         FL_Coord w, FL_Coord h, const char *label)
@end example
@noindent
There are currently three types which just differ by the way they
look:
@table @code
@tindex FL_NORMAL_SELECT
@item FL_NORMAL_SELECT
Per default this type is drawn as a rounded, flat box (but you can
change that by setting a different boxtype for the object) with the
text of the currently selected item in its center.
@tindex FL_MENU_SELECT
@item FL_MENU_SELECT
This select object looks like a button with a little extra box at the
right (just like a @code{FL_MENU_BUTTON} and the text of the
currently selected item drawn on the button.
@tindex FL_DROPLIST_SELECT
@item FL_DROPLIST_SELECT
This type looks like a button with the text of the currently selected
item on top of it and a second square button directly beside it with
an downward pointing arrow on it.
@end table

Per default @code{label} is drawn outside and to the left of the
object.

Once a new select object has been created items have to be added to
it. For this the following function exists:
@findex fl_add_select_items()
@anchor{fl_add_select_items()}
@example
FL_POPUP_ENTRY *fl_add_select_items(FL_OBJECT *obj, const char items,
                                    ...);
@end example
@noindent
@code{items} is a string with the items to add, separated by the
@code{|} character. In the simplest case you would just use something
like @code{"Item 1|Item 2|Item 3"} to add three items to the list.
If there weren't any items before the firs item will be automatically
shown as the selected one.

As also described in the docmentation for the similar function
@code{@ref{fl_popup_add_entries()}} (@pxref{Adding Popups}) the text
for an item may contain "special sequences" that start with the
character @code{%} and the may require an additional argument passed
to the function after the @code{items} argument:
@table @code
@item %x
Set a value of type @code{long int} that's passed to all callback
routines for the item. The value must be given in the arguments
following the @code{items} string.
@item %u
Set a @code{user_void} pointer that's passed to all callbacks of the
item. The pointer must be specified in the arguments following the
@code{items} string.
@item %f
Set a callback function that gets called when the item is selected.
The function is of type
@example
int callback(FL_POPUP_RETURN *r);
@end example
Informaton about the item etc.@: gets passed to the callback function
via the @code{FL_POPUP_RETURN} structure (see below) and the return
value of the function can be used to keep the selection being made
form becoming reported back to the user made by returning a value of
@code{FL_IGNORE} (-1). The functions address must be given in the
arguments following the @code{items} string.
@item %E
Set a callback routine that gets called each time the mouse enters the
item (as long as the item isn't disabled or hidden). The type of the
function is the same as that of the callback function for the
selection of the item but it's return value is never used. The
functions address must be given in the arguments following the
@code{items} string.
@item %L
Set a callback routine that gets called each time the mouse leaves the
item. The type of the function is the same that as of the callback
function for the selection of the item but it's return value is never
used. The functions address must be given in the arguments following
the @code{items} string.
@item %d
Marks the item as disabled, i.e.@: it can't be selected and its text
is per default drawn in a different color
@item %h
Marks the item as hidden, i.e.@: it is not shown while in this state.
@item %S
For items with shortcut keys it's quite common to have them shown on
the right hand side. Using @code{%S} you can split the items text
into two parts, the first one (before @code{%S}) being drawn flushed
left and the second part flushed right. Note that using this special
sequence doesn't automatically sets a shortcut key, this still has to
be done using @code{%s}.
@item %s
Sets one or more shortcut keys for an item. Requires a string with the
shortcuts in the arguments following the @code{items} string.
@xref{Shortcuts}, for details on how to define shortcuts. Please note
that the character in the label idenical to the shortcut character is
only shown as underlined if @code{%S} isn't used.
@item %%
Use this to get a @code{%} within the text of an item.
@end table
@noindent
If you compare this list of "special sequences" with those listed for
the @code{@ref{fl_popup_add_entries()}} function you will find that
aome are missing. This is because a select object is a simple linear
list of items that uses only parts of the popups functionalities.

Another way to "populate" a select object is to create a popup
directly and then associate it with the selecy object using
@findex fl_set_select_popup()
@anchor{fl_set_select_popup()}
@example
int fl_set_select_popup(FL_OBJECT *obj, FL_POPUP  *popup);
@end example
@noindent
Please note that the popup the argument @code{popup} points to may
not contain any entries than those of type @code{FL_POPUP_NORMAL}
(and, of course, the popup can't be a sub-popup of another popup).


@node Select Interaction
@subsection Select Interaction

The simplest interaction with a select object consists of clicking
onto the object and then selecting an item in the popup that gets
shown directly beside the mouse position.

If you click with the left or right mouse button onto the select
object previous or next item, respectively, will be selected. If
youl keep the left or mouse button pressed down for a longer time
slowly all alternatives are selected, one after each other.

You finally can also use the scroll wheel of your mouse to select
the next or previous item (scrolling down selects the next, scrolling
up the previous item).

On every selection of an item (also if the already selected item is
re-selected) a callback that may have been associated with the item is
executed. The callback receives as its argument a pointer to a
structure of type @code{FL_POPUP_RETURN}
@tindex FL_POPUP_RETURN
@example
typedef struct @{
    long int              val;       /* value assigned to entry */
    void                 *user_data; /* pointer to user data */
    const char           *text;      /* text of selected popup entry */
    const char           *label;     /* left-flished text */        
    const char           *accel;     /* right-flushed text */
    const FL_POPUP_ENTRY *entry;     /* selected popup entry */
    const FL_POPUP       *popup;     /* popup we're called for */
@} FL_POPUP_RETURN;
@end example
@noindent
The @code{val} member is a integer value associated with the entry.
It can be set explicitely on creationg of the item using the @code{%x}
"special sequence". If not given then first item gets the value 0,
the next 1 etc. @code{user_data} is a pointer to some user data, which
can be set on creation of the item using @code{%u}. @code{text} is the
string used in creating the item, including all "special sequences",
while @code{label} is the string shown in the popup for the item. If
there was a special sequence of @code{%S} in the string that was used
to create the item @code{accel} is the text that appears right-flushed
in the popup for the item. @code{entry} is a pointer to the popup
entry that represents the item in the select object and, finally,
@code{popup} is the popup associated with the select object.

Normally, when a new item is selected this is reported back to the
caller either by calling the select objects callback (if one exists)
or by returning the onject as the result of a call of e.g.@:
@code{@ref{fl_do_forms()}}. But if the callback for the item itself returns
@code{FL_IGNORE} then this doesn't happen. This can be useful for
cases where all work for a change of the selection can be already done
with in the item callback and the "main loop" shouldn't get involved
anymore.

Per default the popup of a select objects remains shown when the user
releases the mouse somewhere outside the popup window (or on its title
area). The alternative is to close the popup immediately when the user
releases the mouse, independent of where it is. Using the function
@findex fl_set_select_policy()
@anchor{fl_set_select_policy()}
@example
int fl_set_select_policy(FL_OBJECT *obj, int policy);
@end example
@noindent
the program can switch between these two modes of operation,
where @code{policy} can be on of two values:
@table @code
@tindex FL_POPUP_NORMAL_SELECT
@item FL_POPUP_NORMAL_SELECT
Keeps the popup opened when the mouse isn't released on one of the
selectable items.
@tindex FL_POPUP_DRAG_SELECT
@item FL_POPUP_DRAG_SELECT
Close the popup immediately when the mouse button is released.
@end table

The function returns on success the previous setting of the "policy"
and -1 on error.


@node Other Select Routines
@subsection Other Select Routines

To find out which item is currently selected use
@findex fl_get_select_item()
@anchor{fl_get_select_item()}
@example
FL_POPUP_RETURN *fl_get_select_item(FL_OBJECT *obj); 
@end example
@noindent
It returns a pointer to a structure of type @code{FL_POPUP_RETURN} as
already described directly above, containing all needed information
about the selected item.

For some actions, e.g.@: deletion of an item etc.; it is necessary to
knw the popup entry that stands for. Therefore it's possible to search
the list of items accoring to several criteria:
@findex fl_get_select_item_by_value()
@anchor{fl_get_select_item_by_value()}
@findex fl_get_select_item_by_label()
@anchor{fl_get_select_item_by_label()}
@findex fl_get_select_item_by_text()
@anchor{fl_get_select_item_by_text()}
@example
FL_POPUP_ENTRY *fl_get_select_item_by_value(FL_OBJECT *obj, long val);
FL_POPUP_ENTRY *fl_get_select_item_by_label(FL_OBJECT *obj,
                                            const char *label);
FL_POPUP_ENTRY *fl_get_select_item_by_label(FL_OBJECT *obj,
                                            const char *text);
@end example
The first function, @code{@ref{fl_get_select_item_by_value()}},
searches through the list of items and returns the first one with the
@code{val} associated with the item (or @code{NULL} if none is found).
The second, @code{@ref{fl_get_select_item_by_label()}} searches for a
certain label as displayed for the iten in the popup. The third,
@code{@ref{fl_get_select_item_by_text()}} searches for the text the
item was created by (that might be the same as the label text in
simple cases). Please note that all functions return a structure of
type @code{FL_POPUP_ENTRY} (and not @code{FL_POPUP_RETURN}, which
gives you direct access to the entry in the popup for the item.

Using e.g.@: the result of one of the functions above you can also
set the currently selected item via your program using
@findex fl_set_select_item()
@anchor{fl_set_select_item()}
@example
FL_POPUP_RETURN *fl_set_select_item(FL_OBJECT *obj,
					                FL_POPUP_ENTRY *entry);
@end example

Or you could use the result to delete an item:
@findex fl_delete_select_item()
@anchor{fl_delete_select_item()}
@example
int fl_delete_select_item(FL_OBJECT *obj, FL_POPUP_ENTRY *entry);
@end example
@noindent
Please note that the values associated with items won't change due to
removing an item.

Alternatively, you can replace an item by one or more new ones.
To do that use
@findex fl_replace_select_item()
@anchor{fl_replace_select_item()}
@example
FL_POPUP_ENTRY *fl_replace_select_item(FL_OBJECT *obj,
               		                   FL_POPUP_ENTRY *old,
	                                   const char *new_items, ...);
@end example
@noindent
@code{old} designates the item to be removed and @code{new_items} is a
string exactly like it would be used in @code{@ref{fl_add_select_items()}}
for the @code{items} argument, that defines the item(s) to replace the
existing item. Please note that, unless values to be associated with
the items (see the @code{val} member of the @code{FL_POPUP_RETURN}
structure) there's a twist here. When items get created they per
default reeive increasing values, starting at 0. This also holds for
items that get created in the process of replacement. The result is
that the ordering of those values in that case won;t represent the
order in whch they appear in the select objects popup.

Another sometimes useful function allows to insert new items somewhere
in the middle of a list of already existing items:
@findex fl_insert_select_item()
@anchor{fl_insert_select_item()}
@example
FL_POPUP_ENTRY *fl_insert_select_item(FL_OBJECT *obj,
               		                  FL_POPUP_ENTRY *after,
	                                  const char *new_items, ...);
@end example
@noindent
@code{after} is the entry after which the new item(s) are to be
inserted (if it's @code{NULL} the new items are inserted at the very
start). The rest of the argumnts are the same as for
@code{@ref{fl_replace_select_item()}} and the same caveats about the
values associated autimatically with the new items holds.

It's possible to remove all items from a select object by calling
@findex fl_clear_select()
@anchor{fl_clear_select()}
@example
int fl_clear_select(FL_OBJECT *obj);
@end example
@noindent
Afterwards you have to call again e.g.@:
@code{@ref{fl_add_select_items()}} to set new entries. Note that if
you used @code{@ref{fl_set_select_popup()}} to set a popup for the
select object then that popup gets deleted automatically on calling
@code{@ref{fl_clear_select()}}! The values automatically associated
with items when calling @code{@ref{fl_add_select_items()}} will start
at 0 again.


@node Select Attributes
@subsection Select Attributes

Normally, the popup shown for a select object has no title. You can
set a title to be displayed in the popup by calling the function
@findex fl_set_select_popup_title()
@anchor{fl_set_select_popup_title()}
@example
FL_OBJECT *fl_set_select_popup_title(FL_OBJECT *obj, const char *title);
@end example
@noindent
Calling the function with @code{title} set to @code{NULL} or pointing
to an empty string display of a title can also be switched off.

The various colors used for the select item and its popup can be
controlled via a single function
@findex fl_set_select_color()
@anchor{fl_set_select_color()}
@example
FL_COLOR fl_set_select_color(FL_OBJECT *obj, int type, FL_COLOR color);
@end example
The @code{type} argument tells which of the different colors is to be
changed:
@table @code
@tindex FL_SELECT_NORMAL_COLOR
@item FL_SELECT_NORMAL_COLOR
Color the select item is to be drawn in normally (this can also be set
via the first color argument to @code{@ref{fl_set_object_color()}}).
@tindex FL_SELECT_HIGHLIGHT_COLOR
@item FL_SELECT_HIGHLIGHT_COLOR
Color the select object is drawn in when the mose is above it (this
can also be set via the second color argument to
@tindex FL_SELECT_LABEL_COLOR
@item FL_SELECT_LABEL_COLOR
Color the text of the label beside the select object is drawn (this
can also be set via the @code{@ref{fl_set_object_lcol()}} function).
@tindex FL_SELECT_TEXT_COLOR
@item FL_SELECT_TEXT_COLOR
Color the text on top of the select object with the label of the
currently selected item is drawn.
@tindex FL_SELECT_POPUP_BACKGROUND_COLOR
@item FL_SELECT_POPUP_BACKGROUND_COLOR
Color to be used for the background of the popup for the select
object.
@tindex FL_SELECT_POPUP_HIGHLIGHT_COLOR
@item FL_SELECT_POPUP_HIGHLIGHT_COLOR
Color of the item of the popup the mouse is hovering over.
@tindex FL_SELECT_POPUP_TITLE_COLOR
@item FL_SELECT_POPUP_TITLE_COLOR
Color of the text of the title of the popup (if one is shown).
@tindex FL_SELECT_POPUP_TEXT_COLOR
@item FL_SELECT_POPUP_TEXT_COLOR
Color of the texts of the items
@tindex FL_SELECT_POPUP_HIGHLIGHT_TEXT_COLOR
@item FL_SELECT_POPUP_HIGHLIGHTTEXT_COLOR
Color of the texts of the items when the mouse is hovering over the
item.
@tindex FL_SELECT_POPUP_DISABLED_TEXT_COLOR
@item FL_SELECT_POPUP_DISABLED_COLOR
Color of the text if items that are disabled.
@end table

The functions returns the previously set color or @code{FL_MAX_COLORS}
if an error was detected.

You can also query the above listed colors by calling
@findex fl_get_select_color()
@anchor{fl_get_select_color()}
@example
FL_COLOR fl_get_select_color(FL_OBJECT *obj, int type);
@end example

Similar functions exist to control or query the fonts used for the
various elements of a select object:
@findex fl_set_select_font()
@anchor{fl_set_select_font()}
@findex fl_get_select_font()
@anchor{fl_get_select_font()}
@example
int fl_set_select_font(FL_OBJECT *obj, int type, int style, int size);
int fl_get_select_font(FL_OBJECT *obj, int type, int *style, int *size);
@end example
@noindent
The type argument can be set to one of
@table @code
@tindex FL_SELECT_TEXT_FONT
@item FL_SELECT_TEXT_FONT
Font used for the text of the currently selected item of the select
object.
@tindex FL_SELECT_POPUP_TEXT_FONT
@item FL_SELECT_POPUP_TEXT_FONT
Font used for drawing the title of the popup of the select object.
@tindex FL_SELECT_ITEM_TEXT_FONT
@item FL_SELECT_ITEM_TEXT_FONT
Font for the the items in the popup of the select object.
@tindex FL_SELECT_LABEL_FONT
@item FL_SELECT_LABEL_FONT
Font used for the label of the select object (you can as well use
@code{@ref{fl_set_object_lstyle()}} and
@code{@ref{fl_set_object_lsize()}} to set the labels font).
@end table

To control the alignment of the text with the currently selected item
on top of the select object use
@findex fl_set_select_text_align()
@anchor{fl_set_select_text_align()}
@example
int fl_set_select_text_align(FLOBJECT *obj, int align);
@end example
@noindent
Please note that the @code{FL_ALIGN_INSIDE} flag must be set with
@code{align} since the text always will be drawn withing the
boundaries of the object. On success the function return the old
setting for the alignemnt or -1 on error.


Finally, you may change the border width of the popup of the select
object which per default is set to the same value as the default width
of popups.
@findex fl_set_select_popup_bw()
@anchor{fl_set_select_popup_bw()}
@example
int fl_set_select_popup_bw( FL_OBJECT *obj, int bw);
@end example
@noindent
On success the function returns the previous setting of the border
width, on errors @code{INT_MIN}.


@node Select Remarks
@subsection Remarks



@node Menu Object
@section Menu Object

Also menus can be added to forms. These menus can be used to let the
user choose from many different possibilities. Each menu object has a
box with a label in it in the form. Whenever the user presses the
mouse inside the box (or moves the mouse on top of the box) a pop-up
menu appears. The user can then make a selection from the menu.

@ifnottex

@menu
* Adding Menu Objects:   Adding Menu Objects
* Menu Types:            Menu Types
* Menu Interaction:      Menu Interaction
* Other Menu Routines:   Other Menu Routines
* Menu Attributes:       Menu Attributes
* Remarks:               Menu Remarks
@end menu

@end ifnottex


@node Adding Menu Objects
@subsection Adding Menu Objects

To add a menu to a form use the routine
@findex fl_add_menu()
@anchor{fl_add_menu()}
@example
FL_OBJECT *fl_add_menu(int type, FL_Coord x, FL_Coord y,
                       FL_Coord w, FL_Coord h, const char *label)
@end example
@noindent
It shows a box on the screen with the label centered in it.


@node Menu Types
@subsection Menu Types

The following types are available:
@table @code
@tindex FL_PUSH_MENU
@item FL_PUSH_MENU
The menu appears when the user presses a mouse button on it.
@tindex FL_PULLDOWN_MENU
@item FL_PULLDOWN_MENU
The menu appears when the user presses a mouse button on it.
@tindex FL_TOUCH_MENU
@item FL_TOUCH_MENU
The menu appears when the user move the mouse inside it.
@end table

@code{FL_PUSH_MENU} and @code{FL_PULLDOWN_MENU} behave rather similar.
When you click on a @code{FL_PUSH_MENU} per default a pop-up window
gets opened on top of the @code{FL_PUSH_MENU} menu's box that has a
label at the top, indicating the currently selected menu item. The
pop-up window stays open until you either select an item or press a
mouse button somewhere outside the pop-up window.

When you click on @code{FL_PULLDOWN_MENU} also a pop-up window is
shown, but directly below the menu's box. This pop-up window has
no label and it only stays open until you release the mouse button.

@code{FL_PUSH_MENU} and @code{FL_PULLDOWN_MENU} can be made even more
similar by using the @code{@ref{fl_set_menu_notitle()}} function (see
below). This changes it's properties so that the pop-up window also
appears below the menu's box and that no label is shown in the pop-up
window. The only remaining difference then is that a
@code{FL_PUSH_MENU} only gets closed when a menu item is selected or
the user presses the mouse outside of the pop-up window while a
@code{FL_PULLDOWN_MENU} also gets closed when the mouse button is
released.


@node Menu Interaction
@subsection Menu Interaction

When the menu appears the user can make a selection using the left
mouse button or make no selection by clicking outside the menu (or by
simply releasing the mouse button in case of a @code{FL_PULLDOWN_MENU}
type menu. When he makes a selection the menu object is returned by
the interaction routines.

@node Other Menu Routines
@subsection Other Menu Routines

There are two ways to populate a menu, i.e.@: add items. The first one
is a bit more complex but allows for more flexibility, e.g.@: later
adding and removing items, associating callbacks with individual items
etc. For the more simple (and in many cases sufficient) method see the
function @code{@ref{fl_set_menu_entries()}}.

To set the actual menu for a menu object, use the routine
@findex fl_set_menu()
@anchor{fl_set_menu()}
@example
void fl_set_menu(FL_OBJECT *obj, const char *menustr, ...);
@end example
@noindent
@code{menustr} describes the menu in the form used by XPopups
(@pxref{XPopup}). In the simplest case, it just contains the texts fr
the menu items, separated by a bar (@code{'|'}), e.g.@:
@code{"First|Second|Third"}. But it's also possible to employ special
tags (@pxref{Creating XPopups}) that can be used to indicate special
attributes (radio, toggle and greyed-out, for example). Whenever the
user selects a menu item, a pointer to the menu object it belongs to
is returned to the application program.

Please note that if you call @code{@ref{fl_set_menu()}} on a menu that
already contains items those items are removed. The function calls
@code{@ref{fl_clear_menu()}} internally before the new items are
added.

If you explicitely assign a menu item ID to a menu using the special
tag @code{%x} it is your responsibility to make sure that this ID
isn't already used by a different menu item in the same menu. Failure
to do so may make it impossible to use the menu properly. All
functions working on items expect the menu item ID as one of their
arguments.

In case you don't set menu item IDs they are assigned automatically
with the first item obtaining the menu item ID 1, the next 2 etc.,
i.e.@: it directly reflects the position of the item in the menu.

It is also possible to add menu items to an existing menu using a call
of
@findex fl_addto_menu()
@anchor{fl_addto_menu()}
@example
int fl_addto_menu(FL_OBJECT *obj, const char *menustr, ...);
@end example
@noindent
where @code{menustr} is a string of the same form as used in
@code{@ref{fl_set_menu()}} (you can add one or more new menu items
this way).

Also routines exist to delete a particular menu item or change it:
@findex fl_delete_menu_item()
@anchor{fl_delete_menu_item()}
@findex fl_replace_menu_item()
@anchor{fl_replace_menu_item()}
@example
void fl_delete_menu_item(FL_OBJECT *obj, int miid);
void fl_replace_menu_item(FL_OBJECT *obj, int miid,
                           const char *menustr, ...);
@end example
@code{miid} is the menu item ID. @code{menustr} must be a string as
used in @code{@ref{fl_set_menu()}} with the only difference that only
a single menu item can be specified.

Please note: when deleting a menu item all other items keep their
menu item IDs. The menu item ID of the deleted menu item isn't
re-used when new items are added later. Instead for each menu an
internal counter exists that gets incremented for each menu item
added and which value is used for the menu item ID unless one is
explicitely assigned to the menu item. The counter oly gets reset to 1
when the menu is cleared used @code{@ref{fl_clear_menu()}}.

The menu item ID of a menu item changed by using
@code{@ref{fl_replace_menu_item()}} does not change unless the library
is explicitely asked to via @code{%x} in @code{menustr}.

For most applications, the following routine may be easier to use at
the expense of somewhat restrictive value a menu item can have as
well as a loss of the ability to delete menu items or associate
callbacks with menu items. 
@findex fl_set_menu_entries()
@anchor{fl_set_menu_entries()}
@example
int fl_set_menu_entries(FL_OBJECT *obj, FL_PUP_ENTRY *ent);
@end example
@noindent
where @code{ent} is a pointer to an array of structure of the
following type, terminated by an element, where at least the
@code{text} member is a @code{NULL} pointer:
@tindex FL_PUP_ENTRY
@example
typedef struct @{
    const char *text;
    FL_PUP_CB callback;
    const char *shortcut;
    int mode;
@} FL_PUP_ENTRY;
@end example
The meaning of each member is explained in Section 21.3. For menus,
item callback function can be @code{NULL} if the menu callback handles
the interaction results. See demo program @file{popup.c} for an
example use of @code{@ref{fl_set_menu_entries()}}.

The function @code{@ref{fl_set_menu_entries()}} works by creating and
associating a popup menu with the menu object. The popup ID is
returned by the function. Whenever the function is called, the old
popup associated with the object (if one exists) is freed and a new
one is created. Although you can manipulate the menu either through
the menu API (but adding and removing menu items is not supported for
menus created this way ) or popup API, the application should not free
the popup directly and use @code{@ref{fl_clear_menu()}} instead.


To clear the whole menu use
@findex fl_clear_menu()
@anchor{fl_clear_menu()}
@example
void fl_clear_menu(FL_OBJECT *obj);
@end example

To find the menu item selected by the user use
@findex fl_get_menu()
@anchor{fl_get_menu()}
@example
int fl_get_menu(FL_OBJECT *obj);
@end example
@noindent
The the function returns the menu item ID. In the simplest possible
case this is just the position of the menu item (starting at 1). This
stops to be true when either IDs have been explicitely assigned to
items or items have been deleted. In that case the following rules
apply:
@enumerate
@item
A menu item ID may have been assigned to a menu item using @code{%xn}
in the string for the text of the menu item.
@item
Menu items can get associated with a callback function that is
executed when the menu item is selected. The callback function is of
type @code{FL_PUP_CB} and receives the menu item ID of the selected
menu. If such a callback is set for a menu item the return value of
@code{@ref{fl_get_menu()}} is the return value of this function
instead of the menu item ID that would have been returned otherwise.
@end enumerate

To obtain the text of the item selected
@findex fl_get_menu_text()
@anchor{fl_get_menu_text()}
@example
const char *fl_get_menu_text(FL_OBJECT *obj);
@end example

To obtain the text of any item, use the following routine
@findex fl_get_menu_item_text()
@anchor{fl_get_menu_item_text()}
@example
const char *fl_get_menu_item_text(FL_OBJECT *obj, int miid);
@end example
@noindent
where @code{miid} is the menu item ID. If @code{n} isn't a valid menu
iem ID item @code{NULL} is returned.

To obtain the total number of menu items, use the function
@findex fl_get_menu_maxitems()
@anchor{fl_get_menu_maxitems()}
@example
int fl_get_menu_maxitems(FL_OBJECT *obj);
@end example

One can change the appearance of different menu items. In particular,
it is sometimes desirable to make grey-out menu items and make them
unselectable or to put boxes with and without checkmarks in front of
them. This can be done using the routine:
@findex fl_set_menu_item_mode()
@anchor{fl_set_menu_item_mode()}
@example
void fl_set_menu_item_mode(FL_OBJECT *obj, int miid, unsigned mode);
@end example
@noindent
@code{miid} is the menu index ID of the memu item you want to change.
@code{mode} represents the special properties you want to apply to the
chosen item. You can specify more than one at a time by adding or
bitwise OR-ing these values together. For this parameter, the
following symbolic constants exist:
@table @code
@tindex FL_PUP_NONE
@item FL_PUP_NONE
No special display characteristic, the default.
@tindex FL_PUP_BOX
@item FL_PUP_BOX
"Binary" entry, i.e.@: an entry that stands for a choice that can
be switched on and off. Displayed with an unchecked box to the
left.
@tindex FL_PUP_RADIO
@item FL_PUP_RADIO
"Radio" item belonging to a group, so that gets automatically
switched off when another item of the group is selected. Displayed
with a diamoned-shaped box at the left.
@tindex FL_PUP_GREY
@item FL_PUP_GREY
To be OR-ed with one of the above to make that item appear
greyed-out and disable it (i.e.@: not selectable anymore).
@tindex FL_PUP_CHECK
@item FL_PUP_CHECK
To be OR-ed with one of @code{FL_PUP_BOX} and @code{FL_PUP_RADIO}
to make the box to the left appear checked or pushed.
@end table

There is also a routine that can be used to obtain the current mode of
an item after interaction, mostly useful for toggle or radio items:
@findex fl_get_menu_item_mode()
@anchor{fl_get_menu_item_mode()}
@example
unsigned int fl_get_menu_item_mode(FL_OBJECT *obj, int miid);
@end example

It is often useful to define keyboard shortcuts for particular menu
items. For example, it would be nice to have @code{<Alt>s} behave like
selecting "Save" from a menu. This can be done using the following
routine:
@findex fl_set_menu_item_shortcut()
@anchor{fl_set_menu_item_shortcut()}
@example
void fl_set_menu_item_shortcut(FL_OBJECT *obj, int miid,
                               const char *str);
@end example
@noindent
@code{miid} is the menu item ID of the menu item under consideration.
@code{str} contains the shortcut for the item. (Actually, it can
contain more shortcuts for the same item.) @xref{Shortcuts}, for more
information about shortcuts.

Finally there is the routine:
@findex fl_show_menu_symbol()
@anchor{fl_show_menu_symbol()}
@example
void fl_show_menu_symbol(FL_OBJECT *obj, int yes_no);
@end example
@noindent
With this routine you can indicate whether to show a menu symbol at
the right of the menu label. By default no symbol is shown.


@node Menu Attributes
@subsection Menu Attributes
Any boxtype can be used for a menu except for those of type
@code{FL_PULLDOWN_MENU}, for which @code{FL_NO_BOX} should not be
used.

The first color argument (@code{col1}) to
@code{@ref{fl_set_object_color()}} controls the color of the menu's
box when not open and the second (@code{col2}) is the color when the
menu is shown.

To change the font style and size used in the popup menus (not the menu
label), use the following routines
@findex fl_setpup_default_fontstyle()
@findex fl_setpup_default_fontsize()
@example
void fl_setpup_default_fontstyle(int style);
void fl_setpup_default_fontsize(int size);
@end example
@noindent
These settings apply to all menus at once.

If desired, you can attach an external popup to a menu object via the
following routine
@findex fl_set_menu_popup()
@anchor{fl_set_menu_popup()}
@example
void fl_set_menu_popup(FL_OBJECT *obj, int pupID);
@end example
@noindent
where @code{pupID} is the ID returned by @code{@ref{fl_newpup()}} or
@code{@ref{fl_defpup()}}. @xref{XPopup}, for more details on popup
creation.

For a menu created this way only @code{@ref{fl_get_menu()}} and
@code{@ref{fl_get_menu_text()}} work as expected. Other services such as
mode setting and query etc. should be done via the popup routines.

To obtain the popup ID associated with a menu, use the following routine
@findex fl_get_menu_popup()
@anchor{fl_get_menu_popup()}
@example
int fl_get_menu_popup(FL_OBJECT *obj);
@end example
@noindent
The function return the popup ID if the menu was created using
@code{@ref{fl_set_menu_popup()}} or
@code{@ref{fl_set_menu_entries()}}, otherwise it returns -1.

Normally in the popup opened for a menu a title is shown. This can be
switched off (and back on again by using the function
@findex fl_set_menu_notitle()
@anchor{fl_set_menu_notitle()}
@example
fl_set_menu_notitle(FL_OBJECT *obj, int off);
@end example

@node Menu Remarks
@subsection Remarks

See @file{menu.c} for an example of the use of menus. You can also use
@code{FL_MENU_BUTTON} to initiate a callback and use an XPopup
directly within the callback. See @file{pup.c} for an example of this
approach.


@node Browser Object
@section Browser Object

The browser object class is probably the most powerful that currently
exists in the Forms Library. A browser is a box that contains a number
of lines of text. If the text does not fit inside the box, a scrollbar
is automatically added so that the user can scroll through it. A
browser can be used for building up a help facility or to give
messages to the user.

It is possible to create a browser from which the user can select
lines. In this way the user can make its selections from a (possible)
long list of choices. Both single lines and multiple lines can be
selected, depending on the type of the browser.

@ifnottex

@menu
* Adding Browser Objects:   Adding Browser Objects
* Browser Types:            Browser Types
* Browser Interaction:      Browser Interaction
* Other Browser Routines:   Other Browser Routines
* Browser Attributes:       Browser Attributes
* Remarks:                  Browser Remarks
@end menu

@end ifnottex


@node Adding Browser Objects
@subsection Adding Browser Objects

Adding an object To add a browser to a form use the routine
@findex fl_add_browser()
@anchor{fl_add_browser()}
@example
FL_OBJECT *fl_add_browser(int type, FL_Coord x, FL_Coord y,
                          FL_Coord w, FL_Coord h, const char *label);
@end example
@noindent
The meaning of the parameters is as usual. The label is placed below
the box by default.


@node Browser Types
@subsection Browser Types

The following types of browsers exist (see below for more information
about them):
@table @code
@tindex FL_NORMAL_BROWSER
@item FL_NORMAL_BROWSER
A browser in which no selections can be made.
@tindex FL_SELECT_BROWSER
@item FL_SELECT_BROWSER
In this case the user can make single line selections.
@tindex FL_HOLD_BROWSER
@item FL_HOLD_BROWSER
Same but the selection remains visible till the next selection.
@tindex FL_MULTI_BROWSER
@item FL_MULTI_BROWSER
Multiple selections can be made and remain visible till de-selected.
@end table

Hence, the differences only lie in how the selection process works.


@node Browser Interaction
@subsection Browser Interaction

The user can change the position of the slider or use keyboard cursor
keys (including @code{<Home>}, @code{<PageDown>}, etc.) to scroll
through the text. When he/she presses the left mouse below or above
the slider, the browser scrolls one page (actually one line less than
a page) down or up. Any other mouse button scrolls one line at a time.
When not using an @code{FL_NORMAL_BROWSER}, the user can also make
selections with the mouse by pointing to a line or by using the cursor
keys.

For @code{FL_SELECT_BROWSER}'s, as long as the user keeps the mouse
pressed, the current line under the mouse is highlighted. Whenever he
releases the mouse the highlighting disappears and the browser is
returned to the application program. The application program can now
figure out which line was selected using a call of
@code{@ref{fl_get_browser()}} to be described below. It returns the
number of the last selected line. (Top line is line 1.)

An @code{FL_HOLD_BROWSER} works exactly the same except that, when the
mouse is released, the selection remains highlighted.

An @code{FL_MULTI_BROWSER} allows the user to select and de-select
multiple lines. Whenever he selects or de-selects a line the browser
is returned to the application program that can next figure out (using
@code{@ref{fl_get_browser()}} described below) which line was
selected. It returns the number of the last selected line. When the
last line was de-selected it returns the negation of the line number.
I.e., if line 10 was selected last the routine returns 10 and if line
10 was de-selected last, it returns -10. When the user presses the
mouse on a non-selected line and then moves it with the mouse button
still pressed down, he will select all lines he touches with his mouse
until he releases it. All these lines will become highlighted. When
the user starts pressing the mouse on an already selected line he
de-selects lines rather than selecting them.


@node Other Browser Routines
@subsection Other Browser Routines

The maximum length of a line that can be added to a browser is by
default 2048 bytes
@tindex FL_BROWSER_LINELENGTH
(@code{FL_BROWSER_LINELENGTH}). However, if desired, the
application can enlarge this limit using the following routine
@findex fl_set_default_broswer_maxlinelength()
@anchor{fl_set_default_broswer_maxlinelength()}
@example
int fl_set_default_broswer_maxlinelength(int new_length);
@end example
@noindent
The function returns the old limit. Note that the new length affects
all browsers.

There are a large number of routines to change the contents of a browser, select and de-select lines, etc.

To remove all lnes from a browser use
@findex fl_clear_browser()
@anchor{fl_clear_browser()}
@example
void fl_clear_browser(FL_OBJECT *obj);
@end example

To add a line to a browser use
@findex fl_add_browser_line()
@anchor{fl_add_browser_line()}
@example
void fl_add_browser_line(FL_OBJECT *obj, const char *text);
@end example

A second way of adding a line to the browser is to use the call
@findex fl_addto_browser()
@anchor{fl_addto_browser()}
@example
void fl_addto_browser(FL_OBJECT *obj, const char *text);
@end example
@noindent
The difference to @code{@ref{fl_add_browser_line()}} is that with this
call the browser will be shifted such that the newly appended line is
visible. This is useful when e.g.@: using the browser to display
messages.

Sometimes it may be more convenient to add characters to a browser
without implying the starting of a new line. To this end, the
following routine exists
@findex fl_addto_browser_chars()
@anchor{fl_addto_browser_chars()}
@example
void fl_addto_browser_chars(FL_OBJECT *obj, const char *text);
@end example
@noindent
This function appends text to the last line in the browser without
advancing the line counter unless text contains embedded newline
characters (@code{'\n'}). In that case, the text before the embedded
newline is appended to the last line, and the line counter is
incremented. The characters after the newline, possibly with more
embedded newlines in it, are then added to the browser via means
similar to @code{@ref{fl_addto_browser()}}.

You can also insert a line in front of a given line. All lines after
it will be shifted. Note that the top line is numbered 1 (not 0).
@findex fl_insert_browser_line()
@anchor{fl_insert_browser_line()}
@example
void fl_insert_browser_line(FL_OBJECT *obj, int line,
                            const char *text);
@end example
@noindent
Inserting into an empty browser or after the last line in the browser
is the same as adding a line with e.g. @:
@code{@ref{fl_add_browser_line()}}.

To delete a line (shifting the following lines) use:
@findex fl_delete_browser_line()
@anchor{fl_delete_browser_line()}
@example
void fl_delete_browser_line(FL_OBJECT *obj, int line);

@end example

One can also replace a line using
@findex fl_replace_browser_line()
@anchor{fl_replace_browser_line()}
@example
void fl_replace_browser_line(FL_OBJECT *obj, int line,
                             const char *text);
@end example

Making many changes to a visible browser at the same moment, i.e.,
clearing it and loading it with a number of new choices, is slow
because the browser is redrawn after each change. The Forms Library
has a mechanism for avoiding this using the calls
@code{@ref{fl_freeze_form()}} and @code{@ref{fl_unfreeze_form()}}. So
a piece of code that fills in a visible browser should preferably look
like the following
@example
fl_freeze_form(brow->form);
fl_clear_browser(brow);
fl_add_browser_line(brow, "line 1");
fl_add_browser_line(brow, "line 2");
...
fl_unfreeze_form(brow->form);
@end example
@noindent
where @code{brow->form}q is the form that contains the browser object
named @code{brow}.

To obtain the contents of a particular line in the browser, use
@findex fl_get_browser_line()
@anchor{fl_get_browser_line()}
@example
const char *fl_get_browser_line(FL_OBJECT *obj, int line);
@end example
@noindent
It returns a pointer to the particular line of text.

It is possible to load an entire file into a browser using
@findex fl_load_browser()
@anchor{fl_load_browser()}
@example
int fl_load_browser(FL_OBJECT *obj, const char *filename);
@end example
@noindent
The routine returns whether or not the file name was successfully
loaded. If the file name is an empty string the browser is simply
cleared. This routine is particularly useful when using the browser
for a help facility. You can create different help files and load the
needed one depending on context.

The application program can select or de-select lines in the browser.
To this end the following calls exist with the obvious meaning:
@findex fl_select_browser_line()
@anchor{fl_select_browser_line()}
@findex fl_deselect_browser()
@anchor{fl_deselect_browser()}
@findex fl_deselect_browser_line()
@anchor{fl_deselect_browser_line()}
@example
void fl_select_browser_line(FL_OBJECT *obj, int line);
void fl_deselect_browser_line(FL_OBJECT *obj, int line);
void fl_deselect_browser(FL_OBJECT *obj);
@end example
@noindent
The last call de-selects all lines.

To check whether a line is selected, use the routine
@findex fl_isselected_browser_line()
@anchor{fl_isselected_browser_line()}
@example
int fl_isselected_browser_line(FL_OBJECT *obj, int line);
@end example

The routine
@findex fl_get_browser_maxline()
@anchor{fl_get_browser_maxline()}
@example
int fl_get_browser_maxline(FL_OBJECT *obj);
@end example
@noindent
returns the number of lines in the browser. For example, when the
application program wants to figure out which lines in a
@code{FL_MULTI_BROWSER} are selected code similar to the following can
be used:
@example
int total_lines = fl_get_browser_maxline(brow);
for (i = 1; i <= total_lines; i++)
    if (fl_isselected_browser_line(brow, i))
        /* Handle the selected line */
@end example

Sometimes it is useful to know how many lines are visible in the
browser. To this end, the following call can be used
@findex fl_get_browser_screenlines()
@anchor{fl_get_browser_screenlines()}
@example
int fl_get_browser_screenlines(FL_OBJECT *obj);
@end example

To obtain the last selection made by the user, e.g. when the browser
is returned, the application program can use the routine
@findex fl_get_browser()
@anchor{fl_get_browser()}
@example
int fl_get_browser(FL_OBJECT *obj);
@end example
@noindent
It returns the line number of the last selection being made (0 if no
selection was made). When the last action was a de-selection (only for
@code{FL_MULTI_BROWSER}'s) the negative of the de-selected line number
is returned.

There are also calls to influence and query the top line shown in the
browser's box (i.e.@: influence the position of the slider).
@findex fl_set_browser_topline()
@anchor{fl_set_browser_topline()}
@findex fl_get_browser_topline()
@anchor{fl_get_browser_topline()}
@example
void fl_set_browser_topline(FL_OBJECT *obj, int line);
int fl_get_browser_topline(FL_OBJECT *obj);
@end example
@noindent
Note that the index of the top line is 1, not 0.

It is possible to register a callback function that gets called when a
line is double-clicked. To this end, the following function can be
used:
@findex fl_set_browser_dblclick_callback()
@anchor{fl_set_browser_dblclick_callback()}
@example
void fl_set_browser_dblclick_callback(FL_OBJECT *obj,
                                      void (*cb)(FL_OBJECT *, long),
`                                     long data);
@end example
@noindent
Of course, double-click callbacks make most sense for
@code{FL_HOLD_BROWSER}s.

Finally there is a routine that can be used to programmatically scroll
the text horizontally
@findex fl_set_browser_xoffset()
@anchor{fl_set_browser_xoffset()}
@example
void fl_set_browser_xoffset(FL_OBJECT *obj, FL_Coord xoff);
@end example
@noindent
where @code{xoff} indicates how many pixels to scroll to the left
relative to the nominal position of the text lines.

There is also a function that can be used to obtain the current
xoffset if needed:
@findex fl_get_browser_xoffset()
@anchor{fl_get_browser_xoffset()}
@example
FL_Coord fl_get_browser_xoffset(FL_OBJECT *obj);
@end example

@node Browser Attributes
@subsection Browser Attributes

Never use the boxtype @code{FL_NO_BOX} for browsers.

The first color argument (@code{col1}) to
@code{@ref{fl_set_object_color()}} controls the color of the browser's
box, the second (@code{col2}) the color of the selection. The text
color is the same as the label color.

To set the font size used inside the browser use
@findex fl_set_browser_fontsize()
@anchor{fl_set_browser_fontsize()}
@example
void fl_set_browser_fontsize(FL_OBJECT *obj, int size);
@end example

To set the font style used inside the browser use
@findex fl_set_browser_fontstyle()
@anchor{fl_set_browser_fontstyle()}
@example
void fl_set_browser_fontstyle(FL_OBJECT *obj, int style);
@end example
@noindent
@xref{Label Attributes and Fonts}, for details on font sizes and
styles.

It is possible to change the appearance of individual lines in the
browser. Whenever a line starts with the symbol @code{@@} the next
letter indicates the special characteristics associated with this line.
The following possibilities exist at the moment:
@table @code
@item f
Fixed width font.
@item n
Normal (Helvetica) font.
@item t
Times-Roman like font.
@item b
Boldface modifier.
@item i
Italics modifier.
@item l
Large (new size is @code{FL LARGE SIZE}).
@item m
Medium (new size is @code{FL MEDIUM SIZE}).
@item s
Small (new size is @code{FL SMALL SIZE}).
@item L
Large (new size = current size + 6)
@item M
Medium (new size = current size + 4)
@item S
Small (new size = current size - 2).
@item c
Centered.
@item r
Right aligned.
@item _
Draw underlined text.
@item -
An engraved separator. Text following @code{-} is ignored.
@item C
The next number indicates the color index for this line.
@item N
Non-selectable line (in selectable browsers).
@item @@
Regular @code{@@} character.
@end table

The modifiers (bold and itatic) work by adding @code{FL_BOLD_STYLE}
and @code{FL_ITALIC_STYLE} to the current active font index to look up
the font in the font table (you can modify the table using
@code{@ref{fl_set_font_name()}}).

More than one option can be used by putting them next to each other.
For example, @code{"@@C1@@l@@f@@b@@cTitle"} will give you the red,
large, bold fixed font, centered word @code{"Title"}. As you can see
the font change requests accumulate and the order is important, i.e.,
@code{"@@f@@b@@i"} gives you a fixed bold italic font while
@code{"@@b@@i@@f"} gives you a (plain) fixed font.

One word of caution is required here: The line spacing inside the
browser is not changed! Hence, when using a large line, you had better
take care that there is an empty line above and below it.

In some cases the character @code{@@} might need to be placed at the
beginning of the lines without introducing the special meaning
mentioned above. In this case you can use @code{@@@@} or change the
special character to something other than @code{@@} using the
following routine
@findex fl_set_browser_specialkey()
@anchor{fl_set_browser_specialkey()}
@example
void fl_set_browser_specialkey(FL_OBJECT *obj, int key);
@end example

To align different text fields on a line, tab characters (@code{'\t'})
can be embedded in the text. See @code{@ref{fl_set_tabstop()}} on how
to set tabstops.

There are two functions to turn the scrollbars on and off:
@findex fl_set_browser_hscrollbar()
@anchor{fl_set_browser_hscrollbar()}
@findex fl_set_browser_vscrollbar()
@anchor{fl_set_browser_vscrollbar()}
@example
void fl_set_browser_hscrollbar(FL_OBJECT *obj, int how);
void fl_set_browser_vscrollbar(FL_OBJECT *obj, int how);
@end example
@noindent
@code{how} can be set to the following values:
@table @code
@tindex FL_ON
@item FL_ON
Always on.
@tindex FL_OFF
@item FL_OFF
Always off.
@tindex FL_AUTO
@item FL_AUTO
On when needed (i.e., more lines/chars than could be shown)
@end table
@noindent
@code{FL_AUTO} is the default.

Sometimes, it may be desirable for the application to obtain the
scrollbar positions when they change (e.g., to use the scrollbars of
one browser to control other browsers). To this end, the following
routines are available
@tindex FL_BROWSER_SCROLL_CALLBACK
@findex fl_set_browser_hscroll_callback()
@anchor{fl_set_browser_hscroll_callback()}
@findex fl_set_browser_vscroll_callback()
@anchor{fl_set_browser_vscroll_callback()}
@example
typedef void (*FL_BROWSER_SCROLL_CALLBACK)(FL_OBJECT *, int, void *);
void fl_set_browser_hscroll_callback(FL_OBJECT *obj,
                                     FL_BROWSER_SCROLL_CALLBACK cb,
                                     void *cb_data);
void fl_set_browser_vscroll_callback(FL_OBJECT *obj,
                                     FL_BROWSER_SCROLL_CALLBACK cb,
                                     void *cb_data);
@end example
@noindent
After scroll callbacks are set whenever the scrollbar changes position
the callback function is called as
@example
cb(ob, offset, cb_data);
@end example
@noindent
The first argument to the callback function @code{cb} is the browser
object, the second argument is the new xoffset for the horizontal
scrollbar or the new top line for the vertical scrollbar. The third
argument is the callback data specified as the third argument in the
function calls to install the callback.

To uninstall a scroll callback, use a @code{NULL} pointer as the
callback function.

By default, the scrollbar size is determined based on the initial size
of the browser. To change the default, use the following routine
@findex fl_set_browser_scrollbarsize()
@anchor{fl_set_browser_scrollbarsize()}
@example
void fl_set_browser_scrollbarsize(FL_OBJECT *obj, int hh, int vw);
@end example
@noindent
where @code{hh} is the horizontal scrollbar height and @code{vw} is
the vertical scrollbar width. Use reset to the default.

The default scrollbar type is @code{FL_THIN_SCROLLBAR}. There are two
ways you can change the default. One way is to use
@code{@ref{fl_set_defaults()}} or @code{@ref{fl_set_scrollbar_type()}}
to set the application wide default, another way is to use
@code{@ref{fl_get_object_component()}} to get the object handle to the
scrollbars and change the the object type forcibly. The first method
is preferred because the user can override the setting via resources.
Although the second method of changing the scrollbar type is not
recommended, the object handle obtained can be useful in changing the
scrollbar colors etc.

Finally there is a routine that can be used to obtain the browser size
in pixels for the text area
@findex fl_get_browser_dimension()
@anchor{fl_get_browser_dimension()}
@example
void fl_get_browser_dimension(FL_OBJECT *obj, FL_Coord *x, FL_Coord *y,
                              FL_COORD *w, FL_COORD *h);
@end example
@noindent
where @code{x} and @code{y} are measured from the top-left corner of
the form (or the smallest enclosing window). To establish the
relationship between the text area (a function of scrollbar size,
border with and text margin), you can compare the browser size and
text area size.


@node Browser Remarks
@subsection Remarks

There is currently a limit of a maximum of 2048 bytes per line for
@code{fl_load_browser()}.

See @file{fbrowse1.c} for an example program using a
@code{FL_NORMAL_BROWSER} to view files. @file{browserall.c} shows all
different browsers. @file{browserop.c} shows the insertion and
deletion of lines in a @code{FL_HOLD_BROWSER}.

For the browser class, especially multi browsers, interaction via
callbacks is strongly recommended.
