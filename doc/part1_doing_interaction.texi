@node Doing Interaction
@chapter Part I: Doing Interaction

After having defined the forms the application program can use them to
interact with the user. As a first step the program has to display the
forms with which it wants the user to interact. This is done using the
routine
@findex fl_show_form()
@example
Window fl_show_form(FL_FORM *form, int place, int border,
                    const char *name);
@end example
@noindent
It opens a (top-level) window on the screen in which the form is shown.
The parameter @code{name} is the title of the form (and its associated
icon if any). The routine returns the window resource ID of the form.
You normally never need this. Immediately after the form becomes
visible, a full draw of all objects on the form is performed. Due to the
two way buffering mechanism of Xlib, if @code{fl_show_form()} is
followed by something that blocks (e.g., waiting for a device other than
X devices to come online), the output buffer might not be properly
flushed, resulting in the form only being partially drawn. If your
program works this way, use the following function after
@code{fl_show_form()}
@findex fl_update_display()
@example
void fl_update_display(int blocking);
@end example
@noindent
where @code{blocking} is false (0), the function flushes the X buffer so
the drawing requests are on their way to the server. When
@code{blocking} is true (1), the function flushes the buffer and waits
until all the events are received and processed by the server. For
typical programs that use @code{fl_do_forms()} or
@code{fl_check_forms()} after @code{fl_show_form()}, flushing is not
necessary as the output buffer is flushed automatically. Excessive call
to @code{fl_update_display()} degrades performace.

The location and size of the window are determined
by @code{place}. The following possibilities exist:
@table @code
@tindex @code{FL_PLACE_SIZE}
@item FL_PLACE_SIZE
The user can control the position but the size is fixed. Interactive
resizing is not allowed once the form becomes visible.
@tindex @code{FL_PLACE_POSITION}
@item FL_PLACE_POSITION
Initial position used will be the one set via
@code{fl_set_form_position()}. Interactive resizing is possible.
@tindex @code{FL_PLACE GEOMETRY}
@item FL_PLACE GEOMETRY
Place at the latest position and size (see also below) or the geometry
set via @code{fl_set_form_geometry()}. A form so shown will have a fixed
size and interactive resizing is not allowed.
@tindex @code{FL_PLACE_ASPECT}
@item FL_PLACE_ASPECT
Allows interactive resizing but any new size will have the aspect ratio
as that of the initial size.
@tindex @code{FL_PLACE_MOUSE}
@item FL_PLACE_MOUSE
The form is placed centered below the mouse. Interactive resizing will
not be allowed unless this option is accompanied by @code{FL_FREE_SIZE}
as in @code{FL_PLACE_MOUSE | FL_FREE_SIZE}.
@tindex @code{FL_PLACE_CENTER}
@item FL_PLACE_CENTER
The form is placed in the center of the screen. If @code{FL_FREE_SIZE}
is also specified, interactive resizing will be allowed.
@tindex @code{FL_PLACE_FULLSCREEN}
@item FL_PLACE_FULLSCREEN
The form is scaled to cover the full screen. If @code{FL_FREE_SIZE} is
also specified, interative resizing will be allowed.
@tindex @code{FL_PLACE_FREE}
@item FL_PLACE_FREE
Both the position and size are completely free. The initial size used is
the designed size. Initial position, if setvia
@code{fl_set_form_position()}, will be used otherwise interactive
positioning may be possible if the window manager allows it.
@tindex @code{FL_PLACE_HOTSPOT}
@item FL_PLACE_HOTSPOT
The form is so placed that mouse is on the "hotspot". If
@code{FL_FREE_SIZE} is also specified, interactive resizing will be
allowed.
@tindex @code{FL_PLACE_CENTERFREE}
@item FL_PLACE_CENTERFREE
Same as @code{FL_PLACE_CENTER | FL_FREE_SIZE}, i.e., place the form at
the center of the screen and allow resizing.
@tindex @code{FL_PLACE ICONIC}
@item FL_PLACE ICONIC
The form is shown initially iconified. The size and location used are
the window manager's default.
@end table

If no size is specified, the designed (or later scaled) size will be
used. Note that the initial position is dependent upon the window
manager used. Some window managers will allow interactive placement of
the windows and some will not.

You can set the position or size to be used via the following calls
@findex fl_set_form_position()
@example
void fl_set_form_position(FL_FORM *form, FL_Coord x, FL_Coord y);
@end example
@noindent
and
@findex fl_set_form_size(
@example
void fl_set_form_size(FL_FORM *form, FL_Coord w, FL_Coord h);
@end example
@noindent
or, more conveniently,
@findex fl_set_form_geometry(
@example
void fl_set_form_geometry(FL_FORM form*, FL_Coord x, FL_Coord y,
                          FL_Coord w, FL_Coord h);
@end example
@noindent
before placing the form on the screen. (Actually the routines can also
be called while the form is being displayed. It will change shape.)
@code{x}>, @code{y}, @code{w} and @code{h} indicate the position of the
form on the screen and its size@footnote{The parameters should be
sensitive to the coordinate unit in effect at the time of the call, but
at present, they are not, i.e., the function takes only values in pixel
units.}. The position is measured from the top-left corner of the
screen. When the position is negative the distance from the right or the
bottom is indicated. Next the form should be placed on the screen using
@code{FL_PLACE_GEOMETRY}, @code{FL_PLACE_FREE}. E.g., to place a form at
the lower-right corner of the screen use
@example
fl_set_form_position(form, -form->w, -form->h);
fl_show_form(form, FL_PLACE_GEOMETRY, FL_TRANSIENT, "formName");
@end example

To show a form so that a particular object or point is on the mouse, use
one of the following two routines to set the "hotspot"
@findex fl_set_form_hotspot()
@findex fl_set_form_hotobject()
@example
void fl_set_form_hotspot(FL_FORM *form, FL_Coord x, FL_Coord y);
void fl_set_form_hotobject(FL_FORM *form, FL_OBJECT *ob);
@end example
@noindent
and use @code{FL_PLACE_HOTSPOT} in @code{fl_show_form()} to realize. The
coordinates @code{x} and @code{y} are relative to the upper-left corner
of the form.

In the call @code{fl_show_form()} the argument @code{border} indicates
whether or not to request window manager's decoration. border should
take one of the following values:
@table @code
@tindex @code{FL_FULLBORDER}
@item FL_FULLBORDER
full borders
@tindex @code{FL_TRANSIENT}
@item FL_TRANSIENT
borders with (possibly) less decoration
@tindex @code{FL_NOBORDER}
@item FL_NOBORDER
no decoration at all
@end table

For some dialogs, such as demanding an answer etc., you probably do not
want win dow manager's full decoration. Use @code{FL_TRANSIENT} for
this.

A window border is useful to let the user iconify a form or move it
around. If a form is transient or has no border, it is normally more
difficult (or even impossible) to move the form. A transient form
typically should have less decoration , but not necessarily so. It
depends on window mangers as well as their options. @code{FL_NOBORDER}
is guaranteed to have no border@footnote{Provided the window manager is
compliant. If the window manager is not compliant, all bets are off.}
and is immune to iconification request. Because of this, borderless
forms can be hostile to other applications@footnote{Actually, they are
also hostile to their sibling forms. See Appendix A.}, so use this only
if absolutely necessary.

There are other subtle differences between the different decoration
requests. For instance, (small) transient forms always have
@code{save_under} (See @code{XSetWindowAttributes(3X11)}) set to true by
default. Some window properties, @code{WM_COMMAND} in particular, are
only set for full-bordered forms and will only migrate to other
full-bordered forms when the original form having the property becomes
unmapped.

The library has a notion of a "main form" of an application, roughly the
form that would be on the screen the longest. By default, the first
full-bordered form shown becomes the main form of the application. All
transient windows shown afterwards will stay on top of the main form.
The application can set or change the main form anytime using the
following routine
@findex fl_set_app_mainform(
@example
void fl_set_app_mainform(FL_FORM *form);
@end example
@noindent
Setting the main form of an application will cause the @code{WM_COMMAND}
property set for the form if no other form has this property.

Sometimes, it is necessary to have access to the window resource ID
before the window is mapped (shown). For this, the following routine can
be used
@findex fl_prepare_form_window()
@example
Window fl_prepare_form_window(FL_FORM *form, int place,
                              int border, const char *name);
@end example
@noindent
This routine creates a window that obeys any and all constraints just as
@code{fl_show_form()} does but remains
unmapped. To map such a window, the following must be used
@findex fl_show_form_window()
@example
Window fl_show_form_window(FL_FORM *form);
@end example
@noindent
Between these two calls, the application program has full access to the
window and can set all attributes, such as icon pixmaps etc., that are
not set by @code{fl_show_form()}.

You can also scale the form and all objects on it programmatically using
the following routine
@findex fl_scale_form()
@example
void fl_scale_form(FL_FORM *form, double xsc, double ysc);
@end example
@noindent
where you indicate a scaling factor in the x- and y-direction with
respect to the current size. See @file{rescale.c} for an example.

When a form is scaled, either programmatically or interactively, all
objects on the form will also be scaled. This includes both the sizes
and positions of the objects. For most cases, this default behavior is
adequate. In some cases, e.g., to keep a group of objects together, more
control is needed. To this end, the following routines can be used
@findex fl_set_object_gravity()
@findex fl_set_object_resize()
@example
void fl_set_object_gravity(FL_OBJECT *ob,
                           unsigned NWgravity, unsigned SEgravity);
void fl_set_object_resize(FL_OBJECT *ob, unsigned howresize);
@end example
@noindent
where @code{howresize} can be one of
@tindex @code{FL_RESIZE_NONE}
@code{FL_RESIZE_NONE},
@tindex @code{FL_RESIZE_X}
@code{FL_RESIZE_X} or
@tindex @code{FL_RESIZE_Y}
@code{FL_RESIZE_Y} with obvious
meanings. An alias
@tindex @code{FL_RESIZE_ALL}
@code{FL_RESIZE_ALL} @code{FL_RESIZE_X | FL_RESIZE_Y}, can be used to
make both dimension scalable. 

@code{NWgravity} and @code{SEgravity} control
respectively the positioning of the upper-left and lower-right corner of
the object and work analogously to the @code{win_gravity} in
Xlib. The details are as follows: Let @code{P} be the corner
the gravity applies to, @code{(dx1,dy1)} the distance to the
upper-left corner of the form, @code{(dx2,dy2)} the distance
to the lower-right corner of the form, then,
@multitable @columnfractions 0.5 0.5
@headitem Value
@tab Effect
@tindex @code{FL_NoGravity}
@item @code{FL_NoGravity}
@tab Default linear scaling, see below
@tindex @code{FL_NorthWest}
@item @code{FL_NorthWest}
@tab @code{dx1}, @code{dy1} constant
@tindex @code{FL_North}
@item @code{FL_North}
@tab @code{dy1} constant
@tindex @code{FL_NorthEast}
@item @code{FL_NorthEast}
@tab @code{dy1}, @code{dx2} constant
@tindex @code{FL_West}
@item @code{FL_West}
@tab @code{dx1} constant
@tindex @code{FL_East}
@item @code{FL_East}
@tab @code{dx2} constant
@tindex @code{FL_SouthWest}
@item @code{FL_SouthWest}
@tab @code{dx1}, @code{dy2} constant
@tindex @code{FL_South}
@item @code{FL_South}
@tab @code{dy2} constant
@tindex @code{FL_SouthEast}
@item @code{FL_SouthEast}
@tab @code{dx2}, @code{dy2} constant
@end multitable

Default for all object is @code{FL_RESIZE_ALL} and @code{ForgetGravity}.
Note that the three parameters are not orthogonal and the positioning
request will always override the scaling request in case of conflict.
This means @code{FL_RESIZE} is consulted only if one (or both) of the
gravities is @code{FL_NoGravity}.

For the special case where @code{howresize} is @code{FL_RESIZE_NONE} and
both gravities are set to @code{ForgetGravity}, the object is left
un-scaled, but the object is moved so that the new position keeps the
center of gravity of the object constant relative to the form.

Again, since all sizing requests go though the window manager, there is
no guarantee that your request will be honored. If a form is placed with
@code{Fl_PLACE_GEOMETRY} or other size-restricting options, resizing
later via @code{fl_set_form_size()} will likely be rejected.

Sometimes, you may want to change an attribute for all objects on a
particular form, to this end, the following iterator is available
@findex fl_for_all_objects()
@example
void fl_for_all_objects(FL_FORM *form,
                        int (*operate)(FL_OBJECT *ob, void *data),
                        void *data);
@end example
@noindent
where function @code{operate} is called for every object of the form
@code{form} unless @code{operate()} returns nonzero, which terminates
the iterator.

Multiple forms can be shown at the same moment and the system will
interact with all of them simultaneously.

The graphical mode in which the form is shown depends on the type of
machine. In general, the visual chosen by XForms is the one that has the
most colors. Application programs have many ways to change this default,
either through command line options, resources or programmatically. See
the appendices for details.

If for any reason, you would like to change the form title (as well as
its associated icon) after it is shown, the following call can be used
@findex fl_set_form_title()
@example
void fl_set_form_title(FL_FORM *form, const char *name)
@end example

To set or change the icon shown when a form is iconified, use the
following routine
@findex fl_set_form_icon(
@example
void fl_set_form_icon(FL_FORM *form, Pixmap icon, Pixmap mask);
@end example
@noindent
where @code{icon} and @code{mask} can be any valid Pixmap ID. (See
Sections 15.5 and 15.6 for some of the routines that can be used to
create Pixmaps.) Note that an @code{icon} previously setvia this
function (if it exists) is not freed or modified in anyway. See the demo
program @file{iconify.c} for an example.

If the application program wants to stop interacting with a form and
remove it from the screen, it has to use the call
@findex fl_hide_form()
@example
void fl_hide_form(FL_FORM *form);
@end example

To check if a form is visible or not, use the following call
@findex fl_form_is_visible()
@example
int fl_form_is_visible(FL_FORM *form);
@end example
@noindent
The function returns
@tindex @code{FL_INVISIBLE}
@code{FL_INVISIBLE} (0) if the form is not visible,
@tindex @code{FL_VISIBLE}
@code{FL_VISIBLE} (1) if the form is visible and
@tindex @code{FL_BEING_HIDDEN}
@code{FL_BEING_HIDDEN} (-1) if the form is visible but is in the process
of being hidden.

Note that if you don't need a form anymore you can deallocate its memory
using the call @code{fl_free_form()} described earlier.

Window managers typically have a menu entry labeled "delete" or "close"
meant to terminate an application program gently by informing the
application program with a @code{WM_DELETE_WINDOW} protocol message.
Although the Forms Library catches this message, it does not do anything
except terminating the application. This can cause problems if the
application has to do some record keeping before exiting. To perform
record keeping or to elect to ignore this message, register a callback
function using the following routine
@findex fl_set_atclose()
@example
int fl_set_atclose(int (*at_close)(FL_FORM *, void *), void *data);
@end example
@noindent
The callback function @code{at_close} will be called before the Forms
Library terminates the application. The first parameter of the callback
function is the form that received the @code{WM_DELETE_WINDOW} message.
To prevent the Forms Library from terminating the application, the
callback function should return a constant @code{FL_IGNORE}. Any other
value (e.g., @code{FL_OK}) will result in the termination of the
application.

Similar mechanism exists for individual forms
@findex fl_set_form_atclose()
@example
int fl_set_form_atclose(FL_FORM *,
                        int (*at_close)(FL_FORM *, void *),
                        void *data);
@end example
@noindent
except that @code{FL_OK} does not terminate the application, it results
in the form being closed. Of course, if you'd like to terminate the
application, you can always call @code{exit(3)} yourself within the
callback function.


@ifnottex

@menu
* Simple::           Simple Interaction
* Periodic::         Periodic Events and Non-blocking Interaction
* Dealing::          Dealing With Multiple Mindows::
* Using Callbacks::  Using Callback Functions
* Handling::         Handling Other Input Sources
@end menu

@end ifnottex


@node Simple
@section Simple Interaction

Once one or more forms are shown it is time to give the control to the
library to handle the interaction with the forms. There are a number of
different ways of doing this. The first one, appropriate for simple
programs, is to call
@findex fl_do_forms()
@example
FL_OBJECT *fl_do_forms(void);
@end example
@noindent
It controls the interaction until some object in one of the forms
changes state. In this case a pointer to the changed object is returned.

A change occurs in the following cases:
@table @asis
@item box
A box never changes state and, hence, is never returned by
@code{fl_do_forms()}.
@item text
Also a text never changes state.
@item button
A button is returned when the user presses a mouse button on it and then
releases the button. The change is not reported before the user releases
the mouse button, except with touch buttons which are returned all the
time as long as the user keeps the mouse pressed on it. (See e.g.
@file{touchbutton.c} for the use of touch buttons.)
@item slider
A slider is returned whenever it changes value, so whenever the user
moves his mouse after having pressed the slider.
@item input
An input field is returned when it is deactivated, i.e., the user has
selected it and then selected another input field for input (e.g. by
pressing the @code{<TAB>} key).
@end table

When the object is returned by @code{fl_do_forms()} the application
program can check what the change is and take action accordingly. See
some of the demo programs for examples of use. Normally, after the
action is taken by the application program @code{fl_do_forms()} is
called again to continue the interaction. Hence, most programs have the
following global form:
@example
/* define the forms */
/* display the forms */
while (! ready) @{
    obj = fl_do_forms();
    if (obj == obj1)
        /* handle the change in obj1 */
    else if (obj == obj2)
        /* handle the change in obj2 */
    ....
@}
@end example

For moderately complex programs, interaction via callbacks is preferred.
For such programs, the global structure looks something like the
following
@example
/* define callbacks */
void callback(FL_OBJECT *ob, long data) @{
    /* perform tasks */
@}

void terminate_callback(FL_OBJECT *ob, long data) @{
    /* cleanup application */
    fl_finish();
    exit(0);
@}

main(int argc, char *argv[]) @{
    /* create form and bind the callbacks to objects */
    /* enter main loop */
    fl_do_forms();
    return 0;
@}
@end example
@noindent
In this case, @code{fl_do_forms()} handles the interaction indefinitely
and never returns. The program exits via one of the callback functions.


@node Periodic
@section Periodic Events and Non-blocking Interaction

The interaction mentioned above is adequate for many application
programs but not for all. When the program also has to perform tasks
when no user action takes place (e.g. redrawing a rotating image all the
time), some other means of interaction are needed.

There exist two different, but somewhat similar, mechanisms in the
library that are designed specifically for generating and handling
periodic events or achieving non-blocking interaction. Depending on the
application, one method may be more appropriate than the other.

For periodic tasks, e.g., rotating an image, checking the status of some
external device or application state etc., interaction via an idle
callback comes in very handy. An idle callback is an application
function that is registered with the system and is called whenever there
are no events pending for forms (or application windows).

To register an idle callback, use the following routine
@findex fl_set_idle_callback()
@example
FL_APPEVENT_CB fl_set_idle_callback(FL_APPEVENT_CB callback,
                                    void *user_data);
@end example

After the registration, whenever the main loop (@code{fl_do_forms()}) is
idle, i.e., no user action or light user action, the callback function
is called as
@example
int callback(xev, user_data);
@end example
@noindent
where @code{user_data} is the void pointer passed to the system in
@code{fl_set_idle_callback()} through which some information about the
application can be passed. The return value of the callback function is
currently not used. @code{xev} is a pointer to a synthetic@footnote{I.e.
@code{xev->xmotion.send_event} is true.} @code{MotionNotify} event from
which some information about mouse position etc. can be obtained. To
remove the idle callback, use @code{fl_set_idle_callback()} with
callback set to @code{NULL}.

Timeouts are similar to idle callbacks but with somewhat more accurate
timing. Idle callbacks are called whenever the system is idle, the time
interval between any two invocations of the idle callback can vary a
great deal depending upon many factors. Timeout callbacks, on the other
hand, will never be called before the specified time is elapsed. You can
think of timeouts as regularized idle callbacks, and further you can
have more than one timeout callbacks.

To add a timeout callback, use the following routine
@tindex @code{FL_TIMEOUT_CALLBACK}
@findex fl_add_timeout(
@example
typedef void (*FL_TIMEOUT_CALLBACK)(int, void *);
int fl_add_timeout(long msec, FL_TIMEOUT_CALLBACK callback,
                   void *data);
@end example
@noindent
The function returns the timeout's ID@footnote{The function will not
return 0 or -1 as timeout IDs, so the application program can use these
values to tag invalid or expired timeouts.}. When the time interval
specified by @code{msec} (in milli-second) is elapsed, the timeout is
removed, then the callback function is called. The timeout ID is passed
to the callback function as the first parameter. The second parameter of
the callback function is passed the data pointer that was passed to
@code{fl_add_timeout()}.

To remove a timeout before it triggers, use the following routine
@findex fl_remove_timeout()
@example
void fl_remove_timeout(int id);
@end example
@noindent
where @code{id} is the timeout ID returned by @code{fl_add_timeout()}.
There is also an @code{FL_OBJECT}, the @code{FL_TIMER} object,
especially the invisible type, that can be used to do timeout. Since it
is a proper Forms Library object, it may be easier to use simply because
it has the same API as any other GUI elements and is supported by the
Form Designer. See Part III for complete information on @code{FL_TIMER}
object.

Note that idle callback and timeout are not appropriate for tasks that
block or take a long time to finish because during the busy or blocked
period, no interaction with the GUI can take place (both idle callback
and timeout are invoked by the main loop, blockage or busy executing
application code prevents the main loop from performing its tasks).

So what to do in situations where the application program does require a
lengthy computation while still wanting to have the ability to interact
with the user interface (for example, a Stop button to terminate the
lengthy computation)?

In these situations, the following routine can be used:
@findex fl_check_forms()
@example
FL_OBJECT *fl_check_forms(void);
@end example
@noindent
This function is similar to @code{fl_do_forms()} in that it takes care
of handling the events and appropriate callbacks, but it does not block.
It always returns to the application program immediately. If a change
has occurred in some object the object is returned as with
@code{fl_do_forms()}. But when no change has occurred control is also
returned but this time a @code{NULL} object is returned. Thus, by
inserting this statement in the middle of the computation in appropriate
places in effect "polls" the user interface. The downside of using this
function is that if used excessively, as with all excessive polls, it
can chew up considerable CPU cycles. Therefore, it should only be used
outside the inner most loops of the computation. If all objects have
callbacks bound to them, @code{fl_check_forms()} always returns
@code{NULL}, otherwise, code similar to the following is needed:
@example
obj = fl_check_forms();
if (obj == obj1)
    /* handle it */
...
@end example
@noindent
Depending on the applications, it may be possible to partition the
computation into smaller tasks that can be performed within an idle
callback one after another, thus eliminating the need of using
@code{fl_check_forms()}.

Handling intensive computation while maintaining user interface
responsiveness can be tricky and by no means the above methods are the
only options. You can, for example, fork a child process to do some of
the tasks and communicate with the interface via pipes and/or signals,
both of which can be handled with library routines documented later, or
use multi-thread (but be careful to limit Xserver access within one
thread). Be creative and have fun.

For running external executables while maintaining responsiveness of the
interface, see @code{fl_exe_command()} and @code{fl_popen()} documented
later in Section 6.2(73).


@node Dealing
@section Dealing With Multiple Mindows

It is not atypical that an application program may need to take
interaction from more than one form at the same time, Forms Library
provides a mechanism with which precise control can be exercised.

By default, @code{fl_do_forms()} takes
interaction from all forms that are shown. In certain situations, you
might not want to have interaction with all of them. For example, when
the user presses a quit button in a form you might want to ask a
confirmation using another form. You don't want to hide the main form
because of that but you also don't want the user to be able to press
buttons, etc. in this form. The user first has to give the confirmation.
So you want to temporarily deactivate the main form. This can be done
using the call
@findex fl_deactivate_form(
@example
void fl_deactivate_form(FL_FORM *form);
@end example

To reactivate the form later again use
@findex fl_activate_form(
@example
void fl_activate_form(FL_FORM *form);
@end example

It is a good idea to give the user a visual clue that a form is
deactivated. This is not automatically done mainly for performance
reasons. Experience shows that graying out some important objects on the
form is in general adequate. Graying out an object can be accomplished
by using @code{fl_set_object_lcol()} (see @file{objinactive.c}. What
objects to gray out is obviously application dependent.

The following two functions can be used to register two callbacks that
are called whenever the activation status of a form is changed:
@tindex @code{FL_FORM_ATACTIVATE}
@tindex @code{FL_FORM_ATDEACTIVATE}
@findex fl_set_form_atactivate()
@findex fl_set_form_atdeactivate()
@example
typedef void (*FL_FORM_ATACTIVATE)(FL_FORM *, void *);
FL_FORM_ATACTIVATE fl_set_form_atactivate(FL_FORM *form,
                                   FL_FORM_ATACTIVATE callback,
                                   void *data);

typedef void (*FL_FORM_ATDEACTIVATE)(FL_FORM *, void *);
FL_FORM_ATDEACTIVATE fl_set_form_atdeactivate(FL_FORM *form,
                                   FL_FORM_ATDEACTIVATE callback,
                                   void *data);
@end example

It is also possible to deactivate all current forms and reactivate them
again. To this end use the functions:
@findex fl_deactivate_all_forms()
@findex fl_activate_all_forms()
@example
void fl_deactivate_all_forms(void);
void fl_activate_all_forms(void);
@end example
@noindent
Note that deactivation works in an additive way, i.e., when deactivating
a form say 3 times it also has to be activated 3 times to become active
again.

One problem remains. Mouse actions etc. are presented to a program in
the form of events in an event queue. The library routines
@code{fl_do_forms()} and @code{fl_check_forms()} read this queue and
handle the events. When the application program itself also opens
windows, these windows should receive events as well. Unfortunately,
there is only one event queue. When both the application program and the
library routines read events from this one queue problems occur and
events are missed. Hence, the application program should not read the
event queue while displaying forms. To solve this problem, the package
maintains (or appears to maintain) a separate event queue for the user.
This queue behaves in exactly the same way as the normal event queue. To
access it, the application program should use replacements for the usual
Xlib routines. Instead of using @code{XNextEvent()}, the program should
use @code{fl_XNextEvent()}, with the same parameters except the
@code{Display *} . The following is a list of all new routines:
@findex fl_XNextEvent()
@findex fl_XPeekEvent()
@findex fl_XEventsQueued()
@findex fl_XPutbackEvent()
@example
int fl_XNextEvent(XEvent *xev);
int fl_XPeekEvent(XEvent *xev);
int fl_XEventsQueued(int mode);
int fl_XPutbackEvent(XEvent *xev);
@end example

Other events routines may be directly used if proper care is taken to
make sure that only events for the application window in question are
removed. These routines include @code{XWindowEvent()},
@code{XCheckWindowEvent()} etc.

To help find out when an event has occurred, whenever
@code{fl_do_forms()} and @code{fl_check_forms()} encounter an event that
is not meant for them but for the application program they return a
special object
@tindex @code{FL_EVENT}
@code{FL_EVENT}. Upon receiving this special event, the
application program can and must remove the pending event from the queue
using @code{fl_XNextEvent()}.

So the basis of a program with its own windows would look as follows:
@example
/* define the forms */
/* display the forms */
/* open your own window(s) */

while (! ready) @{
    obj = fl_do_forms();    /* or fl_check_forms() */
    if (obj == FL_EVENT) @{
        fl_XNextEvent(&xevent);
        switch (xevent.type) @{
            /* handle the event */
        @}
    @} else if (obj != NULL)
        /* handle the change in obj */
        /* update other things */
    @}
@}
@end example

In some situations you don't want to see the user events. For example,
you might want to write a function that pops up a form to change some
settings. This routine might not want to be concerned with any redrawing
of the main window, etc., but you also don't want to discard any events.
In this case you can use the routines @code{fl_do_only_forms()} and
@code{fl_check_only_forms()} that will never return @code{FL_EVENT}. The
events don't disappear. They will be returned at later calls to the
normal routines @code{fl_do_forms()}.

It can't be over-emphasized that it is an error to ignore
@code{FL_EVENT} or use @code{fl_XNextEvent()} without seeing
@code{FL_EVENT}.

Sometimes an application program might need to find out more information
on the event that triggered a callback, e.g., to implement button number
sensitive functionalities. To this end, the following routines may be
called
@findex fl_mouse_button()
@example
long fl_mouse_button(void);
@end example
@noindent
This function, if needed, should be called from within a callback. The
function returns one of the constants @code{FL_LEFT_MOUSE},
@code{FL_MIDDLE_MOUSE} and @code{FL_RIGHT_MOUSE} indicating the physical
location of the mouse button on the mouse that was pushed or released.
If the callback is triggered by a shortcut, the function returns the
keysym (ascii value if ASCII) of the key plus @code{FL_SHORTCUT}. For
example, if a button has a shortcut @code{<CNTRL>C} (ASCII value is 3),
the button number returned upon activation of the shortcut would be
@code{FL_SHORTCUT + 3}. @code{FL_SHORTCUT} can be used to determine if
the callback is triggered by a shortcut or not
@example
if (fl_mouse_button() >= FL_SHORTCUT)
    /* handle shortcut */
else
    switch (fl_mouse_button()) @{
        case FL_LEFTMOUSE:
        ....
    @}
@end example

More information can be obtained by using the following routine that
returns the last XEvent
@findex fl_last_event()
@example
const XEvent *fl_last_event(void);
@end example
@noindent
Note that if this routine is used outside of a callback function, the
value returned may not be the real "last event" if the program was
idling and, in this case, it returns a synthetic @code{MotionNotify}
event.

Some of the utilities used internally by the Forms Library can be used
by the application programs, such as window geometry queries etc.
Following is a partial list of the available routines:
@findex fl_get_winorigin()
@findex fl_get_winsize()
@findex fl_get_wingeometry()
@example
void fl_get_winorigin(Window win, FL_Coord *x, FL_Coord *y);
void fl_get_winsize(Window win, FL_Coord *w, FL_Coord *h);
void fl_get_wingeometry(Window win, FL_Coord *x, FL_Coord *y,
                        FL_Coord *w, FL_Coord *h);
@end example
@noindent
All positions are relative to the root window.

There are also routines that can be used to obtain the current mouse
position relative to the root window:
@findex fl_get_mouse()
@example
Window fl_get_mouse(FL_Coord *x, FL_Coord *y,
                    unsigned int *keymask);
@end example
@noindent
where @code{keymask} is the same as used in @code{XQueryPointer(3X11)}.
The function returns the window ID the mouse is in.

To obtain the mouse position relative to an arbitrary window, the
following routine may be used
@findex fl_get_win_mouse()
@example
Window fl_get_win_mouse(Window win, FL_Coord *x, FL_Coord *y,
                        unsigned int *keymask);
@end example

To print the name of an XEvent, the following routine can be used:
@findex fl_print_xevent_name()
@example
XEvent *fl_print_xevent_name(const char *where, const XEvent *xev);
@end example
@noindent
The function takes an XEvent, prints out its name and some other info,
e.g., @code{expose, count=n}. Parameter @code{where} can be used to
indicate where this function is called:
@example
fl_print_xevent_name("In tricky.c", &xevent);
@end example


@node Using Callbacks
@section Using Callback Functions

As stated earlier, the recommended method of interaction is to use
callback functions. A callback function is a function supplied to the
library by the application program that binds a specific condition
(e.g., a button is pushed) to the invocation of the function by the
system.

The application program can bind a callback routine to any object. Once
a callback function is bound and the specified condition is met,
@code{fl_do_forms()} or @code{fl_check_forms()} invokes the callback
function instead of returning the object.

To bind a callback routine to an object, use the following
@tindex @code{FL_CALLBACKPTR}
@findex fl_set_object_callback()
@example
typedef void (*FL_CALLBACKPTR)(FL_OBJECT *ob, long argument);
FL_CALLBACKPTR fl_set_object_callback(FL_OBJECT *obj,
                                      FL_CALLBACKPTR callback,
                                      long argument);
@end example
@noindent
where @code{callback} is the callback function. @code{argument} is an
argument that is passed to the callback routine so that it can take
different actions for different objects. The function returns the old
callback routine already bound to the object. You can change the
callback routine anytime using this function. See, for example, demo
program @file{timer.c}.

The callback routine should have the form
@example
void callback(FL_OBJECT *obj, long argument);
@end example
@noindent
The first argument to every callback function is the object to which the
callback is bound. The second parameter is the argument specified by the
application program in the call to @code{fl_set_object_callback()}.

See program @file{yesno_cb.c} for an example of the use of callback
routines. Note that callback routines can be combined with normal
objects. It is possible to change the callback routine at any moment.

Sometimes it is necessary to access other objects on the form from
within the callback function. This presents a difficult situation that
calls for global variables for all the objects on the form. This runs
against good programming methodology and can make a program hard to
maintain. Forms Library solves (to some degree) this problem by creating
three fields, @code{void *u_vdata}, @code{char *u_cdata} and @code{long
u_ldata}, in the @code{FL_OBJECT} structure that you can use to hold the
necessary data to be used in the callback function. A better and more
general solution to the problem is detailed in Part II of this
documentation where all objects on a form is are grouped into a single
structure which can then be "hang" off of @code{u_vdata} or some field
in the @code{FL_FORM} structure.

Another communication problem might arise when the callback function is
called and, from within the callback function, some other objects' state
is explicitly changed, say, via @code{fl_set_button()},
@code{fl_set_input()} etc. You probably don't want to put the state
change handling code of these objects in another object's callback. To
handle this situation, you can simply call
@findex fl_call_object_callback()
@example
void fl_call_object_callback(FL_OBJECT *obj);
@end example

When dealing with multiple forms, the application program can also bind
a callback routine to an entire form. To this end it should use the
routine
@findex fl_set_form_callback()
@example
void fl_set_form_callback(FL_FORM *form,
                          void (*callback)(FL_OBJECT *, void *),
                          void *data);
@end example

Whenever @code{fl_do_forms()} or @code{fl_check_forms()} would return an
object in form they call the routine callback instead, with the object
as an argument. So callback should have the form
@example
void callback(FL_OBJECT *obj, void *data);
@end example

With each form you can associate its own callback routine. For objects
that have their own callbacks, the object callbacks have priority over
the form callback.

When the application program also has its own windows (via Xlib or Xt),
it most likely also wants to know about XEvents for the window. As
explained earlier, this can be accomplished by checking
for @code{FL_EVENT} objects. Another (and better) way is to
add an event callback routine. This routine will be called whenever an
XEvent is pending for the application's own window. To setup an event
callback routine use the call
@tindex FL_APPEVENT_CB
@findex fl_set_event_callback(
@example
FL_APPEVENT_CB fl_set_event_callback(int (*callback)(XEvent *ev,
                                                     void *data),
                                     void *data);
@end example
@noindent
Whenever an event takes place callback is called with the event as
argument. So the callback should have the form
@example
typedef int (*FL_APPEVENT_CB)(XEvent *ev, void *data);
int callback(XEvent *xev, void *data);
@end example

This assumes the application program solicits the events and further,
the callback routine should be prepared to handle all XEvent for all
non-form windows. This could be undesirable if more than one application
window is active. To further partition and simplify the interaction,
callbacks for a specific event on a specific window can be registered:
@findex fl_add_event_callback()
@example
FL_APPEVENT_CB fl_add_event_callback(Window window, int xev_type,
                                     FL_APPEVENT_CB callback,
                                     void *user_data);
@end example
@noindent
where @code{window} is the window for which the callback routine is to
be registered. @code{xev_type} is the XEvent type you're interested in,
e.g., @code{Expose} etc. If @code{xev_type} is 0, it is taken to mean
the callback routine will handle all events for the window. The newly
installed callback replaces the callback already installed. Note that
this function only works for windows created directly by the application
program (i.e., it won't work for forms' windows or windows created by
the canvas object). It is possible to access the raw events that happen
on a form's window via @code{fl_register_raw_callback()} discussed in
Chapter D.

@code{fl_add_event_callback()} does not alter the window's event mask
nor solicit events for you. This is so mainly for the reason that an
event type does not always correspond to a unique event mask, also in
this way, the user can solicit events at window's creation and use 0 to
register all the event handlers.

To let XForms handle solicitation for you, call the following routine
@findex fl_activate_event_callbacks()
@example
void fl_activate_event_callbacks(Window win);
@end example
@noindent
This function activates the default mapping of events to event masks
built-in in the Forms Library, and causes the system to solicit the
events for you. Note however, the mapping of events to masks are not
unique and depending on applications, the default mapping may or may not
be the one you want. For example, @code{MotionNotify} event can be
mapped into @code{ButtonMotionMask} or @code{PointerMotionMask}. Forms
Library will use both.

It is possible to control precisely the masks you want by using the
following function, which can also be used to add or remove solicited
event masks on the fly without altering other masks already selected:
@findex fl_addto_selected_xevent()
@findex fl_remove_selected_xevent()
@example
long fl_addto_selected_xevent(Window win, long mask);
long fl_remove_selected_xevent(Window win, long mask);
@end example

Both functions return the resulting event masks that are currently
selected. If event callback functions are registered via both
@code{fl_set_event_callback()} and @code{fl_add_event_callback()}, the
callback via the latter is invoked first and the callback registered via
@code{fl_set_event_callback()} is called only if the first attempt is
unsuccessful, that is, the handler for the event is not present. For
example, after the following sequence
@example
fl_add_event_callback(winID, Expose, expose_cb, 0);
fl_set_event_callback(event_callback);
@end example
All @code{Expose} events on window @code{winID} are consumed by
@code{expose_cb}, thus @code{event_callback()} would never be invoked as
a result of an @code{Expose} event.

To remove a callback, use the following routine
@findex fl_remove_event_callback()
@example
void fl_remove_event_callback(Window win, int xev_type);
@end example
@noindent
All parameters have the usual meaning. Again, this routine does not
modify the window's event mask. If you like to change the events the
window is sensitive to after removing the callback, use
@code{fl_activate_event_callbacks()}. If @code{xev_type} is 0, all
callbacks for window @code{win} are removed. This routine is called
automatically if @code{fl_winclose()} is called to unmap and destroy a
window. Otherwise, you must call this routine explicitly to remove all
event callbacks before destroying a window using
@code{XDestroyWindow()}.

A program using all of these has the following basic form:
@example
void event_cb(XEvent *xev, void *mydata1) @{
    /* Handles an X-event. */
@}

void expose_cb(XEvent *xev, void *mydata2) @{
    /* handle expose */
@}

void form1_cb(FL_OBJECT *obj) @{
    /* Handles object obj in form1. */
@}

void form2_cb(FL_OBJECT *obj) @{
    /* Handles object obj in form2. */
@}

main(int argc, char *argv[]) @{
    /* initialize */
    /* create form1 and form2 and display them */
    fl_set_form_callback(form1, form1cb);
    fl_set_form_callback(form2, form2cb);

    /* create your own window, winID and show it */
    fl_addto_selected_xevent(winID,
                             ExposureMask | ButtonPressMask |... );
    fl_winshow(winID);
    fl_set_event_callback(event_cb, whatever);
    fl_add_event_callback(winID, Expose, expose_cb, data);
    fl_do_forms();
    return 0;
@}
@end example
@noindent
The routine @code{fl_do_forms()} will never return in this case. See
@file{demo27.c} for a program that works this way.

It is recommended that you set up your programs using callback routines
(either for the objects or for entire forms). This ensures that no
events are missed, events are treated in the correct order, etc. Note
that different event callback routines can be written for different
stages of the program and they can be switched when required. This
provides a progressive path for building up programs.

Another possibility is to use a free object so that the application
window is handled automatically by the internal event processing
mechanism just like any other forms.


@node Handling
@section Handling Other Input Sources

It is not uncommon that X applications may require input from sources
other than the X event queue. Outlined in this section are two routines
in the Forms Library that provide a simple interface to handle
additional input sources. Applications can define input callbacks to be
invoked when input is available from a specified file descriptor.

The function
@tindex FL_IO_CALLBACK
@findex fl_add_io_callback()
@example
typedef void (*FL_IO_CALLBACK)(int fd, void *data);
void fl_add_io_callback(int fd, unsigned condition,
                        FL_IO_CALLBACK callback, void *data);
@end example
@noindent
registers an input callback with the system. The argument @code{fd} must
be a valid file descriptor on a UNIX-based system or other operating
system dependent device specification while @code{condition} indicates
under what circumstance the input callback should be invoked. The
condition must be one of the following constants
@table @code
@tindex @code{FL_READ}
@item FL_READ
File descriptor has data available.
@tindex @code{FL_WRITE}
@item FL_WRITE
File descriptor is available for writing.
@tindex @code{FL_EXCEPT}
@item FL_EXCEPT
an I/O error has occurred.
@end table

When the given condition occurs, the Forms Library invokes the callback
function specified by @code{callback}. The @code{data} argument allows
the application to provide some data to be passed to the callback
function when it is called (be sure that the storage pointed to by data
has global (or static) scope).

To remove a callback that is no longer needed or to stop the Forms
Library's main loop from watching the file descriptor, use the following
function
@findex fl_remove_io_callback()
@example
void fl_remove_io_callback(int fd, unsigned condition,
                           FL_IO_CALLBACK callback);
@end example

The procedures outlined above work well with pipes and sockets, but can
be a CPU hog on real files. To workaround this problem, you may wish to
check the file periodically and only from within an idle callback.
