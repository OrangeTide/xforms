# 1 "forms.c"
/*
 *  This file is part of the XForms library package.
 *
 *  XForms is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation; either version 2.1, or
 *  (at your option) any later version.
 *
 *  XForms is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with XForms.  If not, see <http://www.gnu.org/licenses/>.
 */


/**
 * \file forms.c
 *
 *  This file is part of the XForms library package.
 *  Copyright (c) 1996-2002  T.C. Zhao and Mark Overmars
 *  All rights reserved.
 *
 *  Main event dispatcher.
 */





#include <ctype.h>
# 1 "/usr/include/ctype.h" 1 3
/* Copyright (C) 1991,92,93,95,96,97,98,99,2001,2002,2004,2007,2008,2009,2011
	Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard 7.4: Character handling	<ctype.h>
 */


#define	_CTYPE_H	1

#include <features.h>
# 1 "/usr/include/features.h" 1 3
/* Copyright (C) 1991-1993,1995-2007,2009,2010,2011
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */


#define	_FEATURES_H	1

/* These are defined by the user (or the compiler)
   to specify the desired environment:

   __STRICT_ANSI__	ISO Standard C.
   _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
   _POSIX_SOURCE	IEEE Std 1003.1.
   _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
			if >=199309L, add IEEE Std 1003.1b-1993;
			if >=199506L, add IEEE Std 1003.1c-1995;
			if >=200112L, all of IEEE 1003.1-2004
			if >=200809L, all of IEEE 1003.1-2008
   _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
			Single Unix conformance is wanted, to 600 for the
			sixth revision, to 700 for the seventh revision.
   _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
   _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
   _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
   _FILE_OFFSET_BITS=N	Select default filesystem interface.
   _BSD_SOURCE		ISO C, POSIX, and 4.3BSD things.
   _SVID_SOURCE		ISO C, POSIX, and SVID things.
   _ATFILE_SOURCE	Additional *at interfaces.
   _GNU_SOURCE		All of the above, plus GNU extensions.
   _REENTRANT		Select additionally reentrant object.
   _THREAD_SAFE		Same as _REENTRANT, often used by other systems.
   _FORTIFY_SOURCE	If set to numeric value > 0 additional security
			measures are defined, according to level.

   The `-ansi' switch to the GNU C compiler defines __STRICT_ANSI__.
   If none of these are defined, the default is to have _SVID_SOURCE,
   _BSD_SOURCE, and _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
   200112L.  If more than one of these are defined, they accumulate.
   For example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE
   together give you ISO C, 1003.1, and 1003.2, but nothing else.

   These are defined by this file and are used by the
   header files to decide what to declare or define:

   __USE_ISOC99		Define ISO C99 things.
   __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
   __USE_POSIX		Define IEEE Std 1003.1 things.
   __USE_POSIX2		Define IEEE Std 1003.2 things.
   __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
   __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
   __USE_XOPEN		Define XPG things.
   __USE_XOPEN_EXTENDED	Define X/Open Unix things.
   __USE_UNIX98		Define Single Unix V2 things.
   __USE_XOPEN2K        Define XPG6 things.
   __USE_XOPEN2KXSI     Define XPG6 XSI things.
   __USE_XOPEN2K8       Define XPG7 things.
   __USE_XOPEN2K8XSI    Define XPG7 XSI things.
   __USE_LARGEFILE	Define correct standard I/O things.
   __USE_LARGEFILE64	Define LFS things with separate names.
   __USE_FILE_OFFSET64	Define 64bit interface as default.
   __USE_BSD		Define 4.3BSD things.
   __USE_SVID		Define SVID things.
   __USE_MISC		Define things common to BSD and System V Unix.
   __USE_ATFILE		Define *at interfaces and AT_* constants for them.
   __USE_GNU		Define GNU extensions.
   __USE_REENTRANT	Define reentrant/thread-safe *_r functions.
   __USE_FORTIFY_LEVEL	Additional security measures used, according to level.
   __FAVOR_BSD		Favor 4.3BSD things in cases of conflict.

   The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
   defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
   only for compatibility.  All new code should use the other symbols
   to test for features.

   All macros listed above as possibly being defined by this file are
   explicitly undefined if they are not explicitly defined.
   Feature-test macros that are not defined by the user or compiler
   but are implied by the other feature-test macros defined (or by the
   lack of any definitions) are defined by the file.  */


/* Undefine everything, so we get a clean slate.  */
#undef	__USE_ISOC99
#undef	__USE_ISOC95
#undef	__USE_POSIX
#undef	__USE_POSIX2
#undef	__USE_POSIX199309
#undef	__USE_POSIX199506
#undef	__USE_XOPEN
#undef	__USE_XOPEN_EXTENDED
#undef	__USE_UNIX98
#undef	__USE_XOPEN2K
#undef	__USE_XOPEN2KXSI
#undef	__USE_XOPEN2K8
#undef	__USE_XOPEN2K8XSI
#undef	__USE_LARGEFILE
#undef	__USE_LARGEFILE64
#undef	__USE_FILE_OFFSET64
#undef	__USE_BSD
#undef	__USE_SVID
#undef	__USE_MISC
#undef	__USE_ATFILE
#undef	__USE_GNU
#undef	__USE_REENTRANT
#undef	__USE_FORTIFY_LEVEL
#undef	__FAVOR_BSD
#undef	__KERNEL_STRICT_NAMES

/* Suppress kernel-name space pollution unless user expressedly asks
   for it.  */

#define __KERNEL_STRICT_NAMES


/* Always use ISO C things.  */
#define	__USE_ANSI	1

/* Convenience macros to test the versions of glibc and gcc.
   Use them like this:
   #if __GNUC_PREREQ (2,8)
   ... code requiring gcc 2.8 or later ...
   #endif
   Note - they won't work for gcc1 or glibc1, since the _MINOR macros
   were not defined then.  */

#define __GNUC_PREREQ(maj, min) \
	((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))





/* If _BSD_SOURCE was defined by the user, favor BSD over POSIX.  */






/* If _GNU_SOURCE was defined by the user, turn on all the other features.  */
# 177 "/usr/include/features.h" 3


/* If nothing (other than _GNU_SOURCE) is defined,
   define _BSD_SOURCE and _SVID_SOURCE.  */



#define _BSD_SOURCE	1
#define _SVID_SOURCE	1


/* This is to enable the ISO C99 extension.  Also recognize the old macro
   which was used prior to the standard acceptance.  This macro will
   eventually go away and the features enabled by default once the ISO C99
   standard is widely adopted.  */





/* This is to enable the ISO C90 Amendment 1:1995 extension.  */


#define __USE_ISOC95	1


/* If none of the ANSI/POSIX macros are defined, use POSIX.1 and POSIX.2
   (and IEEE Std 1003.1b-1993 unless _XOPEN_SOURCE is defined).  */


#define _POSIX_SOURCE	1







#define _POSIX_C_SOURCE	200809L

#define __USE_POSIX_IMPLICITLY	1



#define __USE_POSIX	1



#define __USE_POSIX2	1



#define __USE_POSIX199309	1



#define __USE_POSIX199506	1



#define __USE_XOPEN2K		1
#undef __USE_ISOC95
#define __USE_ISOC95		1
#undef __USE_ISOC99
#define __USE_ISOC99		1



#define __USE_XOPEN2K8		1
#undef  _ATFILE_SOURCE
#define _ATFILE_SOURCE	1


# 274 "/usr/include/features.h" 3















#define __USE_MISC	1



#define __USE_BSD	1



#define __USE_SVID	1



#define __USE_ATFILE	1


















#define __USE_FORTIFY_LEVEL 0


/* Define __STDC_IEC_559__ and other similar macros.  */
#include <bits/predefs.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/predefs.h" 1 3
/* Copyright (C) 2005 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */






#define _PREDEFS_H

/* We do support the IEC 559 math functionality, real and complex.  */
#define __STDC_IEC_559__		1
#define __STDC_IEC_559_COMPLEX__	1

/* predefs.h */
# 324 "/usr/include/features.h" 2 3


/* wchar_t uses ISO 10646-1 (2nd ed., published 2000-09-15) / Unicode 3.1.  */
#define __STDC_ISO_10646__		200009L

/* This macro indicates that the installed library is the GNU C Library.
   For historic reasons the value now is 6 and this will stay from now
   on.  The use of this variable is deprecated.  Use __GLIBC__ and
   __GLIBC_MINOR__ now (see below) when you want to test for a specific
   GNU C library version and use the values in <gnu/lib-names.h> to get
   the sonames of the shared libraries.  */
#undef  __GNU_LIBRARY__
#define __GNU_LIBRARY__ 6

/* Major and minor version number of the GNU C library package.  Use
   these macros to test for features in specific releases.  */
#define	__GLIBC__	2
#define	__GLIBC_MINOR__	15

#define __GLIBC_PREREQ(maj, min) \
	((__GLIBC__ << 16) + __GLIBC_MINOR__ >= ((maj) << 16) + (min))

/* Decide whether a compiler supports the long long datatypes.  */




#define __GLIBC_HAVE_LONG_LONG	1


/* This is here only because every header file already includes this one.  */


#include <sys/cdefs.h>
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3
/* Copyright (C) 1992-2001, 2002, 2004, 2005, 2006, 2007, 2009, 2011
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */


#define	_SYS_CDEFS_H	1

/* We are almost always included from features.h. */




/* The GNU libc does not support any K&R compilers or the traditional mode
   of ISO C compilers anymore.  Check for some of the combinations not
   anymore supported.  */




/* Some user header file might have defined this before.  */
#undef	__P
#undef	__PMT



/* All functions, except those with callbacks or those that
   synchronize memory, are leaf functions.  */

#define __LEAF , __leaf__
#define __LEAF_ATTR __attribute__ ((__leaf__))





/* GCC can always grok prototypes.  For C++ programs we add throw()
   to help it optimize the function calls.  But this works only with
   gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions
   as non-throwing using a function attribute since programs can use
   the -fexceptions options for C code as well.  */

#define __THROW	__attribute__ ((__nothrow__ __LEAF))
#define __THROWNL	__attribute__ ((__nothrow__))
#define __NTH(fct)	__attribute__ ((__nothrow__ __LEAF)) fct
# 70 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3


/* Not GCC.  *//* GCC.  */
# 84 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3


/* These two macros are not used in glibc anymore.  They are kept here
   only because some other projects expect the macros to be defined.  */
#define __P(args)	args
#define __PMT(args)	args

/* For these things, GCC behaves the ANSI way normally,
   and the non-ANSI way under -traditional.  */

#define __CONCAT(x,y)	x ## y
#define __STRING(x)	#x

/* This is not a typedef so `const __ptr_t' does the right thing.  */
#define __ptr_t void *
#define __long_double_t  long double


/* C++ needs to know that types and declarations are C, not C++.  */




#define __BEGIN_DECLS
#define __END_DECLS



/* The standard library needs the functions from the ISO C90 standard
   in the std namespace.  At the same time we want to be safe for
   future changes and we include the ISO C99 code in the non-standard
   namespace __c99.  The C++ wrapper header take case of adding the
   definitions to the global namespace.  */








/* For compatibility we do not add the declarations into any
   namespace.  They will end up in the global namespace which is what
   old code expects.  */
#define __BEGIN_NAMESPACE_STD
#define __END_NAMESPACE_STD
#define __USING_NAMESPACE_STD(name)
#define __BEGIN_NAMESPACE_C99
#define __END_NAMESPACE_C99
#define __USING_NAMESPACE_C99(name)



/* Support for bounded pointers.  */

#define __bounded	/* nothing */
#define __unbounded	/* nothing */
#define __ptrvalue	/* nothing */



/* Fortify support.  */
#define __bos(ptr) __builtin_object_size (ptr, __USE_FORTIFY_LEVEL > 1)
#define __bos0(ptr) __builtin_object_size (ptr, 0)


#define __warndecl(name, msg) \
  extern void name (void) __attribute__((__warning__ (msg)))
#define __warnattr(msg) __attribute__((__warning__ (msg)))
#define __errordecl(name, msg) \
  extern void name (void) __attribute__((__error__ (msg)))






/* Support for flexible arrays.  */

/* GCC 2.97 supports C99 flexible array members.  */
#define __flexarr	[]
# 176 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3



/* __asm__ ("xyz") is used throughout the headers to rename functions
   at the assembly language level.  This is wrapped by the __REDIRECT
   macro, in order to support compilers that can do this some other
   way.  When compilers don't support asm-names at all, we have to do
   preprocessor tricks instead (which don't have exactly the right
   semantics, but it's the best we can do).

   Example:
   int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid); */



#define __REDIRECT(name, proto, alias) name proto __asm__ (__ASMNAME (#alias))






#define __REDIRECT_NTH(name, proto, alias) \
     name proto __asm__ (__ASMNAME (#alias)) __THROW
#define __REDIRECT_NTHNL(name, proto, alias) \
     name proto __asm__ (__ASMNAME (#alias)) __THROWNL

#define __ASMNAME(cname)  __ASMNAME2 (__USER_LABEL_PREFIX__, cname)
#define __ASMNAME2(prefix, cname) __STRING (prefix) cname

/*
#elif __SOME_OTHER_COMPILER__

# define __REDIRECT(name, proto, alias) name proto; \
	_Pragma("let " #name " = " #alias)
*/


/* GCC has various useful declarations that can be made with the
   `__attribute__' syntax.  All of the ways we use this do fine if
   they are omitted for compilers that don't understand it. */




/* At some point during the gcc 2.96 development the `malloc' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */

#define __attribute_malloc__ __attribute__ ((__malloc__))




/* At some point during the gcc 2.96 development the `pure' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */

#define __attribute_pure__ __attribute__ ((__pure__))




/* This declaration tells the compiler that the value is constant.  */

#define __attribute_const__ __attribute__ ((__const__))




/* At some point during the gcc 3.1 development the `used' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */

#define __attribute_used__ __attribute__ ((__used__))
#define __attribute_noinline__ __attribute__ ((__noinline__))





/* gcc allows marking deprecated functions.  */

#define __attribute_deprecated__ __attribute__ ((__deprecated__))




/* At some point during the gcc 2.8 development the `format_arg' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.
   If several `format_arg' attributes are given for the same function, in
   gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
   all designated arguments are considered.  */

#define __attribute_format_arg__(x) __attribute__ ((__format_arg__ (x)))




/* At some point during the gcc 2.97 development the `strfmon' format
   attribute for functions was introduced.  We don't want to use it
   unconditionally (although this would be possible) since it
   generates warnings.  */

#define __attribute_format_strfmon__(a,b) \
  __attribute__ ((__format__ (__strfmon__, a, b)))




/* The nonull function attribute allows to mark pointer parameters which
   must not be NULL.  */

#define __nonnull(params) __attribute__ ((__nonnull__ params))




/* If fortification mode, we warn about unused results of certain
   function calls which can lead to problems.  */

#define __attribute_warn_unused_result__ \
   __attribute__ ((__warn_unused_result__))







#define __wur /* Ignore */


/* Forces a function to be always inlined.  */

#define __always_inline __inline __attribute__ ((__always_inline__))




/* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
   inline semantics, unless -fgnu89-inline is used.  */

# 329 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3

#define __extern_inline extern __inline

#define __extern_always_inline \
  extern __always_inline __attribute__ ((__artificial__))






/* GCC 4.3 and above allow passing all anonymous arguments of an
   __extern_always_inline function to some other vararg function.  */

#define __va_arg_pack() __builtin_va_arg_pack ()
#define __va_arg_pack_len() __builtin_va_arg_pack_len ()


/* It is possible to compile containing GCC extensions even if GCC is
   run in pedantic mode if the uses are carefully marked using the
   `__extension__' keyword.  But this is not generally available before
   version 2.8.  */




/* __restrict is known in EGCS 1.2 and above. */




/* ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
     array_name[restrict]
   GCC 3.1 supports this.  */

#define __restrict_arr	__restrict
# 376 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3


#include <bits/wordsize.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3
/* Determine the wordsize from the preprocessor defines.  */


#define __WORDSIZE	64
#define __WORDSIZE_COMPAT32	1



# 378 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3


# 398 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3


#define __LDBL_REDIR1(name, proto, alias) name proto
#define __LDBL_REDIR(name, proto) name proto
#define __LDBL_REDIR1_NTH(name, proto, alias) name proto __THROW
#define __LDBL_REDIR_NTH(name, proto) name proto __THROW
#define __LDBL_REDIR_DECL(name)

#define __REDIRECT_LDBL(name, proto, alias) __REDIRECT (name, proto, alias)
#define __REDIRECT_NTH_LDBL(name, proto, alias) \
  __REDIRECT_NTH (name, proto, alias)



/* sys/cdefs.h */
# 357 "/usr/include/features.h" 2 3



/* If we don't have __REDIRECT, prototypes will be missing if
   __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64]. */





/* !ASSEMBLER */

/* Decide whether we can define 'extern inline' functions in headers.  */






/* There are some functions that must be declared 'extern inline' even with
   -Os when building LIBC, or they'll end up undefined.  */







/* This is here only because every header file already includes this one.
   Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
   <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
   that will always return failure (and set errno to ENOSYS).  */
#include <gnu/stubs.h>
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3
/* This file selects the right generated file of `__stub_FUNCTION' macros
   based on the architecture being compiled for.  */

#include <bits/wordsize.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3
/* Determine the wordsize from the preprocessor defines.  */


#define __WORDSIZE	64
#define __WORDSIZE_COMPAT32	1



# 4 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3





#include <gnu/stubs-64.h>
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3
/* This file is automatically generated.
   It defines a symbol `__stub_FUNCTION' for each function
   in the C library which is a stub, meaning it will fail
   every time called, usually setting errno to ENOSYS.  */





#define __stub_bdflush
#define __stub_chflags
#define __stub_fattach
#define __stub_fchflags
#define __stub_fdetach
#define __stub_getmsg
#define __stub_gtty
#define __stub_lchmod
#define __stub_putmsg
#define __stub_revoke
#define __stub_setlogin
#define __stub_sigreturn
#define __stub_sstk
#define __stub_stty
# 9 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3




# 389 "/usr/include/features.h" 2 3



/* features.h  */
# 27 "/usr/include/ctype.h" 2 3

#include <bits/types.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3
/* bits/types.h -- definitions of __*_t types underlying *_t types.
   Copyright (C) 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 * Never include this file directly; use <sys/types.h> instead.
 */


#define	_BITS_TYPES_H	1

#include <features.h>
#include <bits/wordsize.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3
/* Determine the wordsize from the preprocessor defines.  */


#define __WORDSIZE	64
#define __WORDSIZE_COMPAT32	1



# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3


/* Convenience types.  */
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;

/* Fixed-size types, underlying types depend on word size and compiler.  */
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;





/* quad_t is also 64 bits.  */

typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 67 "/usr/include/x86_64-linux-gnu/bits/types.h" 3



/* The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE
   macros for each of the OS types we define below.  The definitions
   of those macros must use the following macros for underlying types.
   We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned
   variants of each of the following integer types on this machine.

	16		-- "natural" 16-bit type (always short)
	32		-- "natural" 32-bit type (always int)
	64		-- "natural" 64-bit type (long or long long)
	LONG32		-- 32-bit type, traditionally long
	QUAD		-- 64-bit type, always long long
	WORD		-- natural type of __WORDSIZE bits (int or long)
	LONGWORD	-- type of __WORDSIZE bits, traditionally long

   We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the
   conventional uses of `long' or `long long' type modifiers match the
   types we define, even when a less-adorned type would be the same size.
   This matters for (somewhat) portably writing printf/scanf formats for
   these types, where using the appropriate l or ll format modifiers can
   make the typedefs and the formats match up across all GNU platforms.  If
   we used `long' when it's 64 bits where `long long' is expected, then the
   compiler would warn about the formats not matching the argument types,
   and the programmer changing them to shut up the compiler would break the
   program's portability.

   Here we assume what is presently the case in all the GCC configurations
   we support: long long is always 64 bits, long is always word/address size,
   and int is always 32 bits.  */

#define	__S16_TYPE		short int
#define __U16_TYPE		unsigned short int
#define	__S32_TYPE		int
#define __U32_TYPE		unsigned int
#define __SLONGWORD_TYPE	long int
#define __ULONGWORD_TYPE	unsigned long int
# 117 "/usr/include/x86_64-linux-gnu/bits/types.h" 3

#define __SQUAD_TYPE		long int
#define __UQUAD_TYPE		unsigned long int
#define __SWORD_TYPE		long int
#define __UWORD_TYPE		unsigned long int
#define __SLONG32_TYPE		int
#define __ULONG32_TYPE		unsigned int
#define __S64_TYPE		long int
#define __U64_TYPE		unsigned long int
/* No need to mark the typedef with __extension__.   */
#define __STD_TYPE		typedef



#include <bits/typesizes.h>	/* Defines __*_T_TYPE macros.  */
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3
/* bits/typesizes.h -- underlying types for *_t.  Generic version.
   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */






#define	_BITS_TYPESIZES_H	1

/* See <bits/types.h> for the meaning of these macros.  This file exists so
   that <bits/types.h> need not vary across different GNU platforms.  */

#define __DEV_T_TYPE		__UQUAD_TYPE
#define __UID_T_TYPE		__U32_TYPE
#define __GID_T_TYPE		__U32_TYPE
#define __INO_T_TYPE		__ULONGWORD_TYPE
#define __INO64_T_TYPE		__UQUAD_TYPE
#define __MODE_T_TYPE		__U32_TYPE
#define __NLINK_T_TYPE		__UWORD_TYPE
#define __OFF_T_TYPE		__SLONGWORD_TYPE
#define __OFF64_T_TYPE		__SQUAD_TYPE
#define __PID_T_TYPE		__S32_TYPE
#define __RLIM_T_TYPE		__ULONGWORD_TYPE
#define __RLIM64_T_TYPE		__UQUAD_TYPE
#define	__BLKCNT_T_TYPE		__SLONGWORD_TYPE
#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
#define	__ID_T_TYPE		__U32_TYPE
#define __CLOCK_T_TYPE		__SLONGWORD_TYPE
#define __TIME_T_TYPE		__SLONGWORD_TYPE
#define __USECONDS_T_TYPE	__U32_TYPE
#define __SUSECONDS_T_TYPE	__SLONGWORD_TYPE
#define __DADDR_T_TYPE		__S32_TYPE
#define __SWBLK_T_TYPE		__SLONGWORD_TYPE
#define __KEY_T_TYPE		__S32_TYPE
#define __CLOCKID_T_TYPE	__S32_TYPE
#define __TIMER_T_TYPE		void *
#define __BLKSIZE_T_TYPE	__SLONGWORD_TYPE
#define __FSID_T_TYPE		struct { int __val[2]; }
#define __SSIZE_T_TYPE		__SWORD_TYPE

/* Number of descriptors that can fit in an `fd_set'.  */
#define	__FD_SETSIZE		1024


/* bits/typesizes.h */
# 131 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3



typedef  unsigned long int   __dev_t;	/* Type of device numbers.  */
typedef  unsigned int   __uid_t;	/* Type of user identifications.  */
typedef  unsigned int   __gid_t;	/* Type of group identifications.  */
typedef  unsigned long int   __ino_t;	/* Type of file serial numbers.  */
typedef  unsigned long int   __ino64_t;	/* Type of file serial numbers (LFS).*/
typedef  unsigned int   __mode_t;	/* Type of file attribute bitmasks.  */
typedef  unsigned long int   __nlink_t;	/* Type of file link counts.  */
typedef  long int   __off_t;	/* Type of file sizes and offsets.  */
typedef  long int   __off64_t;	/* Type of file sizes and offsets (LFS).  */
typedef  int   __pid_t;	/* Type of process identifications.  */
typedef  struct { int __val[2]; }  __fsid_t;	/* Type of file system IDs.  */
typedef  long int   __clock_t;	/* Type of CPU usage counts.  */
typedef  unsigned long int   __rlim_t;	/* Type for resource measurement.  */
typedef  unsigned long int   __rlim64_t;	/* Type for resource measurement (LFS).  */
typedef  unsigned int   __id_t;		/* General type for IDs.  */
typedef  long int   __time_t;	/* Seconds since the Epoch.  */
typedef  unsigned int   __useconds_t; /* Count of microseconds.  */
typedef  long int   __suseconds_t; /* Signed count of microseconds.  */

typedef  int   __daddr_t;	/* The type of a disk address.  */
typedef  long int   __swblk_t;	/* Type of a swap block maybe?  */
typedef  int   __key_t;	/* Type of an IPC key.  */

/* Clock ID used in clock and timer functions.  */
typedef  int   __clockid_t;

/* Timer ID returned by `timer_create'.  */
typedef  void *  __timer_t;

/* Type to represent block size.  */
typedef  long int   __blksize_t;

/* Types from the Large File Support interface.  */

/* Type to count number of disk blocks.  */
typedef  long int   __blkcnt_t;
typedef  long int   __blkcnt64_t;

/* Type to count file system blocks.  */
typedef  unsigned long int   __fsblkcnt_t;
typedef  unsigned long int   __fsblkcnt64_t;

/* Type to count file system nodes.  */
typedef  unsigned long int   __fsfilcnt_t;
typedef  unsigned long int   __fsfilcnt64_t;

typedef  long int   __ssize_t; /* Type of a byte count, or error.  */

/* These few don't really vary by system, they always correspond
   to one of the other defined types.  */
typedef __off64_t __loff_t;	/* Type of file sizes and offsets (LFS).  */
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;

/* Duplicates info from stdint.h but this is used in unistd.h.  */
typedef  long int  __intptr_t;

/* Duplicate info from sys/socket.h.  */
typedef  unsigned int  __socklen_t;


#undef __STD_TYPE

/* bits/types.h */
# 28 "/usr/include/ctype.h" 2 3


 


/* These are all the characteristics of characters.
   If there get to be more than 16 distinct characteristics,
   many things must be changed that use `unsigned short int's.

   The characteristics are stored always in network byte order (big
   endian).  We define the bit value interpretations here dependent on the
   machine's byte order.  */

#include <endian.h>
# 1 "/usr/include/endian.h" 1 3
/* Copyright (C) 1992, 1996, 1997, 2000, 2008 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */


#define	_ENDIAN_H	1

#include <features.h>

/* Definitions for byte order, according to significance of bytes,
   from low addresses to high addresses.  The value is what you get by
   putting '4' in the most significant byte, '3' in the second most
   significant byte, '2' in the second least significant byte, and '1'
   in the least significant byte, and then writing down one digit for
   each byte, starting with the byte at the lowest address at the left,
   and proceeding to the byte with the highest address at the right.  */

#define	__LITTLE_ENDIAN	1234
#define	__BIG_ENDIAN	4321
#define	__PDP_ENDIAN	3412

/* This file defines `__BYTE_ORDER' for the particular machine.  */
#include <bits/endian.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3
/* x86_64 is little-endian.  */





#define __BYTE_ORDER __LITTLE_ENDIAN
# 37 "/usr/include/endian.h" 2 3


/* Some machines may need to use a different endianness for floating point
   values.  */

#define __FLOAT_WORD_ORDER __BYTE_ORDER



#define LITTLE_ENDIAN	__LITTLE_ENDIAN
#define BIG_ENDIAN	__BIG_ENDIAN
#define PDP_ENDIAN	__PDP_ENDIAN
#define BYTE_ORDER	__BYTE_ORDER



#define __LONG_LONG_PAIR(HI, LO) LO, HI






/* Conversion interfaces.  */
#include <bits/byteswap.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3
/* Macros to swap the order of bytes in integer values.
   Copyright (C) 1997, 1998, 2000, 2002, 2003, 2007, 2008, 2010, 2011
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */






#define _BITS_BYTESWAP_H 1

#include <bits/wordsize.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3
/* Determine the wordsize from the preprocessor defines.  */


#define __WORDSIZE	64
#define __WORDSIZE_COMPAT32	1



# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3


/* Swap bytes in 16 bit value.  */
#define __bswap_constant_16(x) \
     ((unsigned short int) ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8)))


#define __bswap_16(x) \
     (__extension__							      \
      ({ register unsigned short int __v, __x = (unsigned short int) (x);     \
	 if (__builtin_constant_p (__x))				      \
	   __v = __bswap_constant_16 (__x);				      \
	 else								      \
	   __asm__ ("rorw $8, %w0"					      \
		    : "=r" (__v)					      \
		    : "0" (__x)						      \
		    : "cc");						      \
	 __v; }))









/* Swap bytes in 32 bit value.  */
#define __bswap_constant_32(x) \
     ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) |		      \
      (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24))








/* To swap the bytes in a word the i486 processors and up provide the
   `bswap' opcode.  On i386 we have to use three instructions.  */
#define __bswap_32(x) \
     (__extension__							      \
      ({ register unsigned int __v, __x = (x);				      \
	 if (__builtin_constant_p (__x))				      \
	   __v = __bswap_constant_32 (__x);				      \
	 else								      \
	   __asm__ ("bswap %0" : "=r" (__v) : "0" (__x));		      \
	 __v; }))
# 91 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3









/* Swap bytes in 64 bit value.  */
#define __bswap_constant_64(x) \
     (__extension__ ((((x) & 0xff00000000000000ull) >> 56)		      \
		     | (((x) & 0x00ff000000000000ull) >> 40)		      \
		     | (((x) & 0x0000ff0000000000ull) >> 24)		      \
		     | (((x) & 0x000000ff00000000ull) >> 8)		      \
		     | (((x) & 0x00000000ff000000ull) << 8)		      \
		     | (((x) & 0x0000000000ff0000ull) << 24)		      \
		     | (((x) & 0x000000000000ff00ull) << 40)		      \
		     | (((x) & 0x00000000000000ffull) << 56)))


#define __bswap_64(x) \
     (__extension__							      \
      ({ register unsigned long __v, __x = (x);				      \
	 if (__builtin_constant_p (__x))				      \
	   __v = __bswap_constant_64 (__x);				      \
	 else								      \
	   __asm__ ("bswap %q0" : "=r" (__v) : "0" (__x));		      \
	 __v; }))
# 134 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3



/* _BITS_BYTESWAP_H */
# 61 "/usr/include/endian.h" 2 3



#define htobe16(x) __bswap_16 (x)
#define htole16(x) (x)
#define be16toh(x) __bswap_16 (x)
#define le16toh(x) (x)

#define htobe32(x) __bswap_32 (x)
#define htole32(x) (x)
#define be32toh(x) __bswap_32 (x)
#define le32toh(x) (x)

#define htobe64(x) __bswap_64 (x)
#define htole64(x) (x)
#define be64toh(x) __bswap_64 (x)
#define le64toh(x) (x)
# 93 "/usr/include/endian.h" 3



/* endian.h */
# 41 "/usr/include/ctype.h" 2 3

/* __BYTE_ORDER == __LITTLE_ENDIAN */


#define _ISbit(bit)	((bit) < 8 ? ((1 << (bit)) << 8) : ((1 << (bit)) >> 8))


enum
{
  _ISupper = (( 0 ) < 8 ? ((1 << ( 0 )) << 8) : ((1 << ( 0 )) >> 8)) ,	/* UPPERCASE.  */
  _ISlower = (( 1 ) < 8 ? ((1 << ( 1 )) << 8) : ((1 << ( 1 )) >> 8)) ,	/* lowercase.  */
  _ISalpha = (( 2 ) < 8 ? ((1 << ( 2 )) << 8) : ((1 << ( 2 )) >> 8)) ,	/* Alphabetic.  */
  _ISdigit = (( 3 ) < 8 ? ((1 << ( 3 )) << 8) : ((1 << ( 3 )) >> 8)) ,	/* Numeric.  */
  _ISxdigit = (( 4 ) < 8 ? ((1 << ( 4 )) << 8) : ((1 << ( 4 )) >> 8)) ,	/* Hexadecimal numeric.  */
  _ISspace = (( 5 ) < 8 ? ((1 << ( 5 )) << 8) : ((1 << ( 5 )) >> 8)) ,	/* Whitespace.  */
  _ISprint = (( 6 ) < 8 ? ((1 << ( 6 )) << 8) : ((1 << ( 6 )) >> 8)) ,	/* Printing.  */
  _ISgraph = (( 7 ) < 8 ? ((1 << ( 7 )) << 8) : ((1 << ( 7 )) >> 8)) ,	/* Graphical.  */
  _ISblank = (( 8 ) < 8 ? ((1 << ( 8 )) << 8) : ((1 << ( 8 )) >> 8)) ,	/* Blank (usually SPC and TAB).  */
  _IScntrl = (( 9 ) < 8 ? ((1 << ( 9 )) << 8) : ((1 << ( 9 )) >> 8)) ,	/* Control character.  */
  _ISpunct = (( 10 ) < 8 ? ((1 << ( 10 )) << 8) : ((1 << ( 10 )) >> 8)) ,	/* Punctuation.  */
  _ISalnum = (( 11 ) < 8 ? ((1 << ( 11 )) << 8) : ((1 << ( 11 )) >> 8)) 	/* Alphanumeric.  */
};
/* ! _ISbit  */

/* These are defined in ctype-info.c.
   The declarations here must match those in localeinfo.h.

   In the thread-specific locale model (see `uselocale' in <locale.h>)
   we cannot use global variables for these as was done in the past.
   Instead, the following accessor functions return the address of
   each variable, which is local to the current thread if multithreaded.

   These point into arrays of 384, so they can be indexed by any `unsigned
   char' value [0,255]; by EOF (-1); or by any `signed char' value
   [-128,-1).  ISO C requires that the ctype functions work for `unsigned
   char' values and for EOF; we also support negative `signed char' values
   for broken old programs.  The case conversion arrays are of `int's
   rather than `unsigned char's because tolower (EOF) must be EOF, which
   doesn't fit into an `unsigned char'.  But today more important is that
   the arrays are also used for multi-byte character sets.  */
extern __const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__const));



#define __isctype(c, type) \
  ((*__ctype_b_loc ())[(int) (c)] & (unsigned short int) type)









#define	__isascii(c)	(((c) & ~0x7f) == 0)	/* If C is a 7 bit value.  */
#define	__toascii(c)	((c) & 0x7f)		/* Mask off high bits.  */

#define	__exctype(name)	extern int name (int) __THROW

 

/* The following names are all functions:
     int isCHARACTERISTIC(int c);
   which return nonzero iff C has CHARACTERISTIC.
   For the meaning of the characteristic names, see the `enum' above.  */
extern int  isalnum  (int) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  isalpha  (int) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  iscntrl  (int) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  isdigit  (int) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  islower  (int) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  isgraph  (int) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  isprint  (int) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  ispunct  (int) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  isspace  (int) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  isupper  (int) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  isxdigit  (int) __attribute__ ((__nothrow__ , __leaf__ ))  ;


/* Return the lowercase version of C.  */
extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Return the uppercase version of C.  */
extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__ )) ;

 


/* ISO C99 introduced one new function.  */

 

extern int  isblank  (int) __attribute__ ((__nothrow__ , __leaf__ ))  ;

 









/* Return nonzero iff C is in the ASCII set
   (i.e., is no more than 7 bits wide).  */
extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Return the part of C that is in the ASCII set
   (i.e., the low-order 7 bits of C).  */
extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* These are the same as `toupper' and `tolower' except that they do not
   check the argument for being in the range of a `char'.  */
extern int  _toupper  (int) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  _tolower  (int) __attribute__ ((__nothrow__ , __leaf__ ))  ;
/* Use SVID or use misc.  */

/* This code is needed for the optimized mapping functions.  */
#define __tobody(c, f, a, args) \
  (__extension__							      \
   ({ int __res;							      \
      if (sizeof (c) > 1)						      \
	{								      \
	  if (__builtin_constant_p (c))					      \
	    {								      \
	      int __c = (c);						      \
	      __res = __c < -128 || __c > 255 ? __c : (a)[__c];		      \
	    }								      \
	  else								      \
	    __res = f args;						      \
	}								      \
      else								      \
	__res = (a)[(int) (c)];						      \
      __res; }))


# 198 "/usr/include/ctype.h" 3

#define isalnum(c)	__isctype((c), _ISalnum)
#define isalpha(c)	__isctype((c), _ISalpha)
#define iscntrl(c)	__isctype((c), _IScntrl)
#define isdigit(c)	__isctype((c), _ISdigit)
#define islower(c)	__isctype((c), _ISlower)
#define isgraph(c)	__isctype((c), _ISgraph)
#define isprint(c)	__isctype((c), _ISprint)
#define ispunct(c)	__isctype((c), _ISpunct)
#define isspace(c)	__isctype((c), _ISspace)
#define isupper(c)	__isctype((c), _ISupper)
#define isxdigit(c)	__isctype((c), _ISxdigit)

#define isblank(c)	__isctype((c), _ISblank)



# 227 "/usr/include/ctype.h" 3


/* Optimizing gcc */





#define isascii(c)	__isascii (c)
#define toascii(c)	__toascii (c)

#define _tolower(c)	((int) (*__ctype_tolower_loc ())[(int) (c)])
#define _toupper(c)	((int) (*__ctype_toupper_loc ())[(int) (c)])


/* Not __NO_CTYPE.  */



/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another application is
   the implementation of the internationalization handling in the
   upcoming ISO C++ standard library.  To support this another set of
   the functions using locale data exist which have an additional
   argument.

   Attention: all these functions are *not* standardized in any form.
   This is a proof-of-concept implementation.  */

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  */
#include <xlocale.h>
# 1 "/usr/include/xlocale.h" 1 3
/* Definition of locale datatype.
   Copyright (C) 1997,2000,2002,2009,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */


#define _XLOCALE_H	1

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  The file and
   this data structure is not standardized.  Don't rely on it.  It can
   go away without warning.  */
typedef struct __locale_struct
{
  /* Note: LC_ALL is not a valid index into this array.  */
  struct __locale_data *__locales[13]; /* 13 = __LC_LAST. */

  /* To increase the speed of this solution we add some special members.  */
  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;

  /* Note: LC_ALL is not a valid index into this array.  */
  const char *__names[13];
} *__locale_t;

/* POSIX 2008 makes locale_t official.  */
typedef __locale_t locale_t;

/* xlocale.h */
# 259 "/usr/include/ctype.h" 2 3


/* These definitions are similar to the ones above but all functions
   take as an argument a handle for the locale which shall be used.  */
#define __isctype_l(c, type, locale) \
  ((locale)->__ctype_b[(int) (c)] & (unsigned short int) type)

#define __exctype_l(name) 						      \
  extern int name (int, __locale_t) __THROW

/* The following names are all functions:
     int isCHARACTERISTIC(int c, locale_t *locale);
   which return nonzero iff C has CHARACTERISTIC.
   For the meaning of the characteristic names, see the `enum' above.  */
extern int  isalnum_l  (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  isalpha_l  (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  iscntrl_l  (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  isdigit_l  (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  islower_l  (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  isgraph_l  (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  isprint_l  (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  ispunct_l  (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  isspace_l  (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  isupper_l  (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__ ))  ;
extern int  isxdigit_l  (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__ ))  ;

extern int  isblank_l  (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__ ))  ;


/* Return the lowercase version of C in locale L.  */
extern int __tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__ )) ;
extern int tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Return the uppercase version of C.  */
extern int __toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__ )) ;
extern int toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Optimizing gcc */










#define __isalnum_l(c,l)	__isctype_l((c), _ISalnum, (l))
#define __isalpha_l(c,l)	__isctype_l((c), _ISalpha, (l))
#define __iscntrl_l(c,l)	__isctype_l((c), _IScntrl, (l))
#define __isdigit_l(c,l)	__isctype_l((c), _ISdigit, (l))
#define __islower_l(c,l)	__isctype_l((c), _ISlower, (l))
#define __isgraph_l(c,l)	__isctype_l((c), _ISgraph, (l))
#define __isprint_l(c,l)	__isctype_l((c), _ISprint, (l))
#define __ispunct_l(c,l)	__isctype_l((c), _ISpunct, (l))
#define __isspace_l(c,l)	__isctype_l((c), _ISspace, (l))
#define __isupper_l(c,l)	__isctype_l((c), _ISupper, (l))
#define __isxdigit_l(c,l)	__isctype_l((c), _ISxdigit, (l))

#define __isblank_l(c,l)	__isctype_l((c), _ISblank, (l))


#define __isascii_l(c,l)	((l), __isascii (c))
#define __toascii_l(c,l)	((l), __toascii (c))


#define isalnum_l(c,l)	__isalnum_l ((c), (l))
#define isalpha_l(c,l)	__isalpha_l ((c), (l))
#define iscntrl_l(c,l)	__iscntrl_l ((c), (l))
#define isdigit_l(c,l)	__isdigit_l ((c), (l))
#define islower_l(c,l)	__islower_l ((c), (l))
#define isgraph_l(c,l)	__isgraph_l ((c), (l))
#define isprint_l(c,l)	__isprint_l ((c), (l))
#define ispunct_l(c,l)	__ispunct_l ((c), (l))
#define isspace_l(c,l)	__isspace_l ((c), (l))
#define isupper_l(c,l)	__isupper_l ((c), (l))
#define isxdigit_l(c,l)	__isxdigit_l ((c), (l))

#define isblank_l(c,l)	__isblank_l ((c), (l))


#define isascii_l(c,l)	__isascii_l ((c), (l))
#define toascii_l(c,l)	__toascii_l ((c), (l))


/* Not __NO_CTYPE.  */

/* Use POSIX 2008.  */

 

/* ctype.h  */
# 33 "forms.c" 2

#include "include/forms.h"
# 1 "include/forms.h" 1
/*
 *
 *  This file is part of the XForms library package.
 *
 * XForms is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1, or
 * (at your option) any later version.
 *
 * XForms is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with XForms.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 *  \file forms.h
 *
 *. All XForms files as distributed in this package are
 *  Copyright(c) 1996-2002 by T.C. Zhao and Mark Overmars,
 *  with part of the code Copyright (c) 1999-2002 by T.C. Zhao
 *  and Steve Lamont.
 *  ALL RIGHTS RESERVED.
 *
 * Permission to use, copy, and distribute this software in its entirety
 * without fee, is hereby granted, provided that the above copyright
 * notice and this permission notice appear in all copies and their
 * documentation.
 *
 * As of April 2002, xforms is released under the GNU LGPL license.
 * You can use xforms for any purpose that's compatible with
 * LGPL with the restriction that you will need a special license
 * for distributed  binary commercial software that requires or is
 * based on xforms or its derivative.
 *
 * This software is provided "as is" without expressed or implied
 * warranty of any kind.
 *
 * The homepage for XForms is at
 * https://savannah.nongnu.org/projects/xforms/
 *
 * If you have questions about XForms or encounter problems please
 * subscribe to the mailing list at
 * http://cweblog.usuhs.mil/mailman/listinfo/xforms
 *
 * ******** This file is generated automatically. DO NOT CHANGE *********
 */


#define FL_FORMS_H

#define FL_VERSION             1
#define FL_REVISION            3
#define FL_FIXLEVEL            "5"
#define FL_INCLUDE_VERSION     ( FL_VERSION * 1000 + FL_REVISION )

#include <stdio.h>
# 1 "/usr/include/stdio.h" 1 3
/* Define ISO C stdio on top of C++ iostreams.
   Copyright (C) 1991, 1994-2010, 2011 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.19 Input/output	<stdio.h>
 */




#define _STDIO_H	1
#include <features.h>

 

#define __need_size_t
#define __need_NULL
#include <stddef.h>
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004, 2009
   Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3



/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
/* defined(_ANSI_H_) || defined(_MACHINE_ANSI_H_) || defined(_X86_64_ANSI_H_) || defined(_I386_ANSI_H_) */
# 93 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */













/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* _STDDEF_H or __need_ptrdiff_t.  */
# 163 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* BeOS */
/* Cray Unicos/Mk */
/* in case <sys/types.h> has defined it. */








/* Darwin */
/* FreeBSD 5 */




#define __size_t__	/* BeOS */
#define __SIZE_T__	/* Cray Unicos/Mk */
#define _SIZE_T
#define _SYS_SIZE_T_H
#define _T_SIZE_
#define _T_SIZE
#define __SIZE_T
#define _SIZE_T_
#define _BSD_SIZE_T_
#define _SIZE_T_DEFINED_
#define _SIZE_T_DEFINED
#define _BSD_SIZE_T_DEFINED_	/* Darwin */
#define _SIZE_T_DECLARED	/* FreeBSD 5 */
#define ___int_size_t_h
#define _GCC_SIZE_T
#define _SIZET_



#define __size_t





typedef long unsigned int  size_t;
/* __BEOS__ */


/* !(defined (__GNUG__) && defined (size_t)) */
/* __size_t */
/* _SIZET_ */
/* _GCC_SIZE_T */
/* ___int_size_t_h */
/* _SIZE_T_DECLARED */
/* _BSD_SIZE_T_DEFINED_ */
/* _SIZE_T_DEFINED */
/* _SIZE_T_DEFINED_ */
/* _BSD_SIZE_T_ */
/* _SIZE_T_ */
/* __SIZE_T */
/* _T_SIZE */
/* _T_SIZE_ */
/* _SYS_SIZE_T_H */
/* _SIZE_T */
/* __SIZE_T__ */
/* __size_t__ */
#undef	__need_size_t
/* _STDDEF_H or __need_size_t.  */


/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* _STDDEF_H or __need_wchar_t.  */
# 344 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


# 356 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
/* _ANSI_H_ || _MACHINE_ANSI_H_ || _X86_64_ANSI_H_ || _I386_ANSI_H_ */
# 390 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* __sys_stdtypes_h */

/* A null pointer constant.  */


#undef NULL		/* in case <stdio.h> has defined it. */
/* G++ */



#define NULL ((void *)0)
/* C++ *//* C++ */


/* G++ */
/* NULL not defined and <stddef.h> or need NULL.  */
#undef	__need_NULL

/* _STDDEF_H was defined this time */






/* !_STDDEF_H && !_STDDEF_H_ && !_ANSI_STDDEF_H && !__STDDEF_H__
	  || __need_XXX was not defined before */
# 34 "/usr/include/stdio.h" 2 3


#include <bits/types.h>
#define __need_FILE
#define __need___FILE
/* Don't need FILE.  */




/* Define outside of namespace so the C++ is happy.  */
struct _IO_FILE;

 
/* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE FILE;
 



 


#define __FILE_defined	1
/* FILE not defined.  */
#undef	__need_FILE




/* The opaque type of streams.  This is the definition used elsewhere.  */
typedef struct _IO_FILE __FILE;

#define ____FILE_defined	1
/* __FILE not defined.  */
#undef	__need___FILE



#define _STDIO_USES_IOSTREAM

#include <libio.h>
# 1 "/usr/include/libio.h" 1 3
/* Copyright (C) 1991-1995,1997-2006,2007,2009,2011 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Written by Per Bothner <bothner@cygnus.com>.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.

   As a special exception, if you link the code in this file with
   files compiled with a GNU compiler to produce an executable,
   that does not cause the resulting executable to be covered by
   the GNU Lesser General Public License.  This exception does not
   however invalidate any other reasons why the executable file
   might be covered by the GNU Lesser General Public License.
   This exception applies to code released by its copyright holders
   in files containing the exception.  */


#define _IO_STDIO_H

#include <_G_config.h>
# 1 "/usr/include/_G_config.h" 1 3
/* This file is needed by libio to define various configuration parameters.
   These are always the same in the GNU C library.  */


#define _G_config_h 1

/* Define types for libio in terms of the standard internal type names.  */

#include <bits/types.h>
#define __need_size_t



#define __need_NULL
#include <stddef.h>
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004, 2009
   Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3



/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
/* defined(_ANSI_H_) || defined(_MACHINE_ANSI_H_) || defined(_X86_64_ANSI_H_) || defined(_I386_ANSI_H_) */
# 93 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */













/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* _STDDEF_H or __need_ptrdiff_t.  */
# 163 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* BeOS *//* __size_t__ */
# 233 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3

#undef	__need_size_t
/* _STDDEF_H or __need_size_t.  */


/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* _STDDEF_H or __need_wchar_t.  */
# 344 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


# 356 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
/* _ANSI_H_ || _MACHINE_ANSI_H_ || _X86_64_ANSI_H_ || _I386_ANSI_H_ */
# 390 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* __sys_stdtypes_h */

/* A null pointer constant.  */


#undef NULL		/* in case <stdio.h> has defined it. */
/* G++ */



#define NULL ((void *)0)
/* C++ *//* C++ */


/* G++ */
/* NULL not defined and <stddef.h> or need NULL.  */
#undef	__need_NULL

/* _STDDEF_H was defined this time */






/* !_STDDEF_H && !_STDDEF_H_ && !_ANSI_STDDEF_H && !__STDDEF_H__
	  || __need_XXX was not defined before */
# 15 "/usr/include/_G_config.h" 2 3

#define __need_mbstate_t



#include <wchar.h>
# 1 "/usr/include/wchar.h" 1 3
/* Copyright (C) 1995-2008, 2009, 2010, 2011 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *      ISO C99 Standard: 7.24
 *	Extended multibyte and wide character utilities	<wchar.h>
 */








# 48 "/usr/include/wchar.h" 3

# 78 "/usr/include/wchar.h" 3



#define __mbstate_t_defined	1
/* Conversion state information.  */
typedef struct
{
  int __count;
  union
  {

    unsigned int  __wch;



    char __wchb[4];
  } __value;		/* Value so far.  */
} __mbstate_t;

#undef __need_mbstate_t


/* The rest of the file is only used if used if __need_mbstate_t is not
   defined.  */
/* _WCHAR_H defined */
# 890 "/usr/include/wchar.h" 3


/* wchar.h  */

/* Undefine all __need_* constants in case we are included to get those
   constants but the whole file was already read.  */
#undef __need_mbstate_t
#undef __need_wint_t
# 20 "/usr/include/_G_config.h" 2 3

#define _G_size_t	size_t
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
#define _G_ssize_t	__ssize_t
#define _G_off_t	__off_t
#define _G_off64_t	__off64_t
#define	_G_pid_t	__pid_t
#define	_G_uid_t	__uid_t
#define _G_wchar_t	wchar_t
#define _G_wint_t	wint_t
#define _G_stat64	stat64
# 51 "/usr/include/_G_config.h" 3


typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));

#define _G_HAVE_BOOL 1


/* These library features are always available in the GNU C library.  */
#define _G_HAVE_ATEXIT 1
#define _G_HAVE_SYS_CDEFS 1
#define _G_HAVE_SYS_WAIT 1
#define _G_NEED_STDARG_H 1
#define _G_va_list __gnuc_va_list

#define _G_HAVE_PRINTF_FP 1
#define _G_HAVE_MMAP 1
#define _G_HAVE_MREMAP 1
#define _G_HAVE_LONG_DOUBLE_IO 1
#define _G_HAVE_IO_FILE_OPEN 1
#define _G_HAVE_IO_GETLINE_INFO 1

#define _G_IO_IO_FILE_VERSION 0x20001

#define _G_OPEN64	__open64
#define _G_LSEEK64	__lseek64
#define _G_MMAP64	__mmap64
#define _G_FSTAT64(fd,buf) __fxstat64 (_STAT_VER, fd, buf)

/* This is defined by <bits/stat.h> if `st_blksize' exists.  */
#define _G_HAVE_ST_BLKSIZE defined (_STATBUF_ST_BLKSIZE)

#define _G_BUFSIZ 8192

/* These are the vtbl details for ELF.  */
#define _G_NAMES_HAVE_UNDERSCORE 0
#define _G_VTABLE_LABEL_HAS_LENGTH 1
#define _G_USING_THUNKS	1
#define _G_VTABLE_LABEL_PREFIX "__vt_"
#define _G_VTABLE_LABEL_PREFIX_ID __vt_



#define _G_ARGS(ARGLIST) ARGLIST




/* _G_config.h */
# 32 "/usr/include/libio.h" 2 3

/* ALL of these should be defined in _G_config.h */
#define _IO_pos_t _G_fpos_t /* obsolete */
#define _IO_fpos_t _G_fpos_t
#define _IO_fpos64_t _G_fpos64_t
#define _IO_size_t _G_size_t
#define _IO_ssize_t _G_ssize_t
#define _IO_off_t _G_off_t
#define _IO_off64_t _G_off64_t
#define _IO_pid_t _G_pid_t
#define _IO_uid_t _G_uid_t
#define _IO_iconv_t _G_iconv_t
#define _IO_HAVE_SYS_WAIT _G_HAVE_SYS_WAIT
#define _IO_HAVE_ST_BLKSIZE _G_HAVE_ST_BLKSIZE
#define _IO_BUFSIZ _G_BUFSIZ
#define _IO_va_list _G_va_list
#define _IO_wint_t _G_wint_t


/* This define avoids name pollution if we're using GNU stdarg.h */
#define __need___va_list
#include <stdarg.h>
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h" 1 3
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2009 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */



/* not __need___va_list */



#undef __need___va_list

/* Define __gnuc_va_list.  */


#define __GNUC_VA_LIST
typedef __builtin_va_list __gnuc_va_list;


/* Define the standard macros for the user,
   if this invocation was from the user program.  */
/* _STDARG_H */
# 127 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h" 3


/* not _ANSI_STDARG_H_ */
/* not _STDARG_H */
# 53 "/usr/include/libio.h" 2 3


#undef _IO_va_list
#define _IO_va_list __gnuc_va_list
/* __GNUC_VA_LIST */


/*!__P*/
# 72 "/usr/include/libio.h" 3


/* For backward compatibility */

#define _PARAMS(protos) __P(protos)
/*!_PARAMS*/






#define _IO_UNIFIED_JUMPTABLES 1





#define EOF (-1)

# 103 "/usr/include/libio.h" 3


#define _IOS_INPUT	1
#define _IOS_OUTPUT	2
#define _IOS_ATEND	4
#define _IOS_APPEND	8
#define _IOS_TRUNC	16
#define _IOS_NOCREATE	32
#define _IOS_NOREPLACE	64
#define _IOS_BIN	128

/* Magic numbers and bits for the _flags field.
   The magic numbers use the high-order bits of _flags;
   the remaining bits are available for variable flags.
   Note: The magic numbers must all be negative if stdio
   emulation is desired. */

#define _IO_MAGIC 0xFBAD0000 /* Magic number */
#define _OLD_STDIO_MAGIC 0xFABC0000 /* Emulate old stdio. */
#define _IO_MAGIC_MASK 0xFFFF0000
#define _IO_USER_BUF 1 /* User owns buffer; don't delete it on close. */
#define _IO_UNBUFFERED 2
#define _IO_NO_READS 4 /* Reading not allowed */
#define _IO_NO_WRITES 8 /* Writing not allowd */
#define _IO_EOF_SEEN 0x10
#define _IO_ERR_SEEN 0x20
#define _IO_DELETE_DONT_CLOSE 0x40 /* Don't call close(_fileno) on cleanup. */
#define _IO_LINKED 0x80 /* Set if linked (using _chain) to streambuf::_list_all.*/
#define _IO_IN_BACKUP 0x100
#define _IO_LINE_BUF 0x200
#define _IO_TIED_PUT_GET 0x400 /* Set if put and get pointer logicly tied. */
#define _IO_CURRENTLY_PUTTING 0x800
#define _IO_IS_APPENDING 0x1000
#define _IO_IS_FILEBUF 0x2000
#define _IO_BAD_SEEN 0x4000
#define _IO_USER_LOCK 0x8000

#define _IO_FLAGS2_MMAP 1
#define _IO_FLAGS2_NOTCANCEL 2



#define _IO_FLAGS2_USER_WBUF 8






/* These are "formatting flags" matching the iostream fmtflags enum values. */
#define _IO_SKIPWS 01
#define _IO_LEFT 02
#define _IO_RIGHT 04
#define _IO_INTERNAL 010
#define _IO_DEC 020
#define _IO_OCT 040
#define _IO_HEX 0100
#define _IO_SHOWBASE 0200
#define _IO_SHOWPOINT 0400
#define _IO_UPPERCASE 01000
#define _IO_SHOWPOS 02000
#define _IO_SCIENTIFIC 04000
#define _IO_FIXED 010000
#define _IO_UNITBUF 020000
#define _IO_STDIO 040000
#define _IO_DONT_CLOSE 0100000
#define _IO_BOOLALPHA 0200000


struct _IO_jump_t;  struct _IO_FILE;

/* Handle lock.  */







typedef void _IO_lock_t;



/* A streammarker remembers a position in a buffer. */

struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;
  /* If _pos >= 0
 it points to _buf->Gbase()+_pos. FIXME comment */
  /* if _pos < 0, it points to _buf->eBptr()+_pos. FIXME comment */
  int _pos;
# 204 "/usr/include/libio.h" 3

};

/* This is the structure from the libstdc++ codecvt class.  */
enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};

# 271 "/usr/include/libio.h" 3


struct _IO_FILE {
  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */
#define _IO_file_flags _flags

  /* The following pointers correspond to the C++ streambuf protocol. */
  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
  char* _IO_read_ptr;	/* Current read pointer */
  char* _IO_read_end;	/* End of get area. */
  char* _IO_read_base;	/* Start of putback+get area. */
  char* _IO_write_base;	/* Start of put area. */
  char* _IO_write_ptr;	/* Current put pointer. */
  char* _IO_write_end;	/* End of put area. */
  char* _IO_buf_base;	/* Start of reserve area. */
  char* _IO_buf_end;	/* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t   _old_offset; /* This used to be _offset but it's too small.  */

#define __HAVE_COLUMN /* temporary */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  /*  char* _save_gptr;  char* _save_egptr; */

  _IO_lock_t *_lock;








  __off64_t   _offset;








  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;
  /* Make sure we don't get into trouble again.  */
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;

#define _IO_stdin ((_IO_FILE*)(&_IO_2_1_stdin_))
#define _IO_stdout ((_IO_FILE*)(&_IO_2_1_stdout_))
#define _IO_stderr ((_IO_FILE*)(&_IO_2_1_stderr_))







/* Functions to do I/O and file management for a stream.  */

/* Read NBYTES bytes from COOKIE into a buffer pointed to by BUF.
   Return number of bytes read.  */
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);

/* Write N bytes pointed to by BUF to COOKIE.  Write all N bytes
   unless there is an error.  Return number of bytes written, or -1 if
   there is an error without writing anything.  If the file has been
   opened for append (__mode.__append set), then set the file pointer
   to the end of the file and then do the write; if not, just write at
   the current file pointer.  */
typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
				 size_t __n);

/* Move COOKIE's file position to *POS bytes from the
   beginning of the file (if W is SEEK_SET),
   the current position (if W is SEEK_CUR),
   or the end of the file (if W is SEEK_END).
   Set *POS to the new file position.
   Returns zero if successful, nonzero if not.  */
typedef int __io_seek_fn (void *__cookie, __off64_t   *__pos, int __w);

/* Close COOKIE.  */
typedef int __io_close_fn (void *__cookie);


# 411 "/usr/include/libio.h" 3







extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);







#define _IO_BE(expr, res) __builtin_expect ((expr), res)




#define _IO_getc_unlocked(_fp) \
       (_IO_BE ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end, 0) \
	? __uflow (_fp) : *(unsigned char *) (_fp)->_IO_read_ptr++)
#define _IO_peekc_unlocked(_fp) \
       (_IO_BE ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end, 0) \
	  && __underflow (_fp) == EOF ? EOF \
	: *(unsigned char *) (_fp)->_IO_read_ptr)
#define _IO_putc_unlocked(_ch, _fp) \
   (_IO_BE ((_fp)->_IO_write_ptr >= (_fp)->_IO_write_end, 0) \
    ? __overflow (_fp, (unsigned char) (_ch)) \
    : (unsigned char) (*(_fp)->_IO_write_ptr++ = (_ch)))

# 457 "/usr/include/libio.h" 3


#define _IO_feof_unlocked(__fp) (((__fp)->_flags & _IO_EOF_SEEN) != 0)
#define _IO_ferror_unlocked(__fp) (((__fp)->_flags & _IO_ERR_SEEN) != 0)

extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__ )) ;
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__ )) ;

extern int _IO_peekc_locked (_IO_FILE *__fp);

/* This one is for Emacs. */
#define _IO_PENDING_OUTPUT_COUNT(_fp)	\
	((_fp)->_IO_write_ptr - (_fp)->_IO_write_base)

extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__ )) ;
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__ )) ;
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__ )) ;








#define _IO_peekc(_fp) _IO_peekc_unlocked (_fp)
#define _IO_flockfile(_fp) /**/
#define _IO_funlockfile(_fp) /**/
#define _IO_ftrylockfile(_fp) /**/
#define _IO_cleanup_region_start(_fct, _fp) /**/
#define _IO_cleanup_region_end(_Doit) /**/
/* !_IO_MTSAFE_IO */

extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
			__gnuc_va_list , int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
			 __gnuc_va_list );
extern __ssize_t   _IO_padn (_IO_FILE *, int, __ssize_t  );
extern size_t   _IO_sgetn (_IO_FILE *, void *, size_t  );

extern __off64_t   _IO_seekoff (_IO_FILE *, __off64_t  , int, int);
extern __off64_t   _IO_seekpos (_IO_FILE *, __off64_t  , int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__ )) ;

# 547 "/usr/include/libio.h" 3










/* _IO_STDIO_H */
# 75 "/usr/include/stdio.h" 2 3





typedef __gnuc_va_list  va_list;
#define _VA_LIST_DEFINED









typedef __off_t off_t;



#define __off_t_defined







typedef __ssize_t ssize_t;
#define __ssize_t_defined



/* The type of the second argument to `fgetpos' and `fsetpos'.  */
 

typedef _G_fpos_t fpos_t;



 




/* The possibilities for the third argument to `setvbuf'.  */
#define _IOFBF 0		/* Fully buffered.  */
#define _IOLBF 1		/* Line buffered.  */
#define _IONBF 2		/* No buffering.  */


/* Default buffer size.  */

#define BUFSIZ _IO_BUFSIZ



/* End of file character.
   Some things throughout the library rely on this being -1.  */





/* The possibilities for the third argument to `fseek'.
   These values should not be changed.  */
#define SEEK_SET	0	/* Seek from beginning of file.  */
#define SEEK_CUR	1	/* Seek from current position.  */
#define SEEK_END	2	/* Seek from end of file.  */







/* Default path prefix for `tempnam' and `tmpnam'.  */
#define P_tmpdir	"/tmp"



/* Get the values:
   L_tmpnam	How long an array of chars must be to be passed to `tmpnam'.
   TMP_MAX	The minimum number of unique filenames generated by tmpnam
		(and tempnam when it uses tmpnam's name space),
		or tempnam (the two are separate).
   L_ctermid	How long an array to pass to `ctermid'.
   L_cuserid	How long an array to pass to `cuserid'.
   FOPEN_MAX	Minimum number of files that can be open at once.
   FILENAME_MAX	Maximum length of a filename.  */
#include <bits/stdio_lim.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3
/* Copyright (C) 1994, 1997, 1998, 1999, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */






#define L_tmpnam 20
#define TMP_MAX 238328
#define FILENAME_MAX 4096


#define L_ctermid 9







#undef  FOPEN_MAX
#define FOPEN_MAX 16





# 165 "/usr/include/stdio.h" 2 3



/* Standard streams.  */
extern struct _IO_FILE *stdin;		/* Standard input stream.  */
extern struct _IO_FILE *stdout;		/* Standard output stream.  */
extern struct _IO_FILE *stderr;		/* Standard error output stream.  */
/* C89/C99 say they're macros.  Make them happy.  */
#define stdin stdin
#define stdout stdout
#define stderr stderr

 
/* Remove file FILENAME.  */
extern int remove (__const char *__filename) __attribute__ ((__nothrow__ , __leaf__ )) ;
/* Rename file OLD to NEW.  */
extern int rename (__const char *__old, __const char *__new) __attribute__ ((__nothrow__ , __leaf__ )) ;
 


/* Rename file OLD relative to OLDFD to NEW relative to NEWFD.  */
extern int renameat (int __oldfd, __const char *__old, int __newfd,
		     __const char *__new) __attribute__ ((__nothrow__ , __leaf__ )) ;


 
/* Create a temporary file and open it read/write.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern FILE *tmpfile (void)  ;












/* Generate a temporary filename.  */
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__ ))   ;
 


/* This is the reentrant variant of `tmpnam'.  The only difference is
   that it does not allow S to be NULL.  */
extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__ ))   ;




/* Generate a unique temporary filename using up to five characters of PFX
   if it is not NULL.  The directory to put this file in is searched for
   as follows: First the environment variable "TMPDIR" is checked.
   If it contains the name of a writable directory, that directory is used.
   If not and if DIR is not NULL, that value is checked.  If that fails,
   P_tmpdir is tried and finally "/tmp".  The storage for the filename
   is allocated by `malloc'.  */
extern char *tempnam (__const char *__dir, __const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__malloc__))   ;



 
/* Close STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fclose (FILE *__stream);
/* Flush STREAM, or all streams if STREAM is NULL.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fflush (FILE *__stream);
 


/* Faster versions when locking is not required.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fflush_unlocked (FILE *__stream);


# 264 "/usr/include/stdio.h" 3



 

/* Open a file and create a new stream for it.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *fopen (__const char *__restrict __filename,
		    __const char *__restrict __modes)  ;
/* Open a file, replacing an existing stream with it.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *freopen (__const char *__restrict __filename,
		      __const char *__restrict __modes,
		      FILE *__restrict __stream)  ;
# 295 "/usr/include/stdio.h" 3

 









/* Create a new stream that refers to an existing system file descriptor.  */
extern FILE *fdopen (int __fd, __const char *__modes) __attribute__ ((__nothrow__ , __leaf__ ))   ;











/* Create a new stream that refers to a memory buffer.  */
extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__ ))   ;

/* Open a stream that writes into a malloc'd buffer that is expanded as
   necessary.  *BUFLOC and *SIZELOC are updated with the buffer's location
   and the number of characters written on fflush or fclose.  */
extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__ ))   ;



 
/* If BUF is NULL, make STREAM unbuffered.
   Else make it use buffer BUF, of size BUFSIZ.  */
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__ )) ;
/* Make STREAM use buffering mode MODE.
   If BUF is not NULL, use N bytes of it for buffering;
   else allocate an internal buffer N bytes long.  */
extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
		    int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__ )) ;
 


/* If BUF is NULL, make STREAM unbuffered.
   Else make it use SIZE bytes of BUF for buffering.  */
extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
		       size_t __size) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Make STREAM line-buffered.  */
extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__ )) ;



 
/* Write formatted output to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fprintf (FILE *__restrict __stream,
		    __const char *__restrict __format, ...);
/* Write formatted output to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int printf (__const char *__restrict __format, ...);
/* Write formatted output to S.  */
extern int sprintf (char *__restrict __s,
		    __const char *__restrict __format, ...) __attribute__ ((__nothrow__)) ;

/* Write formatted output to S from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
		     __gnuc_va_list  __arg);
/* Write formatted output to stdout from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vprintf (__const char *__restrict __format, __gnuc_va_list  __arg);
/* Write formatted output to S from argument list ARG.  */
extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
		     __gnuc_va_list  __arg) __attribute__ ((__nothrow__)) ;
 


 
/* Maximum chars of output to write in MAXLEN.  */
extern int snprintf (char *__restrict __s, size_t __maxlen,
		     __const char *__restrict __format, ...)
     __attribute__ ((__nothrow__))  __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
		      __const char *__restrict __format, __gnuc_va_list  __arg)
     __attribute__ ((__nothrow__))  __attribute__ ((__format__ (__printf__, 3, 0)));
 


# 409 "/usr/include/stdio.h" 3



/* Write formatted output to a file descriptor.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern int vdprintf (int __fd, __const char *__restrict __fmt,
		     __gnuc_va_list  __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));



 
/* Read formatted input from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fscanf (FILE *__restrict __stream,
		   __const char *__restrict __format, ...)  ;
/* Read formatted input from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int scanf (__const char *__restrict __format, ...)  ;
/* Read formatted input from S.  */
extern int sscanf (__const char *__restrict __s,
		   __const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__ )) ;





/* For strict ISO C99 or POSIX compliance disallow %as, %aS and %a[
   GNU extension which conflicts with valid %a followed by letter
   s, S or [.  */
extern int  fscanf    (FILE *__restrict __stream,
				__const char *__restrict __format, ...)  __asm__ (""     "__isoc99_fscanf"    )   ;

extern int  scanf    (__const char *__restrict __format, ...)  __asm__ (""     "__isoc99_scanf"    )   ;

extern int  sscanf    (__const char *__restrict __s,
				    __const char *__restrict __format, ...)  __asm__ (""     "__isoc99_sscanf"    ) __attribute__ ((__nothrow__ , __leaf__ ))  ;

# 466 "/usr/include/stdio.h" 3



 


 
/* Read formatted input from S into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
		    __gnuc_va_list  __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0)))  ;

/* Read formatted input from stdin into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int vscanf (__const char *__restrict __format, __gnuc_va_list  __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0)))  ;

/* Read formatted input from S into argument list ARG.  */
extern int vsscanf (__const char *__restrict __s,
		    __const char *__restrict __format, __gnuc_va_list  __arg)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__format__ (__scanf__, 2, 0)));





/* For strict ISO C99 or POSIX compliance disallow %as, %aS and %a[
   GNU extension which conflicts with valid %a followed by letter
   s, S or [.  */
extern int  vfscanf   
		       (FILE *__restrict __s,
			__const char *__restrict __format, __gnuc_va_list  __arg)  __asm__ (""     "__isoc99_vfscanf"    ) 

     __attribute__ ((__format__ (__scanf__, 2, 0)))  ;
extern int  vscanf    (__const char *__restrict __format,
				__gnuc_va_list  __arg)  __asm__ (""     "__isoc99_vscanf"    ) 
     __attribute__ ((__format__ (__scanf__, 1, 0)))  ;
extern int  vsscanf   
			   (__const char *__restrict __s,
			    __const char *__restrict __format,
			    __gnuc_va_list  __arg)  __asm__ (""     "__isoc99_vsscanf"    ) __attribute__ ((__nothrow__ , __leaf__ ))  
     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 525 "/usr/include/stdio.h" 3



 
/* Use ISO C9x.  */


 
/* Read a character from STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);

/* Read a character from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getchar (void);
 

/* The C standard explicitly says this is a macro, so we always do the
   optimization for it.  */
#define getc(_fp) _IO_getc (_fp)


/* These are defined in POSIX.1:1996.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
/* Use POSIX or MISC.  */


/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fgetc_unlocked (FILE *__stream);
/* Use MISC.  */


 
/* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.

   These functions is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);

/* Write a character to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int putchar (int __c);
 

/* The C standard explicitly says this can be a macro,
   so we always do the optimization for it.  */
#define putc(_ch, _fp) _IO_putc (_ch, _fp)


/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern int fputc_unlocked (int __c, FILE *__stream);
/* Use MISC.  */


/* These are defined in POSIX.1:1996.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */
extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);
/* Use POSIX or MISC.  */




/* Get a word (int) from STREAM.  */
extern int getw (FILE *__stream);

/* Write a word (int) to STREAM.  */
extern int putw (int __w, FILE *__stream);



 
/* Get a newline-terminated string of finite length from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
      ;

/* Get a newline-terminated string from stdin, removing the newline.
   DO NOT USE THIS FUNCTION!!  There is no limit on how much it will read.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern char *gets (char *__s)  ;
 

# 648 "/usr/include/stdio.h" 3




/* Read up to (and including) a DELIMITER from STREAM into *LINEPTR
   (and null-terminate it). *LINEPTR is a pointer returned from malloc (or
   NULL), pointing to *N characters of space.  It is realloc'd as
   necessary.  Returns the number of characters read (not including the
   null terminator), or -1 on error or EOF.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern __ssize_t   __getdelim (char **__restrict __lineptr,
			       size_t *__restrict __n, int __delimiter,
			       FILE *__restrict __stream)  ;
extern __ssize_t   getdelim (char **__restrict __lineptr,
			     size_t *__restrict __n, int __delimiter,
			     FILE *__restrict __stream)  ;

/* Like `getdelim', but reads up to a newline.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
extern __ssize_t   getline (char **__restrict __lineptr,
			    size_t *__restrict __n,
			    FILE *__restrict __stream)  ;



 
/* Write a string to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);

/* Write a string, followed by a newline, to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int puts (__const char *__s);


/* Push a character back onto the input buffer of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int ungetc (int __c, FILE *__stream);


/* Read chunks of generic data from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern size_t fread (void *__restrict __ptr, size_t __size,
		     size_t __n, FILE *__restrict __stream)  ;
/* Write chunks of generic data to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
		      size_t __n, FILE *__restrict __s);
 

# 725 "/usr/include/stdio.h" 3



/* Faster versions when locking is not necessary.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
			      size_t __n, FILE *__restrict __stream)  ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
			       size_t __n, FILE *__restrict __stream);



 
/* Seek to a certain position on STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fseek (FILE *__stream, long int __off, int __whence);
/* Return the current position of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern long int ftell (FILE *__stream)  ;
/* Rewind to the beginning of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void rewind (FILE *__stream);
 

/* The Single Unix Specification, Version 2, specifies an alternative,
   more adequate interface for the two functions above which deal with
   file offset.  `long int' is not the right type.  These definitions
   are originally defined in the Large File Support API.  */



/* Seek to a certain position on STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fseeko (FILE *__stream, __off_t __off, int __whence);
/* Return the current position of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern __off_t ftello (FILE *__stream)  ;
# 786 "/usr/include/stdio.h" 3



 

/* Get STREAM's position.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);
/* Set STREAM's position.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
# 811 "/usr/include/stdio.h" 3

 








 
/* Clear the error and EOF indicators for STREAM.  */
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__ )) ;
/* Return the EOF indicator for STREAM.  */
extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__ ))   ;
/* Return the error indicator for STREAM.  */
extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__ ))   ;
 


/* Faster versions when locking is not required.  */
extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__ )) ;
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__ ))   ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__ ))   ;



 
/* Print a message describing the meaning of the value of errno.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern void perror (__const char *__s);
 

/* Provide the declarations for `sys_errlist' and `sys_nerr' if they
   are available on this system.  Even if available, these variables
   should not be used directly.  The `strerror' function provides
   all the necessary functionality.  */
#include <bits/sys_errlist.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3
/* Declare sys_errlist and sys_nerr, or don't.  Compatibility (do) version.
   Copyright (C) 2002 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */





/* sys_errlist and sys_nerr are deprecated.  Use strerror instead.  */


extern int sys_nerr;
extern __const char *__const sys_errlist[];





# 850 "/usr/include/stdio.h" 2 3




/* Return the system file descriptor for STREAM.  */
extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__ ))   ;
/* Use POSIX.  */


/* Faster version when locking is not required.  */
extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__ ))   ;





/* Create a new stream connected to a pipe running the given command.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern FILE *popen (__const char *__command, __const char *__modes)  ;

/* Close a stream opened by popen and return the status of its child.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int pclose (FILE *__stream);




/* Return the name of the controlling terminal.  */
extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__ )) ;
/* Use POSIX.  */


/* Use X/Open, but not issue 6.  */





/* Use GNU.  */
# 903 "/usr/include/stdio.h" 3




/* These are defined in POSIX.1:1996.  */

/* Acquire ownership of STREAM.  */
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Try to acquire ownership of STREAM but do not block if it is not
   possible.  */
extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__ ))   ;

/* Relinquish the ownership granted for STREAM.  */
extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__ )) ;
/* POSIX || misc */

/* X/Open, but not issue 6 and not for GNU.  */







/* If we are compiling with optimizing read this file.  It contains
   several optimizing inline functions and macros.  */










 

/* <stdio.h> included.  */

/* !_STDIO_H */
# 60 "include/forms.h" 2

#include <stdarg.h>
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h" 1 3
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2009 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */




#define _STDARG_H
#define _ANSI_STDARG_H_
/* not __need___va_list */
#undef __need___va_list

/* Define __gnuc_va_list.  */






/* Define the standard macros for the user,
   if this invocation was from the user program.  */


#define va_start(v,l)	__builtin_va_start(v,l)
#define va_end(v)	__builtin_va_end(v)
#define va_arg(v,l)	__builtin_va_arg(v,l)

#define va_copy(d,s)	__builtin_va_copy(d,s)

#define __va_copy(d,s)	__builtin_va_copy(d,s)

/* Define va_list, if desired, from __gnuc_va_list. */
/* We deliberately do not define va_list when called from
   stdio.h, because ANSI C says that stdio.h is not supposed to define
   va_list.  stdio.h needs to have access to that data type, 
   but must not use that name.  It should use the name __gnuc_va_list,
   which is safe because it is reserved for the implementation.  */

/* On OSF1, this means varargs.h is "half-loaded".  */







/* not __svr4__ || _SCO_DS */
# 87 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h" 3


/* The macro _VA_LIST_ is the same thing used by this file in Ultrix.
   But on BSD NET2 we must not test or define or undef it.
   (Note that the comments in NET 2's ansi.h
   are incorrect for _VA_LIST_--see stdio.h!)  */

/* The macro _VA_LIST_DEFINED is used in Windows NT 3.5  */
/* not _VA_LIST_DEFINED */
# 106 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stdarg.h" 3


#define _VA_LIST_


#define _VA_LIST





#define _VA_LIST_T_H


#define __va_list__


/* not _VA_LIST_, except on certain systems */

/* not __svr4__ */

/* _STDARG_H */

/* not _ANSI_STDARG_H_ */
/* not _STDARG_H */
# 61 "include/forms.h" 2

#include <string.h>
# 1 "/usr/include/string.h" 1 3
/* Copyright (C) 1991-1993,1995-2004,2007,2009,2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.21 String handling	<string.h>
 */


#define	_STRING_H	1

#include <features.h>

 

/* Get size_t and NULL from <stddef.h>.  */
#define	__need_size_t
#define	__need_NULL
#include <stddef.h>
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004, 2009
   Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3



/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
/* defined(_ANSI_H_) || defined(_MACHINE_ANSI_H_) || defined(_X86_64_ANSI_H_) || defined(_I386_ANSI_H_) */
# 93 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */













/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* _STDDEF_H or __need_ptrdiff_t.  */
# 163 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* BeOS *//* __size_t__ */
# 233 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3

#undef	__need_size_t
/* _STDDEF_H or __need_size_t.  */


/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* _STDDEF_H or __need_wchar_t.  */
# 344 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


# 356 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
/* _ANSI_H_ || _MACHINE_ANSI_H_ || _X86_64_ANSI_H_ || _I386_ANSI_H_ */
# 390 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* __sys_stdtypes_h */

/* A null pointer constant.  */


#undef NULL		/* in case <stdio.h> has defined it. */
/* G++ */



#define NULL ((void *)0)
/* C++ *//* C++ */


/* G++ */
/* NULL not defined and <stddef.h> or need NULL.  */
#undef	__need_NULL

/* _STDDEF_H was defined this time */






/* !_STDDEF_H && !_STDDEF_H_ && !_ANSI_STDDEF_H && !__STDDEF_H__
	  || __need_XXX was not defined before */
# 34 "/usr/include/string.h" 2 3


/* Tell the caller that we provide correct C++ prototypes.  */





 
/* Copy N bytes of SRC to DEST.  */
extern void *memcpy (void *__restrict __dest,
		     __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;
/* Copy N bytes of SRC to DEST, guaranteeing
   correct behavior for overlapping strings.  */
extern void *memmove (void *__dest, __const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;
 

/* Copy no more than N bytes of SRC to DEST, stopping when C is found.
   Return the position in DEST one byte past where C was copied,
   or NULL if C was not found in the first N bytes of SRC.  */

extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
		      int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;
/* SVID.  */


 
/* Set N bytes of S to C.  */
extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;

/* Compare N bytes of S1 and S2.  */
extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1, 2) )) ;

/* Search N bytes of S for C.  */
# 94 "/usr/include/string.h" 3

extern void *memchr (__const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1) )) ;

 

# 123 "/usr/include/string.h" 3



 
/* Copy SRC to DEST.  */
extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;
/* Copy no more than N characters of SRC to DEST.  */
extern char *strncpy (char *__restrict __dest,
		      __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;

/* Append SRC onto DEST.  */
extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;
/* Append no more than N characters from SRC onto DEST.  */
extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
		      size_t __n) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;

/* Compare S1 and S2.  */
extern int strcmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1, 2) )) ;
/* Compare N characters of S1 and S2.  */
extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1, 2) )) ;

/* Compare the collated forms of S1 and S2.  */
extern int strcoll (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1, 2) )) ;
/* Put a transformation of SRC into no more than N bytes of DEST.  */
extern size_t strxfrm (char *__restrict __dest,
		       __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (2) )) ;
 


/* The following functions are equivalent to the both above but they
   take the locale they use for the collation as an extra argument.
   This is not standardsized but something like will come.  */
#include <xlocale.h>

/* Compare the collated forms of S1 and S2 using rules from L.  */
extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1, 2, 3) )) ;
/* Put a transformation of SRC into no more than N bytes of DEST.  */
extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
			 __locale_t __l) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (2, 4) )) ;




/* Duplicate S, returning an identical malloc'd string.  */
extern char *strdup (__const char *__s)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__malloc__))  __attribute__ ((__nonnull__  (1) )) ;


/* Return a malloc'd copy of at most N bytes of STRING.  The
   resultant string is terminated even if no null terminator
   appears before STRING[N].  */

extern char *strndup (__const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__malloc__))  __attribute__ ((__nonnull__  (1) )) ;


# 208 "/usr/include/string.h" 3


 
/* Find the first occurrence of C in S.  */
# 234 "/usr/include/string.h" 3

extern char *strchr (__const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1) )) ;

/* Find the last occurrence of C in S.  */
# 261 "/usr/include/string.h" 3

extern char *strrchr (__const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1) )) ;

 

# 279 "/usr/include/string.h" 3


 
/* Return the length of the initial segment of S which
   consists entirely of characters not in REJECT.  */
extern size_t strcspn (__const char *__s, __const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1, 2) )) ;
/* Return the length of the initial segment of S which
   consists entirely of characters in ACCEPT.  */
extern size_t strspn (__const char *__s, __const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1, 2) )) ;
/* Find the first occurrence in S of any character in ACCEPT.  */
# 313 "/usr/include/string.h" 3

extern char *strpbrk (__const char *__s, __const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1, 2) )) ;

/* Find the first occurrence of NEEDLE in HAYSTACK.  */
# 341 "/usr/include/string.h" 3

extern char *strstr (__const char *__haystack, __const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1, 2) )) ;



/* Divide S into tokens separated by characters in DELIM.  */
extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (2) )) ;
 

/* Divide S into tokens separated by characters in DELIM.  Information
   passed between calls are stored in SAVE_PTR.  */
extern char *__strtok_r (char *__restrict __s,
			 __const char *__restrict __delim,
			 char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (2, 3) )) ;

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
		       char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (2, 3) )) ;


# 376 "/usr/include/string.h" 3


# 394 "/usr/include/string.h" 3



 
/* Return the length of S.  */
extern size_t strlen (__const char *__s)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1) )) ;
 


/* Find the length of STRING, but scan at most MAXLEN characters.
   If no '\0' terminator is found in that many characters, return MAXLEN.  */
extern size_t strnlen (__const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1) )) ;



 
/* Return a string describing the meaning of the `errno' code in ERRNUM.  */
extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__ )) ;
 

/* Reentrant version of `strerror'.
   There are 2 flavors of `strerror_r', GNU which returns the string
   and may or may not use the supplied temporary buffer and POSIX one
   which fills the string into the buffer.
   To use the POSIX version, -D_XOPEN_SOURCE=600 or -D_POSIX_C_SOURCE=200112L
   without -D_GNU_SOURCE is needed, otherwise the GNU version is
   preferred.  */

/* Fill BUF with a string describing the meaning of the `errno' code in
   ERRNUM.  */

extern int  strerror_r   
			   (int __errnum, char *__buf, size_t __buflen)  __asm__ (""     "__xpg_strerror_r"    ) __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__nonnull__  (2) )) ;















/* Translate error number to string according to the locale L.  */
extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__ )) ;



/* We define this function always since `bzero' is sometimes needed when
   the namespace rules does not allow this.  */
extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;


/* Copy N bytes of SRC to DEST (like memmove, but args reversed).  */
extern void bcopy (__const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;

/* Set N bytes of S to 0.  */
extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;

/* Compare N bytes of S1 and S2 (same as memcmp).  */
extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1, 2) )) ;

/* Find the first occurrence of C in S (same as strchr).  */
# 488 "/usr/include/string.h" 3

extern char *index (__const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1) )) ;


/* Find the last occurrence of C in S (same as strrchr).  */
# 516 "/usr/include/string.h" 3

extern char *rindex (__const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1) )) ;


/* Return the position of the first bit set in I, or 0 if none are set.
   The least-significant bit is position 1, the most-significant 32.  */
extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__const__));

/* The following two functions are non-standard but necessary for non-32 bit
   platforms.  */








/* Compare S1 and S2, ignoring case.  */
extern int strcasecmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1, 2) )) ;

/* Compare no more than N chars of S1 and S2, ignoring case.  */
extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1, 2) )) ;
/* Use BSD.  */

# 554 "/usr/include/string.h" 3



/* Return the next DELIM-delimited token from *STRINGP,
   terminating it with a '\0', and update *STRINGP to point past it.  */
extern char *strsep (char **__restrict __stringp,
		     __const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;



/* Return a string describing the meaning of the signal number in SIG.  */
extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Copy SRC to DEST, returning the address of the terminating '\0' in DEST.  */
extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;

/* Copy no more than N characters of SRC to DEST, returning the address of
   the last character written into DEST.  */
extern char *__stpncpy (char *__restrict __dest,
			__const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;
extern char *stpncpy (char *__restrict __dest,
		      __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;


# 609 "/usr/include/string.h" 3




# 638 "/usr/include/string.h" 3








 

/* string.h  */
# 62 "include/forms.h" 2

#include <limits.h>
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include-fixed/limits.h" 1 3
/* Copyright (C) 1992, 1994, 1997, 1998 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
/* Terminated in limity.h.  */
#define _GCC_LIMITS_H_


/* Use "..." so that we find syslimits.h only in this same directory.  */
#include "syslimits.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include-fixed/syslimits.h" 1 3
/* syslimits.h stands for the system's own limits.h file.
   If we can use it ok unmodified, then we install this text.
   If fixincludes fixes it, then the fixed version is installed
   instead of this text.  */

#define _GCC_NEXT_LIMITS_H		/* tell gcc's limits.h to recurse */
#include_next <limits.h>
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include-fixed/limits.h" 1 3
/* Copyright (C) 1992, 1994, 1997, 1998 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
/* Terminated in limity.h.  *//* not _GCC_LIMITS_H_ */
# 166 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include-fixed/limits.h" 3



#include_next <limits.h>		/* recurse down to the real one */
# 1 "/usr/include/limits.h" 1 3
/* Copyright (C) 1991, 1992, 1996, 1997, 1998, 1999, 2000, 2005
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types	<limits.h>
 */


#define _LIBC_LIMITS_H_	1

#include <features.h>


/* Maximum length of any multibyte character in any locale.
   We define this value here since the gcc header does not define
   the correct value.  */
#define MB_LEN_MAX	16


/* If we are not using GNU CC we have to define all the symbols ourself.
   Otherwise use gcc's definitions (see below).  */
/* GCC 2.  */
# 114 "/usr/include/limits.h" 3


/* !_LIBC_LIMITS_H_ */

 /* Get the compiler's limits.h, which defines almost all the ISO constants.

    We put this #include_next outside the double inclusion check because
    it should be possible to include this file more than once and still get
    the definitions from gcc's header.  */





/* The <limits.h> files in some gcc versions don't define LLONG_MIN,
   LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
   ages are available.  */


#define LLONG_MIN	(-LLONG_MAX-1)


#define LLONG_MAX	__LONG_LONG_MAX__


#define ULLONG_MAX	(LLONG_MAX * 2ULL + 1)




/* POSIX adds things to <limits.h>.  */
#include <bits/posix1_lim.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3
/* Copyright (C) 1991-1993,96,98,2000-2003,2004 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	POSIX Standard: 2.9.2 Minimum Values	Added to <limits.h>
 *
 *	Never include this file directly; use <limits.h> instead.
 */


#define	_BITS_POSIX1_LIM_H	1


/* These are the standard-mandated minimum values.  */

/* Minimum number of operations in one list I/O call.  */
#define _POSIX_AIO_LISTIO_MAX	2

/* Minimal number of outstanding asynchronous I/O operations.  */
#define _POSIX_AIO_MAX		1

/* Maximum length of arguments to `execve', including environment.  */
#define	_POSIX_ARG_MAX		4096

/* Maximum simultaneous processes per real user ID.  */

#define _POSIX_CHILD_MAX	25




/* Minimal number of timer expiration overruns.  */
#define _POSIX_DELAYTIMER_MAX	32

/* Maximum length of a host name (not including the terminating null)
   as returned from the GETHOSTNAME function.  */
#define _POSIX_HOST_NAME_MAX	255

/* Maximum link count of a file.  */
#define	_POSIX_LINK_MAX		8

/* Maximum length of login name.  */
#define	_POSIX_LOGIN_NAME_MAX	9

/* Number of bytes in a terminal canonical input queue.  */
#define	_POSIX_MAX_CANON	255

/* Number of bytes for which space will be
   available in a terminal input queue.  */
#define	_POSIX_MAX_INPUT	255

/* Maximum number of message queues open for a process.  */
#define _POSIX_MQ_OPEN_MAX	8

/* Maximum number of supported message priorities.  */
#define _POSIX_MQ_PRIO_MAX	32

/* Number of bytes in a filename.  */
#define	_POSIX_NAME_MAX		14

/* Number of simultaneous supplementary group IDs per process.  */

#define _POSIX_NGROUPS_MAX	8




/* Number of files one process can have open at once.  */

#define _POSIX_OPEN_MAX	20










/* Number of bytes in a pathname.  */
#define	_POSIX_PATH_MAX		256

/* Number of bytes than can be written atomically to a pipe.  */
#define	_POSIX_PIPE_BUF		512

/* The number of repeated occurrences of a BRE permitted by the
   REGEXEC and REGCOMP functions when using the interval notation.  */
#define _POSIX_RE_DUP_MAX	255

/* Minimal number of realtime signals reserved for the application.  */
#define _POSIX_RTSIG_MAX	8

/* Number of semaphores a process can have.  */
#define _POSIX_SEM_NSEMS_MAX	256

/* Maximal value of a semaphore.  */
#define _POSIX_SEM_VALUE_MAX	32767

/* Number of pending realtime signals.  */
#define _POSIX_SIGQUEUE_MAX	32

/* Largest value of a `ssize_t'.  */
#define	_POSIX_SSIZE_MAX	32767

/* Number of streams a process can have open at once.  */
#define	_POSIX_STREAM_MAX	8

/* The number of bytes in a symbolic link.  */
#define _POSIX_SYMLINK_MAX	255

/* The number of symbolic links that can be traversed in the
   resolution of a pathname in the absence of a loop.  */
#define _POSIX_SYMLOOP_MAX	8

/* Number of timer for a process.  */
#define _POSIX_TIMER_MAX	32

/* Maximum number of characters in a tty name.  */
#define	_POSIX_TTY_NAME_MAX	9

/* Maximum length of a timezone name (element of `tzname').  */
#define	_POSIX_TZNAME_MAX	6

# 150 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3


/* Maximum clock resolution in nanoseconds.  */
#define _POSIX_CLOCKRES_MIN	20000000


/* Get the implementation-specific values for the above.  */
#include <bits/local_lim.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3
/* Minimum guaranteed maximum values for system limits.  Linux version.
   Copyright (C) 1993-1998,2000,2002-2004,2008 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

/* The kernel header pollutes the namespace with the NR_OPEN symbol
   and defines LINK_MAX although filesystems have different maxima.  A
   similar thing is true for OPEN_MAX: the limit can be changed at
   runtime and therefore the macro must not be defined.  Remove this
   after including the header if necessary.  */

#define __undef_NR_OPEN


#define __undef_LINK_MAX


#define __undef_OPEN_MAX


#define __undef_ARG_MAX


/* The kernel sources contain a file with all the needed information.  */
#include <linux/limits.h>
# 1 "/usr/include/linux/limits.h" 1 3

#define _LINUX_LIMITS_H

#define NR_OPEN	        1024

#define NGROUPS_MAX    65536	/* supplemental group IDs are available */
#define ARG_MAX       131072	/* # bytes of args + environ for exec() */
#define LINK_MAX         127	/* # links a file may have */
#define MAX_CANON        255	/* size of the canonical input queue */
#define MAX_INPUT        255	/* size of the type-ahead buffer */
#define NAME_MAX         255	/* # chars in a file name */
#define PATH_MAX        4096	/* # chars in a path name including nul */
#define PIPE_BUF        4096	/* # bytes in atomic write to a pipe */
#define XATTR_NAME_MAX   255	/* # chars in an extended attribute name */
#define XATTR_SIZE_MAX 65536	/* size of an extended attribute value (64k) */
#define XATTR_LIST_MAX 65536	/* size of extended attribute namelist (64k) */

#define RTSIG_MAX	  32


# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3


/* Have to remove NR_OPEN?  */

#undef NR_OPEN
#undef __undef_NR_OPEN

/* Have to remove LINK_MAX?  */

#undef LINK_MAX
#undef __undef_LINK_MAX

/* Have to remove OPEN_MAX?  */

#undef OPEN_MAX
#undef __undef_OPEN_MAX

/* Have to remove ARG_MAX?  */

#undef ARG_MAX
#undef __undef_ARG_MAX


/* The number of data keys per process.  */
#define _POSIX_THREAD_KEYS_MAX	128
/* This is the value this implementation supports.  */
#define PTHREAD_KEYS_MAX	1024

/* Controlling the iterations of destructors for thread-specific data.  */
#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS	4
/* Number of iterations this implementation does.  */
#define PTHREAD_DESTRUCTOR_ITERATIONS	_POSIX_THREAD_DESTRUCTOR_ITERATIONS

/* The number of threads per process.  */
#define _POSIX_THREAD_THREADS_MAX	64
/* We have no predefined limit on the number of threads.  */
#undef PTHREAD_THREADS_MAX

/* Maximum amount by which a process can descrease its asynchronous I/O
   priority level.  */
#define AIO_PRIO_DELTA_MAX	20

/* Minimum size for a thread.  We are free to choose a reasonable value.  */
#define PTHREAD_STACK_MIN	16384

/* Maximum number of timer expiration overruns.  */
#define DELAYTIMER_MAX	2147483647

/* Maximum tty name length.  */
#define TTY_NAME_MAX		32

/* Maximum login name length.  This is arbitrary.  */
#define LOGIN_NAME_MAX		256

/* Maximum host name length.  */
#define HOST_NAME_MAX		64

/* Maximum message queue priority level.  */
#define MQ_PRIO_MAX		32768

/* Maximum value the semaphore can have.  */
#define SEM_VALUE_MAX   (2147483647)
# 157 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3




#define SSIZE_MAX	LONG_MAX



/* This value is a guaranteed minimum maximum.
   The current maximum can be got from `sysconf'.  */





/* bits/posix1_lim.h  */
# 145 "/usr/include/limits.h" 2 3




#include <bits/posix2_lim.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3
/* Copyright (C) 1991, 1996, 1999, 2000, 2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 * Never include this file directly; include <limits.h> instead.
 */


#define	_BITS_POSIX2_LIM_H	1


/* The maximum `ibase' and `obase' values allowed by the `bc' utility.  */
#define	_POSIX2_BC_BASE_MAX		99

/* The maximum number of elements allowed in an array by the `bc' utility.  */
#define	_POSIX2_BC_DIM_MAX		2048

/* The maximum `scale' value allowed by the `bc' utility.  */
#define	_POSIX2_BC_SCALE_MAX		99

/* The maximum length of a string constant accepted by the `bc' utility.  */
#define	_POSIX2_BC_STRING_MAX		1000

/* The maximum number of weights that can be assigned to an entry of
   the LC_COLLATE `order' keyword in the locale definition file.  */
#define	_POSIX2_COLL_WEIGHTS_MAX	2

/* The maximum number of expressions that can be nested
   within parentheses by the `expr' utility.  */
#define	_POSIX2_EXPR_NEST_MAX		32

/* The maximum length, in bytes, of an input line.  */
#define	_POSIX2_LINE_MAX		2048

/* The maximum number of repeated occurrences of a regular expression
   permitted when using the interval notation `\{M,N\}'.  */
#define	_POSIX2_RE_DUP_MAX		255

/* The maximum number of bytes in a character class name.  We have no
   fixed limit, 2048 is a high number.  */
#define	_POSIX2_CHARCLASS_NAME_MAX	14


/* These values are implementation-specific,
   and may vary within the implementation.
   Their precise values can be obtained from sysconf.  */


#define	BC_BASE_MAX		_POSIX2_BC_BASE_MAX


#define	BC_DIM_MAX		_POSIX2_BC_DIM_MAX


#define	BC_SCALE_MAX		_POSIX2_BC_SCALE_MAX


#define	BC_STRING_MAX		_POSIX2_BC_STRING_MAX


#define	COLL_WEIGHTS_MAX	255


#define	EXPR_NEST_MAX		_POSIX2_EXPR_NEST_MAX


#define	LINE_MAX		_POSIX2_LINE_MAX


#define	CHARCLASS_NAME_MAX	2048


/* This value is defined like this in regex.h.  */
#define	RE_DUP_MAX (0x7fff)

/* bits/posix2_lim.h */
# 149 "/usr/include/limits.h" 2 3






# 169 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include-fixed/limits.h" 2 3



/* not _GCC_LIMITS_H_ */
# 7 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include-fixed/syslimits.h" 2 3

#undef _GCC_NEXT_LIMITS_H
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include-fixed/limits.h" 2 3


/* Copyright (C) 1991, 1992, 1993, 1996, 1997, 1998, 1999, 2000, 2001,
   2002 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */


#define _LIMITS_H___

/* Number of bits in a `char'.  */
#undef CHAR_BIT
#define CHAR_BIT __CHAR_BIT__

/* Maximum length of a multibyte character.  */




/* Minimum and maximum values a `signed char' can hold.  */
#undef SCHAR_MIN
#define SCHAR_MIN (-SCHAR_MAX - 1)
#undef SCHAR_MAX
#define SCHAR_MAX __SCHAR_MAX__

/* Maximum value an `unsigned char' can hold.  (Minimum is 0).  */
#undef UCHAR_MAX



#define UCHAR_MAX (SCHAR_MAX * 2 + 1)


/* Minimum and maximum values a `char' can hold.  */
# 96 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include-fixed/limits.h" 3

#undef CHAR_MIN
#define CHAR_MIN SCHAR_MIN
#undef CHAR_MAX
#define CHAR_MAX SCHAR_MAX


/* Minimum and maximum values a `signed short int' can hold.  */
#undef SHRT_MIN
#define SHRT_MIN (-SHRT_MAX - 1)
#undef SHRT_MAX
#define SHRT_MAX __SHRT_MAX__

/* Maximum value an `unsigned short int' can hold.  (Minimum is 0).  */
#undef USHRT_MAX



#define USHRT_MAX (SHRT_MAX * 2 + 1)


/* Minimum and maximum values a `signed int' can hold.  */
#undef INT_MIN
#define INT_MIN (-INT_MAX - 1)
#undef INT_MAX
#define INT_MAX __INT_MAX__

/* Maximum value an `unsigned int' can hold.  (Minimum is 0).  */
#undef UINT_MAX
#define UINT_MAX (INT_MAX * 2U + 1U)

/* Minimum and maximum values a `signed long int' can hold.
   (Same as `int').  */
#undef LONG_MIN
#define LONG_MIN (-LONG_MAX - 1L)
#undef LONG_MAX
#define LONG_MAX __LONG_MAX__

/* Maximum value an `unsigned long int' can hold.  (Minimum is 0).  */
#undef ULONG_MAX
#define ULONG_MAX (LONG_MAX * 2UL + 1UL)

# 148 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include-fixed/limits.h" 3


# 160 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include-fixed/limits.h" 3


/* _LIMITS_H___ */
/* This administrivia gets added to the end of limits.h
   if the system has its own version of limits.h.  */

/* not _GCC_LIMITS_H_ *//* not _GCC_LIMITS_H_ */






# 63 "include/forms.h" 2













#define FL_EXPORT extern
/* FL_WIN32 */







/**
 * \file Basic.h
 *
 *  Basic definitions and limits.
 *  Window system independent prototypes
 *
 *  Modify with care
 */


#define FL_BASIC_H

#include <math.h>
# 1 "/usr/include/math.h" 1 3
/* Declarations for math functions.
   Copyright (C) 1991-1993, 1995-1999, 2001, 2002, 2004, 2006, 2009, 2011
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.12 Mathematics	<math.h>
 */


#define	_MATH_H	1

#include <features.h>

 

/* Get machine-dependent HUGE_VAL value (returned on overflow).
   On all IEEE754 machines, this is +Infinity.  */
#include <bits/huge_val.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/huge_val.h" 1 3
/* `HUGE_VAL' constant for IEEE 754 machines (where it is infinity).
   Used by <stdlib.h> and <math.h> functions for overflow.
   Copyright (C) 1992, 1995, 1996, 1997, 1999, 2000, 2004
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */





/* IEEE positive infinity (-HUGE_VAL is negative infinity).  */


#define HUGE_VAL	(__builtin_huge_val())
/* not GCC *//* GCC.  */
# 55 "/usr/include/x86_64-linux-gnu/bits/huge_val.h" 3

# 34 "/usr/include/math.h" 2 3


#include <bits/huge_valf.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/huge_valf.h" 1 3
/* `HUGE_VALF' constant for IEEE 754 machines (where it is infinity).
   Used by <stdlib.h> and <math.h> functions for overflow.
   Copyright (C) 1992, 1995, 1996, 1997, 1999, 2000, 2004
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */





/* IEEE positive infinity (-HUGE_VAL is negative infinity).  */


#define HUGE_VALF	(__builtin_huge_valf())
/* not GCC *//* GCC.  */
# 53 "/usr/include/x86_64-linux-gnu/bits/huge_valf.h" 3

# 36 "/usr/include/math.h" 2 3

#include <bits/huge_vall.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/huge_vall.h" 1 3
/* Default `HUGE_VALL' constant.
   Used by <stdlib.h> and <math.h> functions for overflow.
   Copyright (C) 1992, 1996, 1997, 2004 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */






#define HUGE_VALL	(__builtin_huge_vall())



# 37 "/usr/include/math.h" 2 3


/* Get machine-dependent INFINITY value.  */
#include <bits/inf.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/inf.h" 1 3
/* `INFINITY' constant for IEEE 754 machines.
   Copyright (C) 2004 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */





/* IEEE positive infinity.  */


#define INFINITY	(__builtin_inff())



# 40 "/usr/include/math.h" 2 3


/* Get machine-dependent NAN value (returned for some domain errors).  */
#include <bits/nan.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/nan.h" 1 3
/* `NAN' constant for IEEE 754 machines.
   Copyright (C) 1992,1996,1997,1999,2004,2006 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */






/* IEEE Not A Number.  */



#define NAN	(__builtin_nanf (""))

/* GCC.  */
# 53 "/usr/include/x86_64-linux-gnu/bits/nan.h" 3

# 43 "/usr/include/math.h" 2 3

/* __USE_ISOC99 */

/* Get general and ISO C99 specific information.  */
#include <bits/mathdef.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 1 3
/* Copyright (C) 2001, 2004, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */






#define _MATH_H_MATHDEF	1

#include <bits/wordsize.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3
/* Determine the wordsize from the preprocessor defines.  */


#define __WORDSIZE	64
#define __WORDSIZE_COMPAT32	1



# 26 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 2 3



/* The x86-64 architecture computes values with the precission of the
   used type.  Similarly for -m32 -mfpmath=sse.  */
typedef float float_t;		/* `float' expressions are evaluated as `float'.  */
typedef double double_t;	/* `double' expressions are evaluated
				   as `double'.  */
# 42 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 3


/* The values returned by `ilogb' for 0 and NaN respectively.  */
#define FP_ILOGB0	(-2147483647 - 1)
#define FP_ILOGBNAN	(-2147483647 - 1)

/* The GCC 4.6 compiler will define __FP_FAST_FMA{,F,L} if the fma{,f,l}
   builtins are supported.  */












/* ISO C99 */
# 47 "/usr/include/math.h" 2 3


/* The file <bits/mathcalls.h> contains the prototypes for all the
   actual math functions.  These macros are used for those prototypes,
   so we can easily declare each function as both `name' and `__name',
   and can declare the float versions `namef' and `__namef'.  */

#define __MATHCALL(function,suffix, args)	\
  __MATHDECL (_Mdouble_,function,suffix, args)
#define __MATHDECL(type, function,suffix, args) \
  __MATHDECL_1(type, function,suffix, args); \
  __MATHDECL_1(type, __CONCAT(__,function),suffix, args)
#define __MATHCALLX(function,suffix, args, attrib)	\
  __MATHDECLX (_Mdouble_,function,suffix, args, attrib)
#define __MATHDECLX(type, function,suffix, args, attrib) \
  __MATHDECL_1(type, function,suffix, args) __attribute__ (attrib); \
  __MATHDECL_1(type, __CONCAT(__,function),suffix, args) __attribute__ (attrib)
#define __MATHDECL_1(type, function,suffix, args) \
  extern type __MATH_PRECNAME(function,suffix) args __THROW

#define _Mdouble_		double
#define __MATH_PRECNAME(name,r)	__CONCAT(name,r)
#define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_STD
#define _Mdouble_END_NAMESPACE   __END_NAMESPACE_STD
#include <bits/mathcalls.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3
/* Prototype declarations for math functions; helper file for <math.h>.
   Copyright (C) 1996-2002, 2003, 2006, 2011 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/* NOTE: Because of the special way this file is used by <math.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME,[_r], (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME,[_r], (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.

   Note that there must be no whitespace before the argument passed for
   NAME, to make token pasting work with -traditional.  */






/* Trigonometric functions.  */

  
/* Arc cosine of X.  */
extern   double          acos          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __acos          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Arc sine of X.  */
extern   double          asin          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __asin          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Arc tangent of X.  */
extern   double          atan          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __atan          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Arc tangent of Y/X.  */
extern   double          atan2          (double  __y, double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __atan2          (double  __y, double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Cosine of X.  */
extern   double          cos          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __cos          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Sine of X.  */
extern   double          sin          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __sin          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Tangent of X.  */
extern   double          tan          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __tan          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Hyperbolic functions.  */

/* Hyperbolic cosine of X.  */
extern   double          cosh          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __cosh          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Hyperbolic sine of X.  */
extern   double          sinh          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __sinh          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Hyperbolic tangent of X.  */
extern   double          tanh          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __tanh          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
  








 
/* Hyperbolic arc cosine of X.  */
extern   double          acosh          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __acosh          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Hyperbolic arc sine of X.  */
extern   double          asinh          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __asinh          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Hyperbolic arc tangent of X.  */
extern   double          atanh          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __atanh          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 


/* Exponential and logarithmic functions.  */

  
/* Exponential function of X.  */
extern   double          exp          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __exp          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Break VALUE into a normalized fraction and an integral power of 2.  */
extern   double          frexp          (double  __x, int *__exponent)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __frexp          (double  __x, int *__exponent)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* X times (two to the EXP power).  */
extern   double          ldexp          (double  __x, int __exponent)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __ldexp          (double  __x, int __exponent)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Natural logarithm of X.  */
extern   double          log          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __log          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Base-ten logarithm of X.  */
extern   double          log10          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __log10          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Break VALUE into integral and fractional parts.  */
extern   double          modf          (double  __x, double  *__iptr)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __modf          (double  __x, double  *__iptr)    __attribute__ ((__nothrow__ , __leaf__ ))    
     __attribute__ ((__nonnull__ (2)));
  









 
/* Return exp(X) - 1.  */
extern   double          expm1          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __expm1          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Return log(1 + X).  */
extern   double          log1p          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __log1p          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Return the base 2 signed integral exponent of X.  */
extern   double          logb          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __logb          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 



 
/* Compute base-2 exponential of X.  */
extern   double          exp2          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __exp2          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Compute base-2 logarithm of X.  */
extern   double          log2          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __log2          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 



/* Power functions.  */

  
/* Return X to the Y power.  */
extern   double          pow          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __pow          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Return the square root of X.  */
extern   double          sqrt          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __sqrt          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
  


 
/* Return `sqrt(X*X + Y*Y)'.  */
extern   double          hypot          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __hypot          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 



 
/* Return the cube root of X.  */
extern   double          cbrt          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __cbrt          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 



/* Nearest integer, absolute value, and remainder functions.  */

  
/* Smallest integral value not less than X.  */
extern   double          ceil          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   double         __ceil          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;

/* Absolute value of X.  */
extern   double          fabs          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   double         __fabs          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;

/* Largest integer not greater than X.  */
extern   double          floor          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   double         __floor          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;

/* Floating-point modulo remainder of X/Y.  */
extern   double          fmod          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __fmod          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;


/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern  int     __isinf      (double  __value)  __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern  int     __finite      (double  __value)  __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__const__));
  


/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern  int     isinf      (double  __value)  __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern  int     finite      (double  __value)  __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__const__));

/* Return the remainder of X/Y.  */
extern   double          drem          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __drem          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;


/* Return the fractional part of X after dividing out `ilogb (X)'.  */
extern   double          significand          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __significand          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Use misc.  */


 
/* Return X with its signed changed to Y's.  */
extern   double          copysign          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   double         __copysign          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;
 



 
/* Return representation of NaN for double type.  */
extern   double          nan          (__const char *__tagb)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   double         __nan          (__const char *__tagb)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;
 



/* Return nonzero if VALUE is not a number.  */
extern  int     __isnan      (double  __value)  __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__const__));


/* Return nonzero if VALUE is not a number.  */
extern  int     isnan      (double  __value)  __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__const__));

/* Bessel functions.  */
extern   double          j0          (double )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __j0          (double )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   double          j1          (double )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __j1          (double )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   double          jn          (int, double )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __jn          (int, double )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   double          y0          (double )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __y0          (double )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   double          y1          (double )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __y1          (double )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   double          yn          (int, double )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __yn          (int, double )    __attribute__ ((__nothrow__ , __leaf__ ))    ;




 
/* Error and gamma functions.  */
extern   double          erf          (double )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __erf          (double )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   double          erfc          (double )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __erfc          (double )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   double          lgamma          (double )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __lgamma          (double )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 



 
/* True gamma function.  */
extern   double          tgamma          (double )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __tgamma          (double )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 



/* Obsolete alias for `lgamma'.  */
extern   double          gamma          (double )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __gamma          (double )    __attribute__ ((__nothrow__ , __leaf__ ))    ;



/* Reentrant version of lgamma.  This function uses the global variable
   `signgam'.  The reentrant version instead takes a pointer and stores
   the value through it.  */
extern   double          lgamma_r              (double , int *__signgamp)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __lgamma_r              (double , int *__signgamp)    __attribute__ ((__nothrow__ , __leaf__ ))    ;




 
/* Return the integer nearest X in the direction of the
   prevailing rounding mode.  */
extern   double          rint          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __rint          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
extern   double          nextafter          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   double         __nextafter          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;

extern   double          nexttoward          (double  __x, long double __y)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   double         __nexttoward          (double  __x, long double __y)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;


/* Return the remainder of integer divison X / Y with infinite precision.  */
extern   double          remainder          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __remainder          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;


/* Return X times (2 to the Nth power).  */
extern   double          scalbn          (double  __x, int __n)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __scalbn          (double  __x, int __n)    __attribute__ ((__nothrow__ , __leaf__ ))    ;


/* Return the binary exponent of X, which must be nonzero.  */
extern   int        ilogb        (double  __x)   __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   int        __ilogb        (double  __x)   __attribute__ ((__nothrow__ , __leaf__ ))   ;



/* Return X times (2 to the Nth power).  */
extern   double          scalbln          (double  __x, long int __n)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __scalbln          (double  __x, long int __n)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Round X to integral value in floating-point format using current
   rounding direction, but do not raise inexact exception.  */
extern   double          nearbyint          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __nearbyint          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern   double          round          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   double         __round          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;

/* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  */
extern   double          trunc          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   double         __trunc          (double  __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;

/* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  */
extern   double          remquo          (double  __x, double  __y, int *__quo)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __remquo          (double  __x, double  __y, int *__quo)    __attribute__ ((__nothrow__ , __leaf__ ))    ;


/* Conversion functions.  */

/* Round X to nearest integral value according to current rounding
   direction.  */
extern   long int        lrint        (double  __x)   __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long int        __lrint        (double  __x)   __attribute__ ((__nothrow__ , __leaf__ ))   ;
extern   long long int        llrint        (double  __x)   __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long long int        __llrint        (double  __x)   __attribute__ ((__nothrow__ , __leaf__ ))   ;

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern   long int        lround        (double  __x)   __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long int        __lround        (double  __x)   __attribute__ ((__nothrow__ , __leaf__ ))   ;
extern   long long int        llround        (double  __x)   __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long long int        __llround        (double  __x)   __attribute__ ((__nothrow__ , __leaf__ ))   ;


/* Return positive difference between X and Y.  */
extern   double          fdim          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __fdim          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Return maximum numeric value from X and Y.  */
extern   double          fmax          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __fmax          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Return minimum numeric value from X and Y.  */
extern   double          fmin          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __fmin          (double  __x, double  __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;


/* Classify given number.  */
extern  int      __fpclassify      (double  __value)  __attribute__ ((__nothrow__ , __leaf__ ))  
     __attribute__ ((__const__));

/* Test for negative number.  */
extern  int      __signbit      (double  __value)  __attribute__ ((__nothrow__ , __leaf__ ))  
     __attribute__ ((__const__));


/* Multiply-add function computed as a ternary operation.  */
extern   double          fma          (double  __x, double  __y, double  __z)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __fma          (double  __x, double  __y, double  __z)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Use ISO C99.  */


 



/* Return X times (2 to the Nth power).  */
extern   double          scalb          (double  __x, double  __n)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   double         __scalb          (double  __x, double  __n)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

# 71 "/usr/include/math.h" 2 3

#undef	_Mdouble_
#undef _Mdouble_BEGIN_NAMESPACE
#undef _Mdouble_END_NAMESPACE
#undef	__MATH_PRECNAME




/* Include the file of declarations again, this time using `float'
   instead of `double' and appending f to each function name.  */


#define _Mfloat_		float

#define _Mdouble_		_Mfloat_

#define __MATH_PRECNAME(name,r) name##f##r



#define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_C99
#define _Mdouble_END_NAMESPACE   __END_NAMESPACE_C99
#include <bits/mathcalls.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3
/* Prototype declarations for math functions; helper file for <math.h>.
   Copyright (C) 1996-2002, 2003, 2006, 2011 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/* NOTE: Because of the special way this file is used by <math.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME,[_r], (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME,[_r], (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.

   Note that there must be no whitespace before the argument passed for
   NAME, to make token pasting work with -traditional.  */






/* Trigonometric functions.  */

  
/* Arc cosine of X.  */
extern   float          acosf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __acosf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Arc sine of X.  */
extern   float          asinf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __asinf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Arc tangent of X.  */
extern   float          atanf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __atanf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Arc tangent of Y/X.  */
extern   float          atan2f         (float   __y, float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __atan2f         (float   __y, float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Cosine of X.  */
extern   float          cosf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __cosf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Sine of X.  */
extern   float          sinf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __sinf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Tangent of X.  */
extern   float          tanf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __tanf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Hyperbolic functions.  */

/* Hyperbolic cosine of X.  */
extern   float          coshf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __coshf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Hyperbolic sine of X.  */
extern   float          sinhf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __sinhf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Hyperbolic tangent of X.  */
extern   float          tanhf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __tanhf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
  








 
/* Hyperbolic arc cosine of X.  */
extern   float          acoshf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __acoshf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Hyperbolic arc sine of X.  */
extern   float          asinhf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __asinhf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Hyperbolic arc tangent of X.  */
extern   float          atanhf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __atanhf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 


/* Exponential and logarithmic functions.  */

  
/* Exponential function of X.  */
extern   float          expf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __expf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Break VALUE into a normalized fraction and an integral power of 2.  */
extern   float          frexpf         (float   __x, int *__exponent)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __frexpf         (float   __x, int *__exponent)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* X times (two to the EXP power).  */
extern   float          ldexpf         (float   __x, int __exponent)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __ldexpf         (float   __x, int __exponent)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Natural logarithm of X.  */
extern   float          logf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __logf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Base-ten logarithm of X.  */
extern   float          log10f         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __log10f         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Break VALUE into integral and fractional parts.  */
extern   float          modff         (float   __x, float   *__iptr)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __modff         (float   __x, float   *__iptr)    __attribute__ ((__nothrow__ , __leaf__ ))    
     __attribute__ ((__nonnull__ (2)));
  









 
/* Return exp(X) - 1.  */
extern   float          expm1f         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __expm1f         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Return log(1 + X).  */
extern   float          log1pf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __log1pf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Return the base 2 signed integral exponent of X.  */
extern   float          logbf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __logbf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 



 
/* Compute base-2 exponential of X.  */
extern   float          exp2f         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __exp2f         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Compute base-2 logarithm of X.  */
extern   float          log2f         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __log2f         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 



/* Power functions.  */

  
/* Return X to the Y power.  */
extern   float          powf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __powf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Return the square root of X.  */
extern   float          sqrtf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __sqrtf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
  


 
/* Return `sqrt(X*X + Y*Y)'.  */
extern   float          hypotf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __hypotf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 



 
/* Return the cube root of X.  */
extern   float          cbrtf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __cbrtf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 



/* Nearest integer, absolute value, and remainder functions.  */

  
/* Smallest integral value not less than X.  */
extern   float          ceilf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   float         __ceilf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;

/* Absolute value of X.  */
extern   float          fabsf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   float         __fabsf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;

/* Largest integer not greater than X.  */
extern   float          floorf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   float         __floorf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;

/* Floating-point modulo remainder of X/Y.  */
extern   float          fmodf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __fmodf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;


/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern  int    __isinff     (float   __value)  __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern  int    __finitef     (float   __value)  __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__const__));
  


/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern  int    isinff     (float   __value)  __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern  int    finitef     (float   __value)  __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__const__));

/* Return the remainder of X/Y.  */
extern   float          dremf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __dremf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;


/* Return the fractional part of X after dividing out `ilogb (X)'.  */
extern   float          significandf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __significandf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Use misc.  */


 
/* Return X with its signed changed to Y's.  */
extern   float          copysignf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   float         __copysignf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;
 



 
/* Return representation of NaN for double type.  */
extern   float          nanf         (__const char *__tagb)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   float         __nanf         (__const char *__tagb)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;
 



/* Return nonzero if VALUE is not a number.  */
extern  int    __isnanf     (float   __value)  __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__const__));


/* Return nonzero if VALUE is not a number.  */
extern  int    isnanf     (float   __value)  __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__const__));

/* Bessel functions.  */
extern   float          j0f         (float  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __j0f         (float  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   float          j1f         (float  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __j1f         (float  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   float          jnf         (int, float  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __jnf         (int, float  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   float          y0f         (float  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __y0f         (float  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   float          y1f         (float  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __y1f         (float  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   float          ynf         (int, float  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __ynf         (int, float  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;




 
/* Error and gamma functions.  */
extern   float          erff         (float  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __erff         (float  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   float          erfcf         (float  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __erfcf         (float  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   float          lgammaf         (float  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __lgammaf         (float  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 



 
/* True gamma function.  */
extern   float          tgammaf         (float  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __tgammaf         (float  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 



/* Obsolete alias for `lgamma'.  */
extern   float          gammaf         (float  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __gammaf         (float  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;



/* Reentrant version of lgamma.  This function uses the global variable
   `signgam'.  The reentrant version instead takes a pointer and stores
   the value through it.  */
extern   float          lgammaf_r            (float  , int *__signgamp)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __lgammaf_r            (float  , int *__signgamp)    __attribute__ ((__nothrow__ , __leaf__ ))    ;




 
/* Return the integer nearest X in the direction of the
   prevailing rounding mode.  */
extern   float          rintf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __rintf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
extern   float          nextafterf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   float         __nextafterf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;

extern   float          nexttowardf         (float   __x, long double __y)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   float         __nexttowardf         (float   __x, long double __y)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;


/* Return the remainder of integer divison X / Y with infinite precision.  */
extern   float          remainderf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __remainderf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;


/* Return X times (2 to the Nth power).  */
extern   float          scalbnf         (float   __x, int __n)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __scalbnf         (float   __x, int __n)    __attribute__ ((__nothrow__ , __leaf__ ))    ;


/* Return the binary exponent of X, which must be nonzero.  */
extern   int       ilogbf       (float   __x)   __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   int       __ilogbf       (float   __x)   __attribute__ ((__nothrow__ , __leaf__ ))   ;



/* Return X times (2 to the Nth power).  */
extern   float          scalblnf         (float   __x, long int __n)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __scalblnf         (float   __x, long int __n)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Round X to integral value in floating-point format using current
   rounding direction, but do not raise inexact exception.  */
extern   float          nearbyintf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __nearbyintf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern   float          roundf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   float         __roundf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;

/* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  */
extern   float          truncf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   float         __truncf         (float   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;

/* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  */
extern   float          remquof         (float   __x, float   __y, int *__quo)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __remquof         (float   __x, float   __y, int *__quo)    __attribute__ ((__nothrow__ , __leaf__ ))    ;


/* Conversion functions.  */

/* Round X to nearest integral value according to current rounding
   direction.  */
extern   long int       lrintf       (float   __x)   __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long int       __lrintf       (float   __x)   __attribute__ ((__nothrow__ , __leaf__ ))   ;
extern   long long int       llrintf       (float   __x)   __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long long int       __llrintf       (float   __x)   __attribute__ ((__nothrow__ , __leaf__ ))   ;

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern   long int       lroundf       (float   __x)   __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long int       __lroundf       (float   __x)   __attribute__ ((__nothrow__ , __leaf__ ))   ;
extern   long long int       llroundf       (float   __x)   __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long long int       __llroundf       (float   __x)   __attribute__ ((__nothrow__ , __leaf__ ))   ;


/* Return positive difference between X and Y.  */
extern   float          fdimf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __fdimf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Return maximum numeric value from X and Y.  */
extern   float          fmaxf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __fmaxf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Return minimum numeric value from X and Y.  */
extern   float          fminf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __fminf         (float   __x, float   __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;


/* Classify given number.  */
extern  int     __fpclassifyf     (float   __value)  __attribute__ ((__nothrow__ , __leaf__ ))  
     __attribute__ ((__const__));

/* Test for negative number.  */
extern  int     __signbitf     (float   __value)  __attribute__ ((__nothrow__ , __leaf__ ))  
     __attribute__ ((__const__));


/* Multiply-add function computed as a ternary operation.  */
extern   float          fmaf         (float   __x, float   __y, float   __z)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __fmaf         (float   __x, float   __y, float   __z)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Use ISO C99.  */


 



/* Return X times (2 to the Nth power).  */
extern   float          scalbf         (float   __x, float   __n)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   float         __scalbf         (float   __x, float   __n)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

# 94 "/usr/include/math.h" 2 3

#undef	_Mdouble_
#undef _Mdouble_BEGIN_NAMESPACE
#undef _Mdouble_END_NAMESPACE
#undef	__MATH_PRECNAME




# 119 "/usr/include/math.h" 3


# 129 "/usr/include/math.h" 3


/* Include the file of declarations again, this time using `long double'
   instead of `double' and appending l to each function name.  */


#define _Mlong_double_	long double

#define _Mdouble_		_Mlong_double_

#define __MATH_PRECNAME(name,r) name##l##r



#define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_C99
#define _Mdouble_END_NAMESPACE   __END_NAMESPACE_C99
#define __MATH_DECLARE_LDOUBLE   1
#include <bits/mathcalls.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3
/* Prototype declarations for math functions; helper file for <math.h>.
   Copyright (C) 1996-2002, 2003, 2006, 2011 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/* NOTE: Because of the special way this file is used by <math.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME,[_r], (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME,[_r], (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.

   Note that there must be no whitespace before the argument passed for
   NAME, to make token pasting work with -traditional.  */






/* Trigonometric functions.  */

  
/* Arc cosine of X.  */
extern   long double          acosl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __acosl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Arc sine of X.  */
extern   long double          asinl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __asinl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Arc tangent of X.  */
extern   long double          atanl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __atanl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Arc tangent of Y/X.  */
extern   long double          atan2l         (long double   __y, long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __atan2l         (long double   __y, long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Cosine of X.  */
extern   long double          cosl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __cosl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Sine of X.  */
extern   long double          sinl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __sinl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Tangent of X.  */
extern   long double          tanl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __tanl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Hyperbolic functions.  */

/* Hyperbolic cosine of X.  */
extern   long double          coshl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __coshl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Hyperbolic sine of X.  */
extern   long double          sinhl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __sinhl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Hyperbolic tangent of X.  */
extern   long double          tanhl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __tanhl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
  








 
/* Hyperbolic arc cosine of X.  */
extern   long double          acoshl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __acoshl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Hyperbolic arc sine of X.  */
extern   long double          asinhl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __asinhl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Hyperbolic arc tangent of X.  */
extern   long double          atanhl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __atanhl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 


/* Exponential and logarithmic functions.  */

  
/* Exponential function of X.  */
extern   long double          expl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __expl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Break VALUE into a normalized fraction and an integral power of 2.  */
extern   long double          frexpl         (long double   __x, int *__exponent)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __frexpl         (long double   __x, int *__exponent)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* X times (two to the EXP power).  */
extern   long double          ldexpl         (long double   __x, int __exponent)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __ldexpl         (long double   __x, int __exponent)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Natural logarithm of X.  */
extern   long double          logl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __logl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Base-ten logarithm of X.  */
extern   long double          log10l         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __log10l         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Break VALUE into integral and fractional parts.  */
extern   long double          modfl         (long double   __x, long double   *__iptr)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __modfl         (long double   __x, long double   *__iptr)    __attribute__ ((__nothrow__ , __leaf__ ))    
     __attribute__ ((__nonnull__ (2)));
  









 
/* Return exp(X) - 1.  */
extern   long double          expm1l         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __expm1l         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Return log(1 + X).  */
extern   long double          log1pl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __log1pl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Return the base 2 signed integral exponent of X.  */
extern   long double          logbl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __logbl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 



 
/* Compute base-2 exponential of X.  */
extern   long double          exp2l         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __exp2l         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Compute base-2 logarithm of X.  */
extern   long double          log2l         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __log2l         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 



/* Power functions.  */

  
/* Return X to the Y power.  */
extern   long double          powl         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __powl         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Return the square root of X.  */
extern   long double          sqrtl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __sqrtl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
  


 
/* Return `sqrt(X*X + Y*Y)'.  */
extern   long double          hypotl         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __hypotl         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 



 
/* Return the cube root of X.  */
extern   long double          cbrtl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __cbrtl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 



/* Nearest integer, absolute value, and remainder functions.  */

  
/* Smallest integral value not less than X.  */
extern   long double          ceill         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   long double         __ceill         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;

/* Absolute value of X.  */
extern   long double          fabsl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   long double         __fabsl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;

/* Largest integer not greater than X.  */
extern   long double          floorl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   long double         __floorl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;

/* Floating-point modulo remainder of X/Y.  */
extern   long double          fmodl         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __fmodl         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;


/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern  int    __isinfl     (long double   __value)  __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern  int    __finitel     (long double   __value)  __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__const__));
  


/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
extern  int    isinfl     (long double   __value)  __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
extern  int    finitel     (long double   __value)  __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__const__));

/* Return the remainder of X/Y.  */
extern   long double          dreml         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __dreml         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;


/* Return the fractional part of X after dividing out `ilogb (X)'.  */
extern   long double          significandl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __significandl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Use misc.  */


 
/* Return X with its signed changed to Y's.  */
extern   long double          copysignl         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   long double         __copysignl         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;
 



 
/* Return representation of NaN for double type.  */
extern   long double          nanl         (__const char *__tagb)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   long double         __nanl         (__const char *__tagb)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;
 



/* Return nonzero if VALUE is not a number.  */
extern  int    __isnanl     (long double   __value)  __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__const__));


/* Return nonzero if VALUE is not a number.  */
extern  int    isnanl     (long double   __value)  __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ ((__const__));

/* Bessel functions.  */
extern   long double          j0l         (long double  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __j0l         (long double  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   long double          j1l         (long double  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __j1l         (long double  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   long double          jnl         (int, long double  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __jnl         (int, long double  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   long double          y0l         (long double  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __y0l         (long double  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   long double          y1l         (long double  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __y1l         (long double  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   long double          ynl         (int, long double  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __ynl         (int, long double  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;




 
/* Error and gamma functions.  */
extern   long double          erfl         (long double  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __erfl         (long double  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   long double          erfcl         (long double  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __erfcl         (long double  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
extern   long double          lgammal         (long double  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __lgammal         (long double  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 



 
/* True gamma function.  */
extern   long double          tgammal         (long double  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __tgammal         (long double  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;
 



/* Obsolete alias for `lgamma'.  */
extern   long double          gammal         (long double  )    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __gammal         (long double  )    __attribute__ ((__nothrow__ , __leaf__ ))    ;



/* Reentrant version of lgamma.  This function uses the global variable
   `signgam'.  The reentrant version instead takes a pointer and stores
   the value through it.  */
extern   long double          lgammal_r            (long double  , int *__signgamp)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __lgammal_r            (long double  , int *__signgamp)    __attribute__ ((__nothrow__ , __leaf__ ))    ;




 
/* Return the integer nearest X in the direction of the
   prevailing rounding mode.  */
extern   long double          rintl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __rintl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
extern   long double          nextafterl         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   long double         __nextafterl         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;

extern   long double          nexttowardl         (long double   __x, long double __y)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   long double         __nexttowardl         (long double   __x, long double __y)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;


/* Return the remainder of integer divison X / Y with infinite precision.  */
extern   long double          remainderl         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __remainderl         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;


/* Return X times (2 to the Nth power).  */
extern   long double          scalbnl         (long double   __x, int __n)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __scalbnl         (long double   __x, int __n)    __attribute__ ((__nothrow__ , __leaf__ ))    ;


/* Return the binary exponent of X, which must be nonzero.  */
extern   int       ilogbl       (long double   __x)   __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   int       __ilogbl       (long double   __x)   __attribute__ ((__nothrow__ , __leaf__ ))   ;



/* Return X times (2 to the Nth power).  */
extern   long double          scalblnl         (long double   __x, long int __n)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __scalblnl         (long double   __x, long int __n)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Round X to integral value in floating-point format using current
   rounding direction, but do not raise inexact exception.  */
extern   long double          nearbyintl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __nearbyintl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern   long double          roundl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   long double         __roundl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;

/* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  */
extern   long double          truncl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  ); extern   long double         __truncl         (long double   __x)    __attribute__ ((__nothrow__ , __leaf__ ))   __attribute__ (    (__const__)  )  ;

/* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  */
extern   long double          remquol         (long double   __x, long double   __y, int *__quo)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __remquol         (long double   __x, long double   __y, int *__quo)    __attribute__ ((__nothrow__ , __leaf__ ))    ;


/* Conversion functions.  */

/* Round X to nearest integral value according to current rounding
   direction.  */
extern   long int       lrintl       (long double   __x)   __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long int       __lrintl       (long double   __x)   __attribute__ ((__nothrow__ , __leaf__ ))   ;
extern   long long int       llrintl       (long double   __x)   __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long long int       __llrintl       (long double   __x)   __attribute__ ((__nothrow__ , __leaf__ ))   ;

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
extern   long int       lroundl       (long double   __x)   __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long int       __lroundl       (long double   __x)   __attribute__ ((__nothrow__ , __leaf__ ))   ;
extern   long long int       llroundl       (long double   __x)   __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long long int       __llroundl       (long double   __x)   __attribute__ ((__nothrow__ , __leaf__ ))   ;


/* Return positive difference between X and Y.  */
extern   long double          fdiml         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __fdiml         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Return maximum numeric value from X and Y.  */
extern   long double          fmaxl         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __fmaxl         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

/* Return minimum numeric value from X and Y.  */
extern   long double          fminl         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __fminl         (long double   __x, long double   __y)    __attribute__ ((__nothrow__ , __leaf__ ))    ;


/* Classify given number.  */
extern  int     __fpclassifyl     (long double   __value)  __attribute__ ((__nothrow__ , __leaf__ ))  
     __attribute__ ((__const__));

/* Test for negative number.  */
extern  int     __signbitl     (long double   __value)  __attribute__ ((__nothrow__ , __leaf__ ))  
     __attribute__ ((__const__));


/* Multiply-add function computed as a ternary operation.  */
extern   long double          fmal         (long double   __x, long double   __y, long double   __z)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __fmal         (long double   __x, long double   __y, long double   __z)    __attribute__ ((__nothrow__ , __leaf__ ))    ;
/* Use ISO C99.  */


 



/* Return X times (2 to the Nth power).  */
extern   long double          scalbl         (long double   __x, long double   __n)    __attribute__ ((__nothrow__ , __leaf__ ))  ; extern   long double         __scalbl         (long double   __x, long double   __n)    __attribute__ ((__nothrow__ , __leaf__ ))    ;

# 146 "/usr/include/math.h" 2 3

#undef _Mdouble_
#undef _Mdouble_BEGIN_NAMESPACE
#undef _Mdouble_END_NAMESPACE
#undef __MATH_PRECNAME

/* __STDC__ || __GNUC__ */

/* Use misc or ISO C99.  */
#undef	__MATHDECL_1
#undef	__MATHDECL
#undef	__MATHCALL



/* This variable is used by `gamma' and `lgamma'.  */
extern int signgam;



/* ISO C99 defines some generic macros which work on any data type.  */


/* Get the architecture specific values describing the floating-point
   evaluation.  The following symbols will get defined:

    float_t	floating-point type at least as wide as `float' used
		to evaluate `float' expressions
    double_t	floating-point type at least as wide as `double' used
		to evaluate `double' expressions

    FLT_EVAL_METHOD
		Defined to
		  0	if `float_t' is `float' and `double_t' is `double'
		  1	if `float_t' and `double_t' are `double'
		  2	if `float_t' and `double_t' are `long double'
		  else	`float_t' and `double_t' are unspecified

    INFINITY	representation of the infinity value of type `float'

    FP_FAST_FMA
    FP_FAST_FMAF
    FP_FAST_FMAL
		If defined it indicates that the `fma' function
		generally executes about as fast as a multiply and an add.
		This macro is defined only iff the `fma' function is
		implemented directly with a hardware multiply-add instructions.

    FP_ILOGB0	Expands to a value returned by `ilogb (0.0)'.
    FP_ILOGBNAN	Expands to a value returned by `ilogb (NAN)'.

    DECIMAL_DIG	Number of decimal digits supported by conversion between
		decimal and all internal floating-point formats.

*/

/* All floating-point numbers can be put in one of these categories.  */
enum
  {
    FP_NAN,
#define FP_NAN FP_NAN
    FP_INFINITE,
#define FP_INFINITE FP_INFINITE
    FP_ZERO,
#define FP_ZERO FP_ZERO
    FP_SUBNORMAL,
#define FP_SUBNORMAL FP_SUBNORMAL
    FP_NORMAL
#define FP_NORMAL FP_NORMAL
  };

/* Return number of classification appropriate for X.  */




#define fpclassify(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __fpclassifyf (x)						      \
      : sizeof (x) == sizeof (double)					      \
      ? __fpclassify (x) : __fpclassifyl (x))


/* Return nonzero value if sign of X is negative.  */




#define signbit(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __signbitf (x)							      \
      : sizeof (x) == sizeof (double)					      \
      ? __signbit (x) : __signbitl (x))


/* Return nonzero value if X is not +-Inf or NaN.  */




#define isfinite(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __finitef (x)							      \
      : sizeof (x) == sizeof (double)					      \
      ? __finite (x) : __finitel (x))


/* Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.  */
#define isnormal(x) (fpclassify (x) == FP_NORMAL)

/* Return nonzero value if X is a NaN.  We could use `fpclassify' but
   we already have this functions `__isnan' and it is faster.  */




#define isnan(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __isnanf (x)							      \
      : sizeof (x) == sizeof (double)					      \
      ? __isnan (x) : __isnanl (x))


/* Return nonzero value if X is positive or negative infinity.  */




#define isinf(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __isinff (x)							      \
      : sizeof (x) == sizeof (double)					      \
      ? __isinf (x) : __isinfl (x))


/* Bitmasks for the math_errhandling macro.  */
#define MATH_ERRNO	1	/* errno set by math functions.  */
#define MATH_ERREXCEPT	2	/* Exceptions raised by math functions.  */

/* By default all functions support both errno and exception handling.
   In gcc's fast math mode and if inline functions are defined this
   might not be true.  */

#define math_errhandling	(MATH_ERRNO | MATH_ERREXCEPT)


/* Use ISO C99.  */


/* Support for various different standard error handling behaviors.  */
typedef enum
{
  _IEEE_ = -1,	/* According to IEEE 754/IEEE 854.  */
  _SVID_,	/* According to System V, release 4.  */
  _XOPEN_,	/* Nowadays also Unix98.  */
  _POSIX_,
  _ISOC_	/* Actually this is ISO C99.  */
} _LIB_VERSION_TYPE;

/* This variable can be changed at run-time to any of the values above to
   affect floating point error handling behavior (it may also be necessary
   to change the hardware FPU exception settings).  */
extern _LIB_VERSION_TYPE _LIB_VERSION;




/* In SVID error handling, `matherr' is called with this description
   of the exceptional condition.

   We have a problem when using C++ since `exception' is a reserved
   name in C++.  */



struct exception

  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };




extern int matherr (struct exception *__exc);


#define X_TLOSS	1.41484755040568800000e+16

/* Types of exceptions in the `type' field.  */
#define DOMAIN		1
#define SING		2
#define OVERFLOW	3
#define UNDERFLOW	4
#define TLOSS		5
#define PLOSS		6

/* SVID mode specifies returning this large value instead of infinity.  */
#define HUGE		3.40282347e+38F

/* !SVID *//* SVID */









/* Some useful constants.  */

#define M_E		2.7182818284590452354	/* e */
#define M_LOG2E	1.4426950408889634074	/* log_2 e */
#define M_LOG10E	0.43429448190325182765	/* log_10 e */
#define M_LN2		0.69314718055994530942	/* log_e 2 */
#define M_LN10		2.30258509299404568402	/* log_e 10 */
#define M_PI		3.14159265358979323846	/* pi */
#define M_PI_2		1.57079632679489661923	/* pi/2 */
#define M_PI_4		0.78539816339744830962	/* pi/4 */
#define M_1_PI		0.31830988618379067154	/* 1/pi */
#define M_2_PI		0.63661977236758134308	/* 2/pi */
#define M_2_SQRTPI	1.12837916709551257390	/* 2/sqrt(pi) */
#define M_SQRT2	1.41421356237309504880	/* sqrt(2) */
#define M_SQRT1_2	0.70710678118654752440	/* 1/sqrt(2) */


/* The above constants are not adequate for computation using `long double's.
   Therefore we provide as an extension constants with similar names as a
   GNU extension.  Provide enough digits for the 128-bit IEEE quad.  */
# 394 "/usr/include/math.h" 3



/* When compiling in strict ISO C compatible mode we must not use the
   inline functions since they, among other things, do not set the
   `errno' variable correctly.  */





/* ISO C99 defines some macros to compare number while taking care for
   unordered numbers.  Many FPUs provide special instructions to support
   these operations.  Generic support in GCC for these as builtins went
   in before 3.0.0, but not all cpus added their patterns.  We define
   versions that use the builtins here, and <bits/mathinline.h> will
   undef/redefine as appropriate for the specific GCC version in use.  */
#define isgreater(x, y)	__builtin_isgreater(x, y)
#define isgreaterequal(x, y)	__builtin_isgreaterequal(x, y)
#define isless(x, y)		__builtin_isless(x, y)
#define islessequal(x, y)	__builtin_islessequal(x, y)
#define islessgreater(x, y)	__builtin_islessgreater(x, y)
#define isunordered(u, v)	__builtin_isunordered(u, v)


/* Get machine-dependent inline versions (if there are any).  */




/* Define special entry points to use when the compiler got told to
   only expect finite results.  */





/* If we've still got undefined comparison macros, provide defaults.  */

/* Return nonzero value if X is greater than Y.  */







/* Return nonzero value if X is greater than or equal to Y.  */







/* Return nonzero value if X is less than Y.  */







/* Return nonzero value if X is less than or equal to Y.  */







/* Return nonzero value if either X is less than Y or Y is less than X.  */







/* Return nonzero value if arguments are unordered.  */









 


/* math.h  */
# 97 "include/forms.h" 2


#include <X11/Xlib.h>
# 1 "/usr/include/X11/Xlib.h" 1 3
/*

Copyright 1985, 1986, 1987, 1991, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

*/


/*
 *	Xlib.h - Header definition and support file for the C subroutine
 *	interface library (Xlib) to the X Window System Protocol (V11).
 *	Structures and symbols starting with "_" are private to the library.
 */

#define _X11_XLIB_H_

#define XlibSpecificationRelease 6

#include <sys/types.h>
# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3
/* Copyright (C) 1991,1992,1994-2002,2006,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 */


#define	_SYS_TYPES_H	1

#include <features.h>

 

#include <bits/types.h>



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;
#define __u_char_defined



typedef __loff_t loff_t;



typedef __ino_t ino_t;



#define __ino_t_defined







typedef __dev_t dev_t;
#define __dev_t_defined



typedef __gid_t gid_t;
#define __gid_t_defined



typedef __mode_t mode_t;
#define __mode_t_defined



typedef __nlink_t nlink_t;
#define __nlink_t_defined



typedef __uid_t uid_t;
#define __uid_t_defined
















typedef __pid_t pid_t;
#define __pid_t_defined




typedef __id_t id_t;
#define __id_t_defined









typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;
#define __daddr_t_defined




typedef __key_t key_t;
#define __key_t_defined



#define __need_clock_t

#define	__need_time_t
#define __need_timer_t
#define __need_clockid_t
#include <time.h>
# 1 "/usr/include/time.h" 1 3
/* Copyright (C) 1991-2003,2006,2009,2011 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */












/* <time.h> included.  */
# 51 "/usr/include/time.h" 3



#define __clock_t_defined	1

#include <bits/types.h>

 
/* Returned by `clock'.  */
typedef __clock_t clock_t;
 

 


/* clock_t not defined and <time.h> or need clock_t.  */
#undef	__need_clock_t


#define __time_t_defined	1

#include <bits/types.h>

 
/* Returned by `time'.  */
typedef __time_t time_t;
 

 


/* time_t not defined and <time.h> or need time_t.  */
#undef	__need_time_t



#define __clockid_t_defined	1

#include <bits/types.h>

/* Clock ID used in clock and timer functions.  */
typedef __clockid_t clockid_t;

/* clockid_t not defined and <time.h> or need clockid_t.  */
#undef	__clockid_time_t



#define __timer_t_defined	1

#include <bits/types.h>

/* Timer ID returned by `timer_create'.  */
typedef __timer_t timer_t;

/* timer_t not defined and <time.h> or need timer_t.  */
#undef	__need_timer_t


/* timespec not defined and <time.h> or need timespec.  */
# 126 "/usr/include/time.h" 3

#undef	__need_timespec


/* <time.h> included.  */
# 419 "/usr/include/time.h" 3


/* <time.h> not already included.  */
# 133 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3


# 144 "/usr/include/x86_64-linux-gnu/sys/types.h" 3


#define	__need_size_t
#include <stddef.h>
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004, 2009
   Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3



/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
/* defined(_ANSI_H_) || defined(_MACHINE_ANSI_H_) || defined(_X86_64_ANSI_H_) || defined(_I386_ANSI_H_) */
# 93 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */













/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* _STDDEF_H or __need_ptrdiff_t.  */
# 163 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* BeOS *//* __size_t__ */
# 233 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3

#undef	__need_size_t
/* _STDDEF_H or __need_size_t.  */


/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
/* _STDDEF_H or __need_wchar_t.  */
# 344 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


# 356 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
/* _ANSI_H_ || _MACHINE_ANSI_H_ || _X86_64_ANSI_H_ || _I386_ANSI_H_ */
# 390 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* __sys_stdtypes_h */

/* A null pointer constant.  */

/* NULL not defined and <stddef.h> or need NULL.  */
# 407 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3

#undef	__need_NULL

/* _STDDEF_H was defined this time */






/* !_STDDEF_H && !_STDDEF_H_ && !_ANSI_STDDEF_H && !__STDDEF_H__
	  || __need_XXX was not defined before */
# 147 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3



/* Old compatibility names for C types.  */
typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;


/* These size-specific names are used by some of the inet code.  */

# 185 "/usr/include/x86_64-linux-gnu/sys/types.h" 3


/* For GCC 2.7 and later, we can use specific type-size attributes.  */
#define __intN_t(N, MODE) \
  typedef int int##N##_t __attribute__ ((__mode__ (MODE)))
#define __u_intN_t(N, MODE) \
  typedef unsigned int u_int##N##_t __attribute__ ((__mode__ (MODE)))


#define __int8_t_defined
typedef int int8_t __attribute__ ((__mode__ (  __QI__ ))) ;
typedef int int16_t __attribute__ ((__mode__ (  __HI__ ))) ;
typedef int int32_t __attribute__ ((__mode__ (  __SI__ ))) ;
typedef int int64_t __attribute__ ((__mode__ (  __DI__ ))) ;


typedef unsigned int u_int8_t __attribute__ ((__mode__ (  __QI__ ))) ;
typedef unsigned int u_int16_t __attribute__ ((__mode__ (  __HI__ ))) ;
typedef unsigned int u_int32_t __attribute__ ((__mode__ (  __SI__ ))) ;
typedef unsigned int u_int64_t __attribute__ ((__mode__ (  __DI__ ))) ;

typedef int register_t __attribute__ ((__mode__ (__word__)));


/* Some code from BIND tests this macro to see if the types above are
   defined.  */

#define __BIT_TYPES_DEFINED__	1



/* In BSD <sys/types.h> is expected to define BYTE_ORDER.  */
#include <endian.h>

/* It also defines `fd_set' and the FD_* macros for `select'.  */
#include <sys/select.h>
# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3
/* `fd_set' type and related macros, and `select'/`pselect' declarations.
   Copyright (C) 1996-2003, 2009, 2011 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>  */


#define _SYS_SELECT_H	1

#include <features.h>

/* Get definition of needed basic types.  */
#include <bits/types.h>

/* Get __FD_* definitions.  */
#include <bits/select.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3
/* Copyright (C) 1997-1999,2001,2008,2009,2011 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */





#include <bits/wordsize.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3
/* Determine the wordsize from the preprocessor defines.  */


#define __WORDSIZE	64
#define __WORDSIZE_COMPAT32	1



# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3






#define __FD_ZERO_STOS "stosq"




#define __FD_ZERO(fdsp) \
  do {									      \
    int __d0, __d1;							      \
    __asm__ __volatile__ ("cld; rep; " __FD_ZERO_STOS			      \
			  : "=c" (__d0), "=D" (__d1)			      \
			  : "a" (0), "0" (sizeof (fd_set)		      \
					  / sizeof (__fd_mask)),	      \
			    "1" (&__FDS_BITS (fdsp)[0])			      \
			  : "memory");					      \
  } while (0)

/* ! GNU CC *//* GNU CC */
# 57 "/usr/include/x86_64-linux-gnu/bits/select.h" 3


#define __FD_SET(d, set) \
  ((void) (__FDS_BITS (set)[__FD_ELT (d)] |= __FD_MASK (d)))
#define __FD_CLR(d, set) \
  ((void) (__FDS_BITS (set)[__FD_ELT (d)] &= ~__FD_MASK (d)))
#define __FD_ISSET(d, set) \
  ((__FDS_BITS (set)[__FD_ELT (d)] & __FD_MASK (d)) != 0)
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3


/* Get __sigset_t.  */
#include <bits/sigset.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3
/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.
   Copyright (C) 1991, 1992, 1994, 1996, 1997, 2007
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */


#define _SIGSET_H_types	1

typedef int __sig_atomic_t;

/* A `sigset_t' has a bit for each signal.  */

#define _SIGSET_NWORDS	(1024 / (8 * sizeof (unsigned long int)))
typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int))) ];
  } __sigset_t;




/* We only want to define these functions if <signal.h> was actually
   included; otherwise we were included just to define the types.  Since we
   are namespace-clean, it wouldn't hurt to define extra macros.  But
   trouble can be caused by functions being defined (e.g., any global
   register vars declared later will cause compilation errors).  */

/* ! _SIGSET_H_fns.  */
# 126 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3

# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3



#define __sigset_t_defined
typedef __sigset_t sigset_t;


/* Get definition of timer specification structures.  */
#define __need_time_t
#define __need_timespec
#include <time.h>
# 1 "/usr/include/time.h" 1 3
/* Copyright (C) 1991-2003,2006,2009,2011 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */












/* <time.h> included.  */
# 51 "/usr/include/time.h" 3


/* clock_t not defined and <time.h> or need clock_t.  */
# 66 "/usr/include/time.h" 3

#undef	__need_clock_t

/* time_t not defined and <time.h> or need time_t.  */
# 82 "/usr/include/time.h" 3

#undef	__need_time_t

/* clockid_t not defined and <time.h> or need clockid_t.  */
# 94 "/usr/include/time.h" 3

#undef	__clockid_time_t

/* timer_t not defined and <time.h> or need timer_t.  */
# 106 "/usr/include/time.h" 3

#undef	__need_timer_t






#define __timespec_defined	1

#include <bits/types.h>	/* This defines __time_t for us.  */

/* POSIX.1b structure for a time value.  This is like a `struct timeval' but
   has nanoseconds instead of microseconds.  */
struct timespec
  {
    __time_t tv_sec;		/* Seconds.  */
    long int tv_nsec;		/* Nanoseconds.  */
  };

/* timespec not defined and <time.h> or need timespec.  */
#undef	__need_timespec


/* <time.h> included.  */
# 419 "/usr/include/time.h" 3


/* <time.h> not already included.  */
# 44 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3

#define __need_timeval
#include <bits/time.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3
/* System-dependent timing definitions.  Linux version.
   Copyright (C) 1996,1997,1999-2003,2010,2011 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 * Never include this file directly; use <time.h> instead.
 */



#define _STRUCT_TIMEVAL	1
#include <bits/types.h>

/* A time value that is accurate to the nearest
   microsecond but also has a range of years.  */
struct timeval
  {
    __time_t tv_sec;		/* Seconds.  */
    __suseconds_t tv_usec;	/* Microseconds.  */
  };
/* struct timeval */


# 97 "/usr/include/x86_64-linux-gnu/bits/time.h" 3


#undef __need_timeval
# 46 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3



typedef __suseconds_t suseconds_t;
#define __suseconds_t_defined



/* The fd_set member is required to be an array of longs.  */
typedef long int __fd_mask;

/* Some versions of <linux/posix_types.h> define this macros.  */
#undef	__NFDBITS
/* It's easier to assume 8-bit bytes than to get CHAR_BIT.  */
#define __NFDBITS	(8 * (int) sizeof (__fd_mask))
#define	__FD_ELT(d)	((d) / __NFDBITS)
#define	__FD_MASK(d)	((__fd_mask) 1 << ((d) % __NFDBITS))

/* fd_set for select and pselect.  */
typedef struct
  {
    /* XPG4.2 requires this member name.  Otherwise avoid the name
       from the global namespace.  */




    __fd_mask __fds_bits[1024  / (8 * (int) sizeof (__fd_mask)) ];
#define __FDS_BITS(set) ((set)->__fds_bits)

  } fd_set;

/* Maximum number of file descriptors in `fd_set'.  */
#define	FD_SETSIZE		__FD_SETSIZE


/* Sometimes the fd_set member is assumed to have this type.  */
typedef __fd_mask fd_mask;

/* Number of bits per word of `fd_set' (some code assumes this is 32).  */
#define NFDBITS		__NFDBITS



/* Access macros for `fd_set'.  */
#define	FD_SET(fd, fdsetp)	__FD_SET (fd, fdsetp)
#define	FD_CLR(fd, fdsetp)	__FD_CLR (fd, fdsetp)
#define	FD_ISSET(fd, fdsetp)	__FD_ISSET (fd, fdsetp)
#define	FD_ZERO(fdsetp)		__FD_ZERO (fdsetp)


 

/* Check the first NFDS descriptors each in READFDS (if not NULL) for read
   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out
   after waiting the interval specified therein.  Returns the number of ready
   descriptors, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int select (int __nfds, fd_set *__restrict __readfds,
		   fd_set *__restrict __writefds,
		   fd_set *__restrict __exceptfds,
		   struct timeval *__restrict __timeout);


/* Same as above only that the TIMEOUT value is given with higher
   resolution and a sigmask which is been set temporarily.  This version
   should be used.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pselect (int __nfds, fd_set *__restrict __readfds,
		    fd_set *__restrict __writefds,
		    fd_set *__restrict __exceptfds,
		    const struct timespec *__restrict __timeout,
		    const __sigset_t *__restrict __sigmask);



/* Define some inlines helping to catch common problems.  */




 

/* sys/select.h */
# 220 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3


/* BSD defines these symbols, so we follow.  */
#include <sys/sysmacros.h>
# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3
/* Definitions of macros to access `dev_t' values.
   Copyright (C) 1996, 1997, 1999, 2003, 2004, 2007, 2011
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */


#define _SYS_SYSMACROS_H	1

#include <features.h>

/* If the compiler does not know long long it is out of luck.  We are
   not going to hack weird hacks to support the dev_t representation
   they need.  */

 

__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__const__)) ;
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__const__)) ;
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
					       unsigned int __minor)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__const__)) ;

# 63 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3

 

/* Access the functions with their traditional names.  */
#define major(dev) gnu_dev_major (dev)
#define minor(dev) gnu_dev_minor (dev)
#define makedev(maj, min) gnu_dev_makedev (maj, min)


/* sys/sysmacros.h */
# 223 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3

/* Use BSD.  */




typedef __blksize_t blksize_t;
#define __blksize_t_defined


/* Types from the Large File Support interface.  */


typedef __blkcnt_t blkcnt_t;	 /* Type to count number of disk blocks.  */
#define __blkcnt_t_defined


typedef __fsblkcnt_t fsblkcnt_t; /* Type to count file system blocks.  */
#define __fsblkcnt_t_defined


typedef __fsfilcnt_t fsfilcnt_t; /* Type to count file system inodes.  */
#define __fsfilcnt_t_defined

# 260 "/usr/include/x86_64-linux-gnu/sys/types.h" 3









/* Now add the thread types.  */

#include <bits/pthreadtypes.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3
/* Copyright (C) 2002,2003,2004,2005,2006,2007 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */


#define _BITS_PTHREADTYPES_H	1

#include <bits/wordsize.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3
/* Determine the wordsize from the preprocessor defines.  */


#define __WORDSIZE	64
#define __WORDSIZE_COMPAT32	1



# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3



#define __SIZEOF_PTHREAD_ATTR_T 56
#define __SIZEOF_PTHREAD_MUTEX_T 40
#define __SIZEOF_PTHREAD_MUTEXATTR_T 4
#define __SIZEOF_PTHREAD_COND_T 48
#define __SIZEOF_PTHREAD_CONDATTR_T 4
#define __SIZEOF_PTHREAD_RWLOCK_T 56
#define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
#define __SIZEOF_PTHREAD_BARRIER_T 32
#define __SIZEOF_PTHREAD_BARRIERATTR_T 4
# 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3



/* Thread identifiers.  The structure of the attribute type is not
   exposed on purpose.  */
typedef unsigned long int pthread_t;


typedef union
{
  char __size[56 ];
  long int __align;
} pthread_attr_t;



typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;








/* Data structures for mutex handling.  The structure of the attribute
   type is not exposed on purpose.  */
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;

    /* KIND must stay at this position in the structure to maintain
       binary compatibility.  */
    int __kind;

    int __spins;
    __pthread_list_t __list;
#define __PTHREAD_MUTEX_HAVE_PREV	1








  } __data;
  char __size[40 ];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4 ];
  int __align;
} pthread_mutexattr_t;


/* Data structure for conditional variable handling.  The structure of
   the attribute type is not exposed on purpose.  */
typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48 ];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4 ];
  int __align;
} pthread_condattr_t;


/* Keys for thread-specific data */
typedef unsigned int pthread_key_t;


/* Once-only execution */
typedef int pthread_once_t;



/* Data structure for read-write lock variable handling.  The
   structure of the attribute type is not exposed on purpose.  */
typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;
    /* FLAGS must stay at this position in the structure to maintain
       binary compatibility.  */
    unsigned int __flags;
  } __data;
# 186 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3

  char __size[56 ];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8 ];
  long int __align;
} pthread_rwlockattr_t;




/* POSIX spinlock data type.  */
typedef volatile int pthread_spinlock_t;


/* POSIX barriers data type.  The structure of the type is
   deliberately not exposed.  */
typedef union
{
  char __size[32 ];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4 ];
  int __align;
} pthread_barrierattr_t;








/* bits/pthreadtypes.h */
# 271 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3



 

/* sys/types.h */
# 38 "/usr/include/X11/Xlib.h" 2 3






#include <X11/X.h>
# 1 "/usr/include/X11/X.h" 1 3
/* Definitions for the X window system likely to be used by applications */


#define X_H

/***********************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.


Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

#define X_PROTOCOL	11		/* current protocol version */
#define X_PROTOCOL_REVISION 0		/* current minor version */

/* Resources */

/*
 * _XSERVER64 must ONLY be defined when compiling X server sources on
 * systems where unsigned long is not 32 bits, must NOT be used in
 * client or library code.
 */


#define _XTYPEDEF_XID
typedef unsigned long XID;


#define _XTYPEDEF_MASK
typedef unsigned long Mask;


#define _XTYPEDEF_ATOM
typedef unsigned long Atom;		/* Also in Xdefs.h */

typedef unsigned long VisualID;
typedef unsigned long Time;
# 94 "/usr/include/X11/X.h" 3


typedef XID Window;
typedef XID Drawable;

#define _XTYPEDEF_FONT
typedef XID Font;

typedef XID Pixmap;
typedef XID Cursor;
typedef XID Colormap;
typedef XID GContext;
typedef XID KeySym;

typedef unsigned char KeyCode;

/*****************************************************************
 * RESERVED RESOURCE AND CONSTANT DEFINITIONS
 *****************************************************************/


#define None                 0L	/* universal null resource or null atom */


#define ParentRelative       1L	/* background pixmap in CreateWindow
				    and ChangeWindowAttributes */

#define CopyFromParent       0L	/* border pixmap in CreateWindow
				       and ChangeWindowAttributes
				   special VisualID and special window
				       class passed to CreateWindow */

#define PointerWindow        0L	/* destination window in SendEvent */
#define InputFocus           1L	/* destination window in SendEvent */

#define PointerRoot          1L	/* focus window in SetInputFocus */

#define AnyPropertyType      0L	/* special Atom, passed to GetProperty */

#define AnyKey		     0L	/* special Key Code, passed to GrabKey */

#define AnyButton            0L	/* special Button Code, passed to GrabButton */

#define AllTemporary         0L	/* special Resource ID passed to KillClient */

#define CurrentTime          0L	/* special Time */

#define NoSymbol	     0L	/* special KeySym */

/***************************************************************** 
 * EVENT DEFINITIONS 
 *****************************************************************/

/* Input Event Masks. Used as event-mask window attribute and as arguments
   to Grab requests.  Not to be confused with event names.  */

#define NoEventMask			0L
#define KeyPressMask			(1L<<0)  
#define KeyReleaseMask			(1L<<1)  
#define ButtonPressMask			(1L<<2)  
#define ButtonReleaseMask		(1L<<3)  
#define EnterWindowMask			(1L<<4)  
#define LeaveWindowMask			(1L<<5)  
#define PointerMotionMask		(1L<<6)  
#define PointerMotionHintMask		(1L<<7)  
#define Button1MotionMask		(1L<<8)  
#define Button2MotionMask		(1L<<9)  
#define Button3MotionMask		(1L<<10) 
#define Button4MotionMask		(1L<<11) 
#define Button5MotionMask		(1L<<12) 
#define ButtonMotionMask		(1L<<13) 
#define KeymapStateMask			(1L<<14)
#define ExposureMask			(1L<<15) 
#define VisibilityChangeMask		(1L<<16) 
#define StructureNotifyMask		(1L<<17) 
#define ResizeRedirectMask		(1L<<18) 
#define SubstructureNotifyMask		(1L<<19) 
#define SubstructureRedirectMask	(1L<<20) 
#define FocusChangeMask			(1L<<21) 
#define PropertyChangeMask		(1L<<22) 
#define ColormapChangeMask		(1L<<23) 
#define OwnerGrabButtonMask		(1L<<24) 

/* Event names.  Used in "type" field in XEvent structures.  Not to be
confused with event masks above.  They start from 2 because 0 and 1
are reserved in the protocol for errors and replies. */

#define KeyPress		2
#define KeyRelease		3
#define ButtonPress		4
#define ButtonRelease		5
#define MotionNotify		6
#define EnterNotify		7
#define LeaveNotify		8
#define FocusIn			9
#define FocusOut		10
#define KeymapNotify		11
#define Expose			12
#define GraphicsExpose		13
#define NoExpose		14
#define VisibilityNotify	15
#define CreateNotify		16
#define DestroyNotify		17
#define UnmapNotify		18
#define MapNotify		19
#define MapRequest		20
#define ReparentNotify		21
#define ConfigureNotify		22
#define ConfigureRequest	23
#define GravityNotify		24
#define ResizeRequest		25
#define CirculateNotify		26
#define CirculateRequest	27
#define PropertyNotify		28
#define SelectionClear		29
#define SelectionRequest	30
#define SelectionNotify		31
#define ColormapNotify		32
#define ClientMessage		33
#define MappingNotify		34
#define GenericEvent		35
#define LASTEvent		36	/* must be bigger than any event # */


/* Key masks. Used as modifiers to GrabButton and GrabKey, results of QueryPointer,
   state in various key-, mouse-, and button-related events. */

#define ShiftMask		(1<<0)
#define LockMask		(1<<1)
#define ControlMask		(1<<2)
#define Mod1Mask		(1<<3)
#define Mod2Mask		(1<<4)
#define Mod3Mask		(1<<5)
#define Mod4Mask		(1<<6)
#define Mod5Mask		(1<<7)

/* modifier names.  Used to build a SetModifierMapping request or
   to read a GetModifierMapping request.  These correspond to the
   masks defined above. */
#define ShiftMapIndex		0
#define LockMapIndex		1
#define ControlMapIndex		2
#define Mod1MapIndex		3
#define Mod2MapIndex		4
#define Mod3MapIndex		5
#define Mod4MapIndex		6
#define Mod5MapIndex		7


/* button masks.  Used in same manner as Key masks above. Not to be confused
   with button names below. */

#define Button1Mask		(1<<8)
#define Button2Mask		(1<<9)
#define Button3Mask		(1<<10)
#define Button4Mask		(1<<11)
#define Button5Mask		(1<<12)

#define AnyModifier		(1<<15)  /* used in GrabButton, GrabKey */


/* button names. Used as arguments to GrabButton and as detail in ButtonPress
   and ButtonRelease events.  Not to be confused with button masks above.
   Note that 0 is already defined above as "AnyButton".  */

#define Button1			1
#define Button2			2
#define Button3			3
#define Button4			4
#define Button5			5

/* Notify modes */

#define NotifyNormal		0
#define NotifyGrab		1
#define NotifyUngrab		2
#define NotifyWhileGrabbed	3

#define NotifyHint		1	/* for MotionNotify events */
		       
/* Notify detail */

#define NotifyAncestor		0
#define NotifyVirtual		1
#define NotifyInferior		2
#define NotifyNonlinear		3
#define NotifyNonlinearVirtual	4
#define NotifyPointer		5
#define NotifyPointerRoot	6
#define NotifyDetailNone	7

/* Visibility notify */

#define VisibilityUnobscured		0
#define VisibilityPartiallyObscured	1
#define VisibilityFullyObscured		2

/* Circulation request */

#define PlaceOnTop		0
#define PlaceOnBottom		1

/* protocol families */

#define FamilyInternet		0	/* IPv4 */
#define FamilyDECnet		1
#define FamilyChaos		2
#define FamilyInternet6		6	/* IPv6 */

/* authentication families not tied to a specific protocol */
#define FamilyServerInterpreted 5

/* Property notification */

#define PropertyNewValue	0
#define PropertyDelete		1

/* Color Map notification */

#define ColormapUninstalled	0
#define ColormapInstalled	1

/* GrabPointer, GrabButton, GrabKeyboard, GrabKey Modes */

#define GrabModeSync		0
#define GrabModeAsync		1

/* GrabPointer, GrabKeyboard reply status */

#define GrabSuccess		0
#define AlreadyGrabbed		1
#define GrabInvalidTime		2
#define GrabNotViewable		3
#define GrabFrozen		4

/* AllowEvents modes */

#define AsyncPointer		0
#define SyncPointer		1
#define ReplayPointer		2
#define AsyncKeyboard		3
#define SyncKeyboard		4
#define ReplayKeyboard		5
#define AsyncBoth		6
#define SyncBoth		7

/* Used in SetInputFocus, GetInputFocus */

#define RevertToNone		(int)None
#define RevertToPointerRoot	(int)PointerRoot
#define RevertToParent		2

/*****************************************************************
 * ERROR CODES 
 *****************************************************************/

#define Success		   0	/* everything's okay */
#define BadRequest	   1	/* bad request code */
#define BadValue	   2	/* int parameter out of range */
#define BadWindow	   3	/* parameter not a Window */
#define BadPixmap	   4	/* parameter not a Pixmap */
#define BadAtom		   5	/* parameter not an Atom */
#define BadCursor	   6	/* parameter not a Cursor */
#define BadFont		   7	/* parameter not a Font */
#define BadMatch	   8	/* parameter mismatch */
#define BadDrawable	   9	/* parameter not a Pixmap or Window */
#define BadAccess	  10	/* depending on context:
				 - key/button already grabbed
				 - attempt to free an illegal 
				   cmap entry 
				- attempt to store into a read-only 
				   color map entry.
 				- attempt to modify the access control
				   list from other than the local host.
				*/
#define BadAlloc	  11	/* insufficient resources */
#define BadColor	  12	/* no such colormap */
#define BadGC		  13	/* parameter not a GC */
#define BadIDChoice	  14	/* choice not in range or already used */
#define BadName		  15	/* font or color name doesn't exist */
#define BadLength	  16	/* Request length incorrect */
#define BadImplementation 17	/* server is defective */

#define FirstExtensionError	128
#define LastExtensionError	255

/*****************************************************************
 * WINDOW DEFINITIONS 
 *****************************************************************/

/* Window classes used by CreateWindow */
/* Note that CopyFromParent is already defined as 0 above */

#define InputOutput		1
#define InputOnly		2

/* Window attributes for CreateWindow and ChangeWindowAttributes */

#define CWBackPixmap		(1L<<0)
#define CWBackPixel		(1L<<1)
#define CWBorderPixmap		(1L<<2)
#define CWBorderPixel           (1L<<3)
#define CWBitGravity		(1L<<4)
#define CWWinGravity		(1L<<5)
#define CWBackingStore          (1L<<6)
#define CWBackingPlanes	        (1L<<7)
#define CWBackingPixel	        (1L<<8)
#define CWOverrideRedirect	(1L<<9)
#define CWSaveUnder		(1L<<10)
#define CWEventMask		(1L<<11)
#define CWDontPropagate	        (1L<<12)
#define CWColormap		(1L<<13)
#define CWCursor	        (1L<<14)

/* ConfigureWindow structure */

#define CWX			(1<<0)
#define CWY			(1<<1)
#define CWWidth			(1<<2)
#define CWHeight		(1<<3)
#define CWBorderWidth		(1<<4)
#define CWSibling		(1<<5)
#define CWStackMode		(1<<6)


/* Bit Gravity */

#define ForgetGravity		0
#define NorthWestGravity	1
#define NorthGravity		2
#define NorthEastGravity	3
#define WestGravity		4
#define CenterGravity		5
#define EastGravity		6
#define SouthWestGravity	7
#define SouthGravity		8
#define SouthEastGravity	9
#define StaticGravity		10

/* Window gravity + bit gravity above */

#define UnmapGravity		0

/* Used in CreateWindow for backing-store hint */

#define NotUseful               0
#define WhenMapped              1
#define Always                  2

/* Used in GetWindowAttributes reply */

#define IsUnmapped		0
#define IsUnviewable		1
#define IsViewable		2

/* Used in ChangeSaveSet */

#define SetModeInsert           0
#define SetModeDelete           1

/* Used in ChangeCloseDownMode */

#define DestroyAll              0
#define RetainPermanent         1
#define RetainTemporary         2

/* Window stacking method (in configureWindow) */

#define Above                   0
#define Below                   1
#define TopIf                   2
#define BottomIf                3
#define Opposite                4

/* Circulation direction */

#define RaiseLowest             0
#define LowerHighest            1

/* Property modes */

#define PropModeReplace         0
#define PropModePrepend         1
#define PropModeAppend          2

/*****************************************************************
 * GRAPHICS DEFINITIONS
 *****************************************************************/

/* graphics functions, as in GC.alu */

#define	GXclear			0x0		/* 0 */
#define GXand			0x1		/* src AND dst */
#define GXandReverse		0x2		/* src AND NOT dst */
#define GXcopy			0x3		/* src */
#define GXandInverted		0x4		/* NOT src AND dst */
#define	GXnoop			0x5		/* dst */
#define GXxor			0x6		/* src XOR dst */
#define GXor			0x7		/* src OR dst */
#define GXnor			0x8		/* NOT src AND NOT dst */
#define GXequiv			0x9		/* NOT src XOR dst */
#define GXinvert		0xa		/* NOT dst */
#define GXorReverse		0xb		/* src OR NOT dst */
#define GXcopyInverted		0xc		/* NOT src */
#define GXorInverted		0xd		/* NOT src OR dst */
#define GXnand			0xe		/* NOT src OR NOT dst */
#define GXset			0xf		/* 1 */

/* LineStyle */

#define LineSolid		0
#define LineOnOffDash		1
#define LineDoubleDash		2

/* capStyle */

#define CapNotLast		0
#define CapButt			1
#define CapRound		2
#define CapProjecting		3

/* joinStyle */

#define JoinMiter		0
#define JoinRound		1
#define JoinBevel		2

/* fillStyle */

#define FillSolid		0
#define FillTiled		1
#define FillStippled		2
#define FillOpaqueStippled	3

/* fillRule */

#define EvenOddRule		0
#define WindingRule		1

/* subwindow mode */

#define ClipByChildren		0
#define IncludeInferiors	1

/* SetClipRectangles ordering */

#define Unsorted		0
#define YSorted			1
#define YXSorted		2
#define YXBanded		3

/* CoordinateMode for drawing routines */

#define CoordModeOrigin		0	/* relative to the origin */
#define CoordModePrevious       1	/* relative to previous point */

/* Polygon shapes */

#define Complex			0	/* paths may intersect */
#define Nonconvex		1	/* no paths intersect, but not convex */
#define Convex			2	/* wholly convex */

/* Arc modes for PolyFillArc */

#define ArcChord		0	/* join endpoints of arc */
#define ArcPieSlice		1	/* join endpoints to center of arc */

/* GC components: masks used in CreateGC, CopyGC, ChangeGC, OR'ed into
   GC.stateChanges */

#define GCFunction              (1L<<0)
#define GCPlaneMask             (1L<<1)
#define GCForeground            (1L<<2)
#define GCBackground            (1L<<3)
#define GCLineWidth             (1L<<4)
#define GCLineStyle             (1L<<5)
#define GCCapStyle              (1L<<6)
#define GCJoinStyle		(1L<<7)
#define GCFillStyle		(1L<<8)
#define GCFillRule		(1L<<9) 
#define GCTile			(1L<<10)
#define GCStipple		(1L<<11)
#define GCTileStipXOrigin	(1L<<12)
#define GCTileStipYOrigin	(1L<<13)
#define GCFont 			(1L<<14)
#define GCSubwindowMode		(1L<<15)
#define GCGraphicsExposures     (1L<<16)
#define GCClipXOrigin		(1L<<17)
#define GCClipYOrigin		(1L<<18)
#define GCClipMask		(1L<<19)
#define GCDashOffset		(1L<<20)
#define GCDashList		(1L<<21)
#define GCArcMode		(1L<<22)

#define GCLastBit		22
/*****************************************************************
 * FONTS 
 *****************************************************************/

/* used in QueryFont -- draw direction */

#define FontLeftToRight		0
#define FontRightToLeft		1

#define FontChange		255

/*****************************************************************
 *  IMAGING 
 *****************************************************************/

/* ImageFormat -- PutImage, GetImage */

#define XYBitmap		0	/* depth 1, XYFormat */
#define XYPixmap		1	/* depth == drawable depth */
#define ZPixmap			2	/* depth == drawable depth */

/*****************************************************************
 *  COLOR MAP STUFF 
 *****************************************************************/

/* For CreateColormap */

#define AllocNone		0	/* create map with no entries */
#define AllocAll		1	/* allocate entire map writeable */


/* Flags used in StoreNamedColor, StoreColors */

#define DoRed			(1<<0)
#define DoGreen			(1<<1)
#define DoBlue			(1<<2)

/*****************************************************************
 * CURSOR STUFF
 *****************************************************************/

/* QueryBestSize Class */

#define CursorShape		0	/* largest size that can be displayed */
#define TileShape		1	/* size tiled fastest */
#define StippleShape		2	/* size stippled fastest */

/***************************************************************** 
 * KEYBOARD/POINTER STUFF
 *****************************************************************/

#define AutoRepeatModeOff	0
#define AutoRepeatModeOn	1
#define AutoRepeatModeDefault	2

#define LedModeOff		0
#define LedModeOn		1

/* masks for ChangeKeyboardControl */

#define KBKeyClickPercent	(1L<<0)
#define KBBellPercent		(1L<<1)
#define KBBellPitch		(1L<<2)
#define KBBellDuration		(1L<<3)
#define KBLed			(1L<<4)
#define KBLedMode		(1L<<5)
#define KBKey			(1L<<6)
#define KBAutoRepeatMode	(1L<<7)

#define MappingSuccess     	0
#define MappingBusy        	1
#define MappingFailed		2

#define MappingModifier		0
#define MappingKeyboard		1
#define MappingPointer		2

/*****************************************************************
 * SCREEN SAVER STUFF 
 *****************************************************************/

#define DontPreferBlanking	0
#define PreferBlanking		1
#define DefaultBlanking		2

#define DisableScreenSaver	0
#define DisableScreenInterval	0

#define DontAllowExposures	0
#define AllowExposures		1
#define DefaultExposures	2

/* for ForceScreenSaver */

#define ScreenSaverReset 0
#define ScreenSaverActive 1

/*****************************************************************
 * HOSTS AND CONNECTIONS
 *****************************************************************/

/* for ChangeHosts */

#define HostInsert		0
#define HostDelete		1

/* for ChangeAccessControl */

#define EnableAccess		1      
#define DisableAccess		0

/* Display classes  used in opening the connection 
 * Note that the statically allocated ones are even numbered and the
 * dynamically changeable ones are odd numbered */

#define StaticGray		0
#define GrayScale		1
#define StaticColor		2
#define PseudoColor		3
#define TrueColor		4
#define DirectColor		5


/* Byte order  used in imageByteOrder and bitmapBitOrder */

#define LSBFirst		0
#define MSBFirst		1

/* X_H */
# 44 "/usr/include/X11/Xlib.h" 2 3


/* applications should not depend on these two headers being included! */
#include <X11/Xfuncproto.h>
# 1 "/usr/include/X11/Xfuncproto.h" 1 3
/* Xfuncproto.h.  Generated from Xfuncproto.h.in by configure.  */
/*
 *
Copyright 1989, 1991, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.
 *
 */

/* Definitions to make function prototypes manageable */


#define _XFUNCPROTO_H_


#define NeedFunctionPrototypes 1
/* NeedFunctionPrototypes */


#define NeedVarargsPrototypes 1
/* NeedVarargsPrototypes */




#define NeedNestedPrototypes 1
/* NeedNestedPrototypes */


#define _Xconst const
/* _Xconst */

/* Function prototype configuration (see configure for more info) */

#define NARROWPROTO /**/


#define FUNCPROTO 15




#define NeedWidePrototypes 0



/* NeedWidePrototypes */

/* NeedFunctionPrototypes */


/* for C++ V2.0 */



#define _XFUNCPROTOBEGIN
#define _XFUNCPROTOEND

/* _XFUNCPROTOBEGIN */

/* Added in X11R6.9, so available in any version of modular xproto */

#define _X_SENTINEL(x) __attribute__ ((__sentinel__(x)))
/* GNUC >= 4 */



/* Added in X11R6.9, so available in any version of modular xproto */

#define _X_EXPORT      __attribute__((visibility("default")))
#define _X_HIDDEN      __attribute__((visibility("hidden")))
#define _X_INTERNAL    __attribute__((visibility("internal")))
/* not gcc >= 4 and not Sun Studio >= 8 *//* GNUC >= 4 */
# 99 "/usr/include/X11/Xfuncproto.h" 3


/* requires xproto >= 7.0.9 */

#define _X_LIKELY(x)   __builtin_expect(!!(x), 1)
#define _X_UNLIKELY(x) __builtin_expect(!!(x), 0)
/* not gcc >= 3.3 */




/* Added in X11R6.9, so available in any version of modular xproto */

#define _X_DEPRECATED  __attribute__((deprecated))
/* not gcc >= 3.1 */



/* requires xproto >= 7.0.17 */


#define _X_NORETURN __attribute((noreturn))
/* GNUC  */



/* Added in X11R6.9, so available in any version of modular xproto */

#define _X_ATTRIBUTE_PRINTF(x,y) __attribute__((__format__(__printf__,x,y)))
/* not gcc >= 2.3 */



/* requires xproto >= 7.0.22 */

#define _X_NONNULL(args...)  __attribute__((nonnull(args)))




/* requires xproto >= 7.0.22 */

#define _X_UNUSED  __attribute__((__unused__))




/* C99 keyword "inline" or equivalent extensions in pre-C99 compilers */
/* requires xproto >= 7.0.9
   (introduced in 7.0.8 but didn't support all compilers until 7.0.9) */
/* assume autoconf set it correctly *//* C99 *//* gcc w/C89+extensions */




#define _X_INLINE __inline__




/* C99 keyword "restrict" or equivalent extensions in pre-C99 compilers */
/* requires xproto >= 7.0.21 */

/* assume autoconf set it correctly *//* C99 *//* gcc w/C89+extensions */



#define _X_RESTRICT_KYWD __restrict__





/* _XFUNCPROTO_H_ */
# 47 "/usr/include/X11/Xlib.h" 2 3

#include <X11/Xosdefs.h>
# 1 "/usr/include/X11/Xosdefs.h" 1 3
/*
 * O/S-dependent (mis)feature macro definitions
 *
Copyright 1991, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.
 */


#define _XOSDEFS_H_

/*
 * X_NOT_POSIX means does not have POSIX header files.  Lack of this
 * symbol does NOT mean that the POSIX environment is the default.
 * You may still have to define _POSIX_SOURCE to get it.
 */








# 52 "/usr/include/X11/Xosdefs.h" 3


# 65 "/usr/include/X11/Xosdefs.h" 3









# 88 "/usr/include/X11/Xosdefs.h" 3



























/* _XOSDEFS_H_ */

# 48 "/usr/include/X11/Xlib.h" 2 3



#include <stddef.h>
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004, 2009
   Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */



#define _STDDEF_H
#define _STDDEF_H_
/* snaroff@next.com says the NeXT needs this.  */
#define _ANSI_STDDEF_H
/* Irix 5.1 needs this.  */
#define __STDDEF_H__



/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
/* defined(_ANSI_H_) || defined(_MACHINE_ANSI_H_) || defined(_X86_64_ANSI_H_) || defined(_I386_ANSI_H_) */
# 93 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */













/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* in case <sys/types.h> has defined it. */







#define _PTRDIFF_T
#define _T_PTRDIFF_
#define _T_PTRDIFF
#define __PTRDIFF_T
#define _PTRDIFF_T_
#define _BSD_PTRDIFF_T_
#define ___int_ptrdiff_t_h
#define _GCC_PTRDIFF_T



typedef long int  ptrdiff_t;
/* _GCC_PTRDIFF_T */
/* ___int_ptrdiff_t_h */
/* _BSD_PTRDIFF_T_ */
/* _PTRDIFF_T_ */
/* __PTRDIFF_T */
/* _T_PTRDIFF */
/* _T_PTRDIFF_ */
/* _PTRDIFF_T */

/* If this symbol has done its job, get rid of it.  */
#undef	__need_ptrdiff_t

/* _STDDEF_H or __need_ptrdiff_t.  */

/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* BeOS *//* __size_t__ */
# 233 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3

#undef	__need_size_t
/* _STDDEF_H or __need_size_t.  */


/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* BeOS */
/* Cray Unicos/Mk */






/* Darwin */
/* Darwin */
/* FreeBSD 5 */






#define __wchar_t__	/* BeOS */
#define __WCHAR_T__	/* Cray Unicos/Mk */
#define _WCHAR_T
#define _T_WCHAR_
#define _T_WCHAR
#define __WCHAR_T
#define _WCHAR_T_
#define _BSD_WCHAR_T_
#define _WCHAR_T_DEFINED_
#define _WCHAR_T_DEFINED
#define _WCHAR_T_H
#define ___int_wchar_t_h
#define __INT_WCHAR_T_H
#define _GCC_WCHAR_T
#define _WCHAR_T_DECLARED

/* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_, and _BSD_RUNE_T_ (which, unlike the other
   symbols in the _FOO_T_ family, stays defined even after its
   corresponding type is defined).  If we define wchar_t, then we
   must undef _WCHAR_T_; for BSD/386 1.1 (and perhaps others), if
   we undef _WCHAR_T_, then we must also define rune_t, since 
   headers like runetype.h assume that if machine/ansi.h is included,
   and _BSD_WCHAR_T_ is not defined, then rune_t is available.
   machine/ansi.h says, "Note that _WCHAR_T_ and _RUNE_T_ must be of
   the same type." */

#undef _BSD_WCHAR_T_
# 304 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* FreeBSD 5 can't be handled well using "traditional" logic above
   since it no longer defines _BSD_RUNE_T_ yet still desires to export
   rune_t in some cases... */
# 318 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3






typedef int  wchar_t;







/* _WCHAR_T_DECLARED */
/* _BSD_RUNE_T_DEFINED_ */







/* __WCHAR_T__ */
/* __wchar_t__ */
#undef	__need_wchar_t
/* _STDDEF_H or __need_wchar_t.  */

# 356 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
/* _ANSI_H_ || _MACHINE_ANSI_H_ || _X86_64_ANSI_H_ || _I386_ANSI_H_ */
# 390 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* __sys_stdtypes_h */

/* A null pointer constant.  */


#undef NULL		/* in case <stdio.h> has defined it. */
/* G++ */



#define NULL ((void *)0)
/* C++ *//* C++ */


/* G++ */
/* NULL not defined and <stddef.h> or need NULL.  */
#undef	__need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)

/* _STDDEF_H was defined this time */

/* !_STDDEF_H && !_STDDEF_H_ && !_ANSI_STDDEF_H && !__STDDEF_H__
	  || __need_XXX was not defined before */
# 51 "/usr/include/X11/Xlib.h" 2 3


















extern int
_Xmblen(




    char *str,
    int len

    );

/* API mentioning "UTF8" or "utf8" is an XFree86 extension, introduced in
   November 2000. Its presence is indicated through the following macro. */
#define X_HAVE_UTF8_STRING 1

typedef char *XPointer;

#define Bool int
#define Status int
#define True 1
#define False 0

#define QueuedAlready 0
#define QueuedAfterReading 1
#define QueuedAfterFlush 2

#define ConnectionNumber(dpy) 	(((_XPrivDisplay)dpy)->fd)
#define RootWindow(dpy, scr) 	(ScreenOfDisplay(dpy,scr)->root)
#define DefaultScreen(dpy) 	(((_XPrivDisplay)dpy)->default_screen)
#define DefaultRootWindow(dpy) 	(ScreenOfDisplay(dpy,DefaultScreen(dpy))->root)
#define DefaultVisual(dpy, scr) (ScreenOfDisplay(dpy,scr)->root_visual)
#define DefaultGC(dpy, scr) 	(ScreenOfDisplay(dpy,scr)->default_gc)
#define BlackPixel(dpy, scr) 	(ScreenOfDisplay(dpy,scr)->black_pixel)
#define WhitePixel(dpy, scr) 	(ScreenOfDisplay(dpy,scr)->white_pixel)
#define AllPlanes 		((unsigned long)~0L)
#define QLength(dpy) 		(((_XPrivDisplay)dpy)->qlen)
#define DisplayWidth(dpy, scr) 	(ScreenOfDisplay(dpy,scr)->width)
#define DisplayHeight(dpy, scr) (ScreenOfDisplay(dpy,scr)->height)
#define DisplayWidthMM(dpy, scr)(ScreenOfDisplay(dpy,scr)->mwidth)
#define DisplayHeightMM(dpy, scr)(ScreenOfDisplay(dpy,scr)->mheight)
#define DisplayPlanes(dpy, scr) (ScreenOfDisplay(dpy,scr)->root_depth)
#define DisplayCells(dpy, scr) 	(DefaultVisual(dpy,scr)->map_entries)
#define ScreenCount(dpy) 	(((_XPrivDisplay)dpy)->nscreens)
#define ServerVendor(dpy) 	(((_XPrivDisplay)dpy)->vendor)
#define ProtocolVersion(dpy) 	(((_XPrivDisplay)dpy)->proto_major_version)
#define ProtocolRevision(dpy) 	(((_XPrivDisplay)dpy)->proto_minor_version)
#define VendorRelease(dpy) 	(((_XPrivDisplay)dpy)->release)
#define DisplayString(dpy) 	(((_XPrivDisplay)dpy)->display_name)
#define DefaultDepth(dpy, scr) 	(ScreenOfDisplay(dpy,scr)->root_depth)
#define DefaultColormap(dpy, scr)(ScreenOfDisplay(dpy,scr)->cmap)
#define BitmapUnit(dpy) 	(((_XPrivDisplay)dpy)->bitmap_unit)
#define BitmapBitOrder(dpy) 	(((_XPrivDisplay)dpy)->bitmap_bit_order)
#define BitmapPad(dpy) 		(((_XPrivDisplay)dpy)->bitmap_pad)
#define ImageByteOrder(dpy) 	(((_XPrivDisplay)dpy)->byte_order)
/* unable to get WORD64 without pulling in other symbols */


#define NextRequest(dpy)	(((_XPrivDisplay)dpy)->request + 1)

#define LastKnownRequestProcessed(dpy)	(((_XPrivDisplay)dpy)->last_request_read)

/* macros for screen oriented applications (toolkit) */
#define ScreenOfDisplay(dpy, scr)(&((_XPrivDisplay)dpy)->screens[scr])
#define DefaultScreenOfDisplay(dpy) ScreenOfDisplay(dpy,DefaultScreen(dpy))
#define DisplayOfScreen(s)	((s)->display)
#define RootWindowOfScreen(s)	((s)->root)
#define BlackPixelOfScreen(s)	((s)->black_pixel)
#define WhitePixelOfScreen(s)	((s)->white_pixel)
#define DefaultColormapOfScreen(s)((s)->cmap)
#define DefaultDepthOfScreen(s)	((s)->root_depth)
#define DefaultGCOfScreen(s)	((s)->default_gc)
#define DefaultVisualOfScreen(s)((s)->root_visual)
#define WidthOfScreen(s)	((s)->width)
#define HeightOfScreen(s)	((s)->height)
#define WidthMMOfScreen(s)	((s)->mwidth)
#define HeightMMOfScreen(s)	((s)->mheight)
#define PlanesOfScreen(s)	((s)->root_depth)
#define CellsOfScreen(s)	(DefaultVisualOfScreen((s))->map_entries)
#define MinCmapsOfScreen(s)	((s)->min_maps)
#define MaxCmapsOfScreen(s)	((s)->max_maps)
#define DoesSaveUnders(s)	((s)->save_unders)
#define DoesBackingStore(s)	((s)->backing_store)
#define EventMaskOfScreen(s)	((s)->root_input_mask)

/*
 * Extensions need a way to hang private data on some structures.
 */
typedef struct _XExtData {
	int number;		/* number returned by XRegisterExtension */
	struct _XExtData *next;	/* next item on list of data for structure */
	int (*free_private)(	/* called to free private storage */
	struct _XExtData *extension
	);
	XPointer private_data;	/* data private to this extension. */
} XExtData;

/*
 * This file contains structures used by the extension mechanism.
 */
typedef struct {		/* public to extension, cannot be changed */
	int extension;		/* extension number */
	int major_opcode;	/* major op-code assigned by server */
	int first_event;	/* first event number for the extension */
	int first_error;	/* first error number for the extension */
} XExtCodes;

/*
 * Data structure for retrieving info about pixmap formats.
 */

typedef struct {
    int depth;
    int bits_per_pixel;
    int scanline_pad;
} XPixmapFormatValues;


/*
 * Data structure for setting graphics context.
 */
typedef struct {
	int function;		/* logical operation */
	unsigned long plane_mask;/* plane mask */
	unsigned long foreground;/* foreground pixel */
	unsigned long background;/* background pixel */
	int line_width;		/* line width */
	int line_style;	 	/* LineSolid, LineOnOffDash, LineDoubleDash */
	int cap_style;	  	/* CapNotLast, CapButt,
				   CapRound, CapProjecting */
	int join_style;	 	/* JoinMiter, JoinRound, JoinBevel */
	int fill_style;	 	/* FillSolid, FillTiled,
				   FillStippled, FillOpaeueStippled */
	int fill_rule;	  	/* EvenOddRule, WindingRule */
	int arc_mode;		/* ArcChord, ArcPieSlice */
	Pixmap tile;		/* tile pixmap for tiling operations */
	Pixmap stipple;		/* stipple 1 plane pixmap for stipping */
	int ts_x_origin;	/* offset for tile or stipple operations */
	int ts_y_origin;
        Font font;	        /* default text font for text operations */
	int subwindow_mode;     /* ClipByChildren, IncludeInferiors */
	int  graphics_exposures;/* boolean, should exposures be generated */
	int clip_x_origin;	/* origin for clipping */
	int clip_y_origin;
	Pixmap clip_mask;	/* bitmap clipping; other calls for rects */
	int dash_offset;	/* patterned/dashed line information */
	char dashes;
} XGCValues;

/*
 * Graphics context.  The contents of this structure are implementation
 * dependent.  A GC should be treated as opaque by application code.
 */

typedef struct _XGC







*GC;

/*
 * Visual structure; contains information about colormapping possible.
 */
typedef struct {
	XExtData *ext_data;	/* hook for extension to hang data */
	VisualID visualid;	/* visual id of this visual */



	int class;		/* class of screen (monochrome, etc.) */

	unsigned long red_mask, green_mask, blue_mask;	/* mask values */
	int bits_per_rgb;	/* log base 2 of distinct color values */
	int map_entries;	/* color map entries */
} Visual;

/*
 * Depth structure; contains information for each possible depth.
 */
typedef struct {
	int depth;		/* this depth (Z) of the depth */
	int nvisuals;		/* number of Visual types at this depth */
	Visual *visuals;	/* list of visuals possible at this depth */
} Depth;

/*
 * Information about the screen.  The contents of this structure are
 * implementation dependent.  A Screen should be treated as opaque
 * by application code.
 */

struct _XDisplay;		/* Forward declare before use for C++ */

typedef struct {
	XExtData *ext_data;	/* hook for extension to hang data */
	struct _XDisplay *display;/* back pointer to display structure */
	Window root;		/* Root window id. */
	int width, height;	/* width and height of screen */
	int mwidth, mheight;	/* width and height of  in millimeters */
	int ndepths;		/* number of depths possible */
	Depth *depths;		/* list of allowable depths on the screen */
	int root_depth;		/* bits per pixel */
	Visual *root_visual;	/* root visual */
	GC default_gc;		/* GC for the root root visual */
	Colormap cmap;		/* default color map */
	unsigned long white_pixel;
	unsigned long black_pixel;	/* White and Black pixel values */
	int max_maps, min_maps;	/* max and min color maps */
	int backing_store;	/* Never, WhenMapped, Always */
	int  save_unders;
	long root_input_mask;	/* initial root input mask */
} Screen;

/*
 * Format structure; describes ZFormat data the screen will understand.
 */
typedef struct {
	XExtData *ext_data;	/* hook for extension to hang data */
	int depth;		/* depth of this image format */
	int bits_per_pixel;	/* bits/pixel at this depth */
	int scanline_pad;	/* scanline must padded to this multiple */
} ScreenFormat;

/*
 * Data structure for setting window attributes.
 */
typedef struct {
    Pixmap background_pixmap;	/* background or None or ParentRelative */
    unsigned long background_pixel;	/* background pixel */
    Pixmap border_pixmap;	/* border of the window */
    unsigned long border_pixel;	/* border pixel value */
    int bit_gravity;		/* one of bit gravity values */
    int win_gravity;		/* one of the window gravity values */
    int backing_store;		/* NotUseful, WhenMapped, Always */
    unsigned long backing_planes;/* planes to be preseved if possible */
    unsigned long backing_pixel;/* value to use in restoring planes */
    int  save_under;		/* should bits under be saved? (popups) */
    long event_mask;		/* set of events that should be saved */
    long do_not_propagate_mask;	/* set of events that should not propagate */
    int  override_redirect;	/* boolean value for override-redirect */
    Colormap colormap;		/* color map to be associated with window */
    Cursor cursor;		/* cursor to be displayed (or None) */
} XSetWindowAttributes;

typedef struct {
    int x, y;			/* location of window */
    int width, height;		/* width and height of window */
    int border_width;		/* border width of window */
    int depth;          	/* depth of window */
    Visual *visual;		/* the associated visual structure */
    Window root;        	/* root of screen containing window */



    int class;			/* InputOutput, InputOnly*/

    int bit_gravity;		/* one of bit gravity values */
    int win_gravity;		/* one of the window gravity values */
    int backing_store;		/* NotUseful, WhenMapped, Always */
    unsigned long backing_planes;/* planes to be preserved if possible */
    unsigned long backing_pixel;/* value to be used when restoring planes */
    int  save_under;		/* boolean, should bits under be saved? */
    Colormap colormap;		/* color map to be associated with window */
    int  map_installed;		/* boolean, is color map currently installed*/
    int map_state;		/* IsUnmapped, IsUnviewable, IsViewable */
    long all_event_masks;	/* set of events all people have interest in*/
    long your_event_mask;	/* my event mask */
    long do_not_propagate_mask; /* set of events that should not propagate */
    int  override_redirect;	/* boolean value for override-redirect */
    Screen *screen;		/* back pointer to correct screen */
} XWindowAttributes;

/*
 * Data structure for host setting; getting routines.
 *
 */

typedef struct {
	int family;		/* for example FamilyInternet */
	int length;		/* length of address, in bytes */
	char *address;		/* pointer to where to find the bytes */
} XHostAddress;

/*
 * Data structure for ServerFamilyInterpreted addresses in host routines
 */
typedef struct {
	int typelength;		/* length of type string, in bytes */
	int valuelength;	/* length of value string, in bytes */
	char *type;		/* pointer to where to find the type string */
	char *value;		/* pointer to where to find the address */
} XServerInterpretedAddress;

/*
 * Data structure for "image" data, used by image manipulation routines.
 */
typedef struct _XImage {
    int width, height;		/* size of image */
    int xoffset;		/* number of pixels offset in X direction */
    int format;			/* XYBitmap, XYPixmap, ZPixmap */
    char *data;			/* pointer to image data */
    int byte_order;		/* data byte order, LSBFirst, MSBFirst */
    int bitmap_unit;		/* quant. of scanline 8, 16, 32 */
    int bitmap_bit_order;	/* LSBFirst, MSBFirst */
    int bitmap_pad;		/* 8, 16, 32 either XY or ZPixmap */
    int depth;			/* depth of image */
    int bytes_per_line;		/* accelarator to next line */
    int bits_per_pixel;		/* bits per pixel (ZPixmap) */
    unsigned long red_mask;	/* bits in z arrangment */
    unsigned long green_mask;
    unsigned long blue_mask;
    XPointer obdata;		/* hook for the object routines to hang on */
    struct funcs {		/* image manipulation routines */
	struct _XImage *(*create_image)(
		struct _XDisplay* /* display */,
		Visual*		/* visual */,
		unsigned int	/* depth */,
		int		/* format */,
		int		/* offset */,
		char*		/* data */,
		unsigned int	/* width */,
		unsigned int	/* height */,
		int		/* bitmap_pad */,
		int		/* bytes_per_line */);
	int (*destroy_image)        (struct _XImage *);
	unsigned long (*get_pixel)  (struct _XImage *, int, int);
	int (*put_pixel)            (struct _XImage *, int, int, unsigned long);
	struct _XImage *(*sub_image)(struct _XImage *, int, int, unsigned int, unsigned int);
	int (*add_pixel)            (struct _XImage *, long);
	} f;
} XImage;

/*
 * Data structure for XReconfigureWindow
 */
typedef struct {
    int x, y;
    int width, height;
    int border_width;
    Window sibling;
    int stack_mode;
} XWindowChanges;

/*
 * Data structure used by color operations
 */
typedef struct {
	unsigned long pixel;
	unsigned short red, green, blue;
	char flags;  /* do_red, do_green, do_blue */
	char pad;
} XColor;

/*
 * Data structures for graphics operations.  On most machines, these are
 * congruent with the wire protocol structures, so reformatting the data
 * can be avoided on these architectures.
 */
typedef struct {
    short x1, y1, x2, y2;
} XSegment;

typedef struct {
    short x, y;
} XPoint;

typedef struct {
    short x, y;
    unsigned short width, height;
} XRectangle;

typedef struct {
    short x, y;
    unsigned short width, height;
    short angle1, angle2;
} XArc;


/* Data structure for XChangeKeyboardControl */

typedef struct {
        int key_click_percent;
        int bell_percent;
        int bell_pitch;
        int bell_duration;
        int led;
        int led_mode;
        int key;
        int auto_repeat_mode;   /* On, Off, Default */
} XKeyboardControl;

/* Data structure for XGetKeyboardControl */

typedef struct {
        int key_click_percent;
	int bell_percent;
	unsigned int bell_pitch, bell_duration;
	unsigned long led_mask;
	int global_auto_repeat;
	char auto_repeats[32];
} XKeyboardState;

/* Data structure for XGetMotionEvents.  */

typedef struct {
        Time time;
	short x, y;
} XTimeCoord;

/* Data structure for X{Set,Get}ModifierMapping */

typedef struct {
 	int max_keypermod;	/* The server's max # of keys per modifier */
 	KeyCode *modifiermap;	/* An 8 by max_keypermod array of modifiers */
} XModifierKeymap;


/*
 * Display datatype maintaining display specific data.
 * The contents of this structure are implementation dependent.
 * A Display should be treated as opaque by application code.
 */

typedef struct _XDisplay Display;


struct _XPrivate;		/* Forward declare before use for C++ */
struct _XrmHashBucketRec;

typedef struct



{
	XExtData *ext_data;	/* hook for extension to hang data */
	struct _XPrivate *private1;
	int fd;			/* Network socket. */
	int private2;
	int proto_major_version;/* major version of server's X protocol */
	int proto_minor_version;/* minor version of servers X protocol */
	char *vendor;		/* vendor of the server hardware */
        XID private3;
	XID private4;
	XID private5;
	int private6;
	XID (*resource_alloc)(	/* allocator function */
		struct _XDisplay*
	);
	int byte_order;		/* screen byte order, LSBFirst, MSBFirst */
	int bitmap_unit;	/* padding and data requirements */
	int bitmap_pad;		/* padding requirements on bitmaps */
	int bitmap_bit_order;	/* LeastSignificant or MostSignificant */
	int nformats;		/* number of pixmap formats in list */
	ScreenFormat *pixmap_format;	/* pixmap format list */
	int private8;
	int release;		/* release of the server */
	struct _XPrivate *private9, *private10;
	int qlen;		/* Length of input event queue */
	unsigned long last_request_read; /* seq number of last event read */
	unsigned long request;	/* sequence number of last request. */
	XPointer private11;
	XPointer private12;
	XPointer private13;
	XPointer private14;
	unsigned max_request_size; /* maximum number 32 bit words in request*/
	struct _XrmHashBucketRec *db;
	int (*private15)(
		struct _XDisplay*
		);
	char *display_name;	/* "host:display" string used on this connect*/
	int default_screen;	/* default screen for operations */
	int nscreens;		/* number of screens on this server*/
	Screen *screens;	/* pointer to list of screens */
	unsigned long motion_buffer;	/* size of motion buffer */
	unsigned long private16;
	int min_keycode;	/* minimum defined keycode */
	int max_keycode;	/* maximum defined keycode */
	XPointer private17;
	XPointer private18;
	int private19;
	char *xdefaults;	/* contents of defaults from server */
	/* there is more to this structure, but it is private to Xlib */
}



*_XPrivDisplay;

#undef _XEVENT_

/*
 * Definitions of specific events.
 */
typedef struct {
	int type;		/* of event */
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;	        /* "event" window it is reported relative to */
	Window root;	        /* root window that the event occurred on */
	Window subwindow;	/* child window */
	Time time;		/* milliseconds */
	int x, y;		/* pointer x, y coordinates in event window */
	int x_root, y_root;	/* coordinates relative to root */
	unsigned int state;	/* key or button mask */
	unsigned int keycode;	/* detail */
	int  same_screen;	/* same screen flag */
} XKeyEvent;
typedef XKeyEvent XKeyPressedEvent;
typedef XKeyEvent XKeyReleasedEvent;

typedef struct {
	int type;		/* of event */
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;	        /* "event" window it is reported relative to */
	Window root;	        /* root window that the event occurred on */
	Window subwindow;	/* child window */
	Time time;		/* milliseconds */
	int x, y;		/* pointer x, y coordinates in event window */
	int x_root, y_root;	/* coordinates relative to root */
	unsigned int state;	/* key or button mask */
	unsigned int button;	/* detail */
	int  same_screen;	/* same screen flag */
} XButtonEvent;
typedef XButtonEvent XButtonPressedEvent;
typedef XButtonEvent XButtonReleasedEvent;

typedef struct {
	int type;		/* of event */
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;	        /* "event" window reported relative to */
	Window root;	        /* root window that the event occurred on */
	Window subwindow;	/* child window */
	Time time;		/* milliseconds */
	int x, y;		/* pointer x, y coordinates in event window */
	int x_root, y_root;	/* coordinates relative to root */
	unsigned int state;	/* key or button mask */
	char is_hint;		/* detail */
	int  same_screen;	/* same screen flag */
} XMotionEvent;
typedef XMotionEvent XPointerMovedEvent;

typedef struct {
	int type;		/* of event */
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;	        /* "event" window reported relative to */
	Window root;	        /* root window that the event occurred on */
	Window subwindow;	/* child window */
	Time time;		/* milliseconds */
	int x, y;		/* pointer x, y coordinates in event window */
	int x_root, y_root;	/* coordinates relative to root */
	int mode;		/* NotifyNormal, NotifyGrab, NotifyUngrab */
	int detail;
	/*
	 * NotifyAncestor, NotifyVirtual, NotifyInferior,
	 * NotifyNonlinear,NotifyNonlinearVirtual
	 */
	int  same_screen;	/* same screen flag */
	int  focus;		/* boolean focus */
	unsigned int state;	/* key or button mask */
} XCrossingEvent;
typedef XCrossingEvent XEnterWindowEvent;
typedef XCrossingEvent XLeaveWindowEvent;

typedef struct {
	int type;		/* FocusIn or FocusOut */
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;		/* window of event */
	int mode;		/* NotifyNormal, NotifyWhileGrabbed,
				   NotifyGrab, NotifyUngrab */
	int detail;
	/*
	 * NotifyAncestor, NotifyVirtual, NotifyInferior,
	 * NotifyNonlinear,NotifyNonlinearVirtual, NotifyPointer,
	 * NotifyPointerRoot, NotifyDetailNone
	 */
} XFocusChangeEvent;
typedef XFocusChangeEvent XFocusInEvent;
typedef XFocusChangeEvent XFocusOutEvent;

/* generated on EnterWindow and FocusIn  when KeyMapState selected */
typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	char key_vector[32];
} XKeymapEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	int x, y;
	int width, height;
	int count;		/* if non-zero, at least this many more */
} XExposeEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Drawable drawable;
	int x, y;
	int width, height;
	int count;		/* if non-zero, at least this many more */
	int major_code;		/* core is CopyArea or CopyPlane */
	int minor_code;		/* not defined in the core */
} XGraphicsExposeEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Drawable drawable;
	int major_code;		/* core is CopyArea or CopyPlane */
	int minor_code;		/* not defined in the core */
} XNoExposeEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	int state;		/* Visibility state */
} XVisibilityEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window parent;		/* parent of the window */
	Window window;		/* window id of window created */
	int x, y;		/* window location */
	int width, height;	/* size of window */
	int border_width;	/* border width */
	int  override_redirect;	/* creation should be overridden */
} XCreateWindowEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
} XDestroyWindowEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
	int  from_configure;
} XUnmapEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
	int  override_redirect;	/* boolean, is override set... */
} XMapEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window parent;
	Window window;
} XMapRequestEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
	Window parent;
	int x, y;
	int  override_redirect;
} XReparentEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
	int x, y;
	int width, height;
	int border_width;
	Window above;
	int  override_redirect;
} XConfigureEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
	int x, y;
} XGravityEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	int width, height;
} XResizeRequestEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window parent;
	Window window;
	int x, y;
	int width, height;
	int border_width;
	Window above;
	int detail;		/* Above, Below, TopIf, BottomIf, Opposite */
	unsigned long value_mask;
} XConfigureRequestEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window event;
	Window window;
	int place;		/* PlaceOnTop, PlaceOnBottom */
} XCirculateEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window parent;
	Window window;
	int place;		/* PlaceOnTop, PlaceOnBottom */
} XCirculateRequestEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	Atom atom;
	Time time;
	int state;		/* NewValue, Deleted */
} XPropertyEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	Atom selection;
	Time time;
} XSelectionClearEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window owner;
	Window requestor;
	Atom selection;
	Atom target;
	Atom property;
	Time time;
} XSelectionRequestEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window requestor;
	Atom selection;
	Atom target;
	Atom property;		/* ATOM or None */
	Time time;
} XSelectionEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	Colormap colormap;	/* COLORMAP or None */



	int  new;

	int state;		/* ColormapInstalled, ColormapUninstalled */
} XColormapEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;
	Atom message_type;
	int format;
	union {
		char b[20];
		short s[10];
		long l[5];
		} data;
} XClientMessageEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;	/* Display the event was read from */
	Window window;		/* unused */
	int request;		/* one of MappingModifier, MappingKeyboard,
				   MappingPointer */
	int first_keycode;	/* first keycode */
	int count;		/* defines range of change w. first_keycode*/
} XMappingEvent;

typedef struct {
	int type;
	Display *display;	/* Display the event was read from */
	XID resourceid;		/* resource id */
	unsigned long serial;	/* serial number of failed request */
	unsigned char error_code;	/* error code of failed request */
	unsigned char request_code;	/* Major op-code of failed request */
	unsigned char minor_code;	/* Minor op-code of failed request */
} XErrorEvent;

typedef struct {
	int type;
	unsigned long serial;	/* # of last request processed by server */
	int  send_event;	/* true if this came from a SendEvent request */
	Display *display;/* Display the event was read from */
	Window window;	/* window on which event was requested in event mask */
} XAnyEvent;


/***************************************************************
 *
 * GenericEvent.  This event is the standard event for all newer extensions.
 */

typedef struct
    {
    int            type;         /* of event. Always GenericEvent */
    unsigned long  serial;       /* # of last request processed */
    int            send_event;   /* true if from SendEvent request */
    Display        *display;     /* Display the event was read from */
    int            extension;    /* major opcode of extension that caused the event */
    int            evtype;       /* actual event type. */
    } XGenericEvent;

typedef struct {
    int            type;         /* of event. Always GenericEvent */
    unsigned long  serial;       /* # of last request processed */
    int            send_event;   /* true if from SendEvent request */
    Display        *display;     /* Display the event was read from */
    int            extension;    /* major opcode of extension that caused the event */
    int            evtype;       /* actual event type. */
    unsigned int   cookie;
    void           *data;
} XGenericEventCookie;

/*
 * this union is defined so Xlib can always use the same sized
 * event structure internally, to avoid memory fragmentation.
 */
typedef union _XEvent {
        int type;		/* must not be changed; first element */
	XAnyEvent xany;
	XKeyEvent xkey;
	XButtonEvent xbutton;
	XMotionEvent xmotion;
	XCrossingEvent xcrossing;
	XFocusChangeEvent xfocus;
	XExposeEvent xexpose;
	XGraphicsExposeEvent xgraphicsexpose;
	XNoExposeEvent xnoexpose;
	XVisibilityEvent xvisibility;
	XCreateWindowEvent xcreatewindow;
	XDestroyWindowEvent xdestroywindow;
	XUnmapEvent xunmap;
	XMapEvent xmap;
	XMapRequestEvent xmaprequest;
	XReparentEvent xreparent;
	XConfigureEvent xconfigure;
	XGravityEvent xgravity;
	XResizeRequestEvent xresizerequest;
	XConfigureRequestEvent xconfigurerequest;
	XCirculateEvent xcirculate;
	XCirculateRequestEvent xcirculaterequest;
	XPropertyEvent xproperty;
	XSelectionClearEvent xselectionclear;
	XSelectionRequestEvent xselectionrequest;
	XSelectionEvent xselection;
	XColormapEvent xcolormap;
	XClientMessageEvent xclient;
	XMappingEvent xmapping;
	XErrorEvent xerror;
	XKeymapEvent xkeymap;
	XGenericEvent xgeneric;
	XGenericEventCookie xcookie;
	long pad[24];
} XEvent;


#define XAllocID(dpy) ((*((_XPrivDisplay)dpy)->resource_alloc)((dpy)))

/*
 * per character font metric information.
 */
typedef struct {
    short	lbearing;	/* origin to left edge of raster */
    short	rbearing;	/* origin to right edge of raster */
    short	width;		/* advance to next char's origin */
    short	ascent;		/* baseline to top edge of raster */
    short	descent;	/* baseline to bottom edge of raster */
    unsigned short attributes;	/* per char flags (not predefined) */
} XCharStruct;

/*
 * To allow arbitrary information with fonts, there are additional properties
 * returned.
 */
typedef struct {
    Atom name;
    unsigned long card32;
} XFontProp;

typedef struct {
    XExtData	*ext_data;	/* hook for extension to hang data */
    Font        fid;            /* Font id for this font */
    unsigned	direction;	/* hint about direction the font is painted */
    unsigned	min_char_or_byte2;/* first character */
    unsigned	max_char_or_byte2;/* last character */
    unsigned	min_byte1;	/* first row that exists */
    unsigned	max_byte1;	/* last row that exists */
    int 	all_chars_exist;/* flag if all characters have non-zero size*/
    unsigned	default_char;	/* char to print for undefined character */
    int         n_properties;   /* how many properties there are */
    XFontProp	*properties;	/* pointer to array of additional properties*/
    XCharStruct	min_bounds;	/* minimum bounds over all existing char*/
    XCharStruct	max_bounds;	/* maximum bounds over all existing char*/
    XCharStruct	*per_char;	/* first_char to last_char information */
    int		ascent;		/* log. extent above baseline for spacing */
    int		descent;	/* log. descent below baseline for spacing */
} XFontStruct;

/*
 * PolyText routines take these as arguments.
 */
typedef struct {
    char *chars;		/* pointer to string */
    int nchars;			/* number of characters */
    int delta;			/* delta between strings */
    Font font;			/* font to print it in, None don't change */
} XTextItem;

typedef struct {		/* normal 16 bit characters are two bytes */
    unsigned char byte1;
    unsigned char byte2;
} XChar2b;

typedef struct {
    XChar2b *chars;		/* two byte characters */
    int nchars;			/* number of characters */
    int delta;			/* delta between strings */
    Font font;			/* font to print it in, None don't change */
} XTextItem16;


typedef union { Display *display;
		GC gc;
		Visual *visual;
		Screen *screen;
		ScreenFormat *pixmap_format;
		XFontStruct *font; } XEDataObject;

typedef struct {
    XRectangle      max_ink_extent;
    XRectangle      max_logical_extent;
} XFontSetExtents;

/* unused:
typedef void (*XOMProc)();
 */

typedef struct _XOM *XOM;
typedef struct _XOC *XOC, *XFontSet;

typedef struct {
    char           *chars;
    int             nchars;
    int             delta;
    XFontSet        font_set;
} XmbTextItem;

typedef struct {
    wchar_t        *chars;
    int             nchars;
    int             delta;
    XFontSet        font_set;
} XwcTextItem;

#define XNRequiredCharSet "requiredCharSet"
#define XNQueryOrientation "queryOrientation"
#define XNBaseFontName "baseFontName"
#define XNOMAutomatic "omAutomatic"
#define XNMissingCharSet "missingCharSet"
#define XNDefaultString "defaultString"
#define XNOrientation "orientation"
#define XNDirectionalDependentDrawing "directionalDependentDrawing"
#define XNContextualDrawing "contextualDrawing"
#define XNFontInfo "fontInfo"

typedef struct {
    int charset_count;
    char **charset_list;
} XOMCharSetList;

typedef enum {
    XOMOrientation_LTR_TTB,
    XOMOrientation_RTL_TTB,
    XOMOrientation_TTB_LTR,
    XOMOrientation_TTB_RTL,
    XOMOrientation_Context
} XOrientation;

typedef struct {
    int num_orientation;
    XOrientation *orientation;	/* Input Text description */
} XOMOrientation;

typedef struct {
    int num_font;
    XFontStruct **font_struct_list;
    char **font_name_list;
} XOMFontInfo;

typedef struct _XIM *XIM;
typedef struct _XIC *XIC;

typedef void (*XIMProc)(
    XIM,
    XPointer,
    XPointer
);

typedef int  (*XICProc)(
    XIC,
    XPointer,
    XPointer
);

typedef void (*XIDProc)(
    Display*,
    XPointer,
    XPointer
);

typedef unsigned long XIMStyle;

typedef struct {
    unsigned short count_styles;
    XIMStyle *supported_styles;
} XIMStyles;

#define XIMPreeditArea		0x0001L
#define XIMPreeditCallbacks	0x0002L
#define XIMPreeditPosition	0x0004L
#define XIMPreeditNothing	0x0008L
#define XIMPreeditNone		0x0010L
#define XIMStatusArea		0x0100L
#define XIMStatusCallbacks	0x0200L
#define XIMStatusNothing	0x0400L
#define XIMStatusNone		0x0800L

#define XNVaNestedList "XNVaNestedList"
#define XNQueryInputStyle "queryInputStyle"
#define XNClientWindow "clientWindow"
#define XNInputStyle "inputStyle"
#define XNFocusWindow "focusWindow"
#define XNResourceName "resourceName"
#define XNResourceClass "resourceClass"
#define XNGeometryCallback "geometryCallback"
#define XNDestroyCallback "destroyCallback"
#define XNFilterEvents "filterEvents"
#define XNPreeditStartCallback "preeditStartCallback"
#define XNPreeditDoneCallback "preeditDoneCallback"
#define XNPreeditDrawCallback "preeditDrawCallback"
#define XNPreeditCaretCallback "preeditCaretCallback"
#define XNPreeditStateNotifyCallback "preeditStateNotifyCallback"
#define XNPreeditAttributes "preeditAttributes"
#define XNStatusStartCallback "statusStartCallback"
#define XNStatusDoneCallback "statusDoneCallback"
#define XNStatusDrawCallback "statusDrawCallback"
#define XNStatusAttributes "statusAttributes"
#define XNArea "area"
#define XNAreaNeeded "areaNeeded"
#define XNSpotLocation "spotLocation"
#define XNColormap "colorMap"
#define XNStdColormap "stdColorMap"
#define XNForeground "foreground"
#define XNBackground "background"
#define XNBackgroundPixmap "backgroundPixmap"
#define XNFontSet "fontSet"
#define XNLineSpace "lineSpace"
#define XNCursor "cursor"

#define XNQueryIMValuesList "queryIMValuesList"
#define XNQueryICValuesList "queryICValuesList"
#define XNVisiblePosition "visiblePosition"
#define XNR6PreeditCallback "r6PreeditCallback"
#define XNStringConversionCallback "stringConversionCallback"
#define XNStringConversion "stringConversion"
#define XNResetState "resetState"
#define XNHotKey "hotKey"
#define XNHotKeyState "hotKeyState"
#define XNPreeditState "preeditState"
#define XNSeparatorofNestedList "separatorofNestedList"

#define XBufferOverflow		-1
#define XLookupNone		1
#define XLookupChars		2
#define XLookupKeySym		3
#define XLookupBoth		4

typedef void *XVaNestedList;

typedef struct {
    XPointer client_data;
    XIMProc callback;
} XIMCallback;

typedef struct {
    XPointer client_data;
    XICProc callback;
} XICCallback;

typedef unsigned long XIMFeedback;

#define XIMReverse		1L
#define XIMUnderline		(1L<<1)
#define XIMHighlight		(1L<<2)
#define XIMPrimary	 	(1L<<5)
#define XIMSecondary		(1L<<6)
#define XIMTertiary	 	(1L<<7)
#define XIMVisibleToForward 	(1L<<8)
#define XIMVisibleToBackword 	(1L<<9)
#define XIMVisibleToCenter 	(1L<<10)

typedef struct _XIMText {
    unsigned short length;
    XIMFeedback *feedback;
    int  encoding_is_wchar;
    union {
	char *multi_byte;
	wchar_t *wide_char;
    } string;
} XIMText;

typedef	unsigned long	 XIMPreeditState;

#define	XIMPreeditUnKnown	0L
#define	XIMPreeditEnable	1L
#define	XIMPreeditDisable	(1L<<1)

typedef	struct	_XIMPreeditStateNotifyCallbackStruct {
    XIMPreeditState state;
} XIMPreeditStateNotifyCallbackStruct;

typedef	unsigned long	 XIMResetState;

#define	XIMInitialState		1L
#define	XIMPreserveState	(1L<<1)

typedef unsigned long XIMStringConversionFeedback;

#define	XIMStringConversionLeftEdge	(0x00000001)
#define	XIMStringConversionRightEdge	(0x00000002)
#define	XIMStringConversionTopEdge	(0x00000004)
#define	XIMStringConversionBottomEdge	(0x00000008)
#define	XIMStringConversionConcealed	(0x00000010)
#define	XIMStringConversionWrapped	(0x00000020)

typedef struct _XIMStringConversionText {
    unsigned short length;
    XIMStringConversionFeedback *feedback;
    int  encoding_is_wchar;
    union {
	char *mbs;
	wchar_t *wcs;
    } string;
} XIMStringConversionText;

typedef	unsigned short	XIMStringConversionPosition;

typedef	unsigned short	XIMStringConversionType;

#define	XIMStringConversionBuffer	(0x0001)
#define	XIMStringConversionLine		(0x0002)
#define	XIMStringConversionWord		(0x0003)
#define	XIMStringConversionChar		(0x0004)

typedef	unsigned short	XIMStringConversionOperation;

#define	XIMStringConversionSubstitution	(0x0001)
#define	XIMStringConversionRetrieval	(0x0002)

typedef enum {
    XIMForwardChar, XIMBackwardChar,
    XIMForwardWord, XIMBackwardWord,
    XIMCaretUp, XIMCaretDown,
    XIMNextLine, XIMPreviousLine,
    XIMLineStart, XIMLineEnd,
    XIMAbsolutePosition,
    XIMDontChange
} XIMCaretDirection;

typedef struct _XIMStringConversionCallbackStruct {
    XIMStringConversionPosition position;
    XIMCaretDirection direction;
    XIMStringConversionOperation operation;
    unsigned short factor;
    XIMStringConversionText *text;
} XIMStringConversionCallbackStruct;

typedef struct _XIMPreeditDrawCallbackStruct {
    int caret;		/* Cursor offset within pre-edit string */
    int chg_first;	/* Starting change position */
    int chg_length;	/* Length of the change in character count */
    XIMText *text;
} XIMPreeditDrawCallbackStruct;

typedef enum {
    XIMIsInvisible,	/* Disable caret feedback */
    XIMIsPrimary,	/* UI defined caret feedback */
    XIMIsSecondary	/* UI defined caret feedback */
} XIMCaretStyle;

typedef struct _XIMPreeditCaretCallbackStruct {
    int position;		 /* Caret offset within pre-edit string */
    XIMCaretDirection direction; /* Caret moves direction */
    XIMCaretStyle style;	 /* Feedback of the caret */
} XIMPreeditCaretCallbackStruct;

typedef enum {
    XIMTextType,
    XIMBitmapType
} XIMStatusDataType;

typedef struct _XIMStatusDrawCallbackStruct {
    XIMStatusDataType type;
    union {
	XIMText *text;
	Pixmap  bitmap;
    } data;
} XIMStatusDrawCallbackStruct;

typedef struct _XIMHotKeyTrigger {
    KeySym	 keysym;
    int		 modifier;
    int		 modifier_mask;
} XIMHotKeyTrigger;

typedef struct _XIMHotKeyTriggers {
    int			 num_hot_key;
    XIMHotKeyTrigger	*key;
} XIMHotKeyTriggers;

typedef	unsigned long	 XIMHotKeyState;

#define	XIMHotKeyStateON	(0x0001L)
#define	XIMHotKeyStateOFF	(0x0002L)

typedef struct {
    unsigned short count_values;
    char **supported_values;
} XIMValuesList;

 





extern int _Xdebug;

extern XFontStruct *XLoadQueryFont(
    Display*		/* display */,
    const  char*	/* name */
);

extern XFontStruct *XQueryFont(
    Display*		/* display */,
    XID			/* font_ID */
);


extern XTimeCoord *XGetMotionEvents(
    Display*		/* display */,
    Window		/* w */,
    Time		/* start */,
    Time		/* stop */,
    int*		/* nevents_return */
);

extern XModifierKeymap *XDeleteModifiermapEntry(
    XModifierKeymap*	/* modmap */,



    KeyCode		/* keycode_entry */,

    int			/* modifier */
);

extern XModifierKeymap	*XGetModifierMapping(
    Display*		/* display */
);

extern XModifierKeymap	*XInsertModifiermapEntry(
    XModifierKeymap*	/* modmap */,



    KeyCode		/* keycode_entry */,

    int			/* modifier */
);

extern XModifierKeymap *XNewModifiermap(
    int			/* max_keys_per_mod */
);

extern XImage *XCreateImage(
    Display*		/* display */,
    Visual*		/* visual */,
    unsigned int	/* depth */,
    int			/* format */,
    int			/* offset */,
    char*		/* data */,
    unsigned int	/* width */,
    unsigned int	/* height */,
    int			/* bitmap_pad */,
    int			/* bytes_per_line */
);
extern int  XInitImage(
    XImage*		/* image */
);
extern XImage *XGetImage(
    Display*		/* display */,
    Drawable		/* d */,
    int			/* x */,
    int			/* y */,
    unsigned int	/* width */,
    unsigned int	/* height */,
    unsigned long	/* plane_mask */,
    int			/* format */
);
extern XImage *XGetSubImage(
    Display*		/* display */,
    Drawable		/* d */,
    int			/* x */,
    int			/* y */,
    unsigned int	/* width */,
    unsigned int	/* height */,
    unsigned long	/* plane_mask */,
    int			/* format */,
    XImage*		/* dest_image */,
    int			/* dest_x */,
    int			/* dest_y */
);

/*
 * X function declarations.
 */
extern Display *XOpenDisplay(
    const  char*	/* display_name */
);

extern void XrmInitialize(
    void
);

extern char *XFetchBytes(
    Display*		/* display */,
    int*		/* nbytes_return */
);
extern char *XFetchBuffer(
    Display*		/* display */,
    int*		/* nbytes_return */,
    int			/* buffer */
);
extern char *XGetAtomName(
    Display*		/* display */,
    Atom		/* atom */
);
extern int  XGetAtomNames(
    Display*		/* dpy */,
    Atom*		/* atoms */,
    int			/* count */,
    char**		/* names_return */
);
extern char *XGetDefault(
    Display*		/* display */,
    const  char*	/* program */,
    const  char*	/* option */
);
extern char *XDisplayName(
    const  char*	/* string */
);
extern char *XKeysymToString(
    KeySym		/* keysym */
);

extern int (*XSynchronize(
    Display*		/* display */,
    int 		/* onoff */
))(
    Display*		/* display */
);
extern int (*XSetAfterFunction(
    Display*		/* display */,
    int (*) (
	     Display*	/* display */
            )		/* procedure */
))(
    Display*		/* display */
);
extern Atom XInternAtom(
    Display*		/* display */,
    const  char*	/* atom_name */,
    int 		/* only_if_exists */
);
extern int  XInternAtoms(
    Display*		/* dpy */,
    char**		/* names */,
    int			/* count */,
    int 		/* onlyIfExists */,
    Atom*		/* atoms_return */
);
extern Colormap XCopyColormapAndFree(
    Display*		/* display */,
    Colormap		/* colormap */
);
extern Colormap XCreateColormap(
    Display*		/* display */,
    Window		/* w */,
    Visual*		/* visual */,
    int			/* alloc */
);
extern Cursor XCreatePixmapCursor(
    Display*		/* display */,
    Pixmap		/* source */,
    Pixmap		/* mask */,
    XColor*		/* foreground_color */,
    XColor*		/* background_color */,
    unsigned int	/* x */,
    unsigned int	/* y */
);
extern Cursor XCreateGlyphCursor(
    Display*		/* display */,
    Font		/* source_font */,
    Font		/* mask_font */,
    unsigned int	/* source_char */,
    unsigned int	/* mask_char */,
    XColor const  *	/* foreground_color */,
    XColor const  *	/* background_color */
);
extern Cursor XCreateFontCursor(
    Display*		/* display */,
    unsigned int	/* shape */
);
extern Font XLoadFont(
    Display*		/* display */,
    const  char*	/* name */
);
extern GC XCreateGC(
    Display*		/* display */,
    Drawable		/* d */,
    unsigned long	/* valuemask */,
    XGCValues*		/* values */
);
extern GContext XGContextFromGC(
    GC			/* gc */
);
extern void XFlushGC(
    Display*		/* display */,
    GC			/* gc */
);
extern Pixmap XCreatePixmap(
    Display*		/* display */,
    Drawable		/* d */,
    unsigned int	/* width */,
    unsigned int	/* height */,
    unsigned int	/* depth */
);
extern Pixmap XCreateBitmapFromData(
    Display*		/* display */,
    Drawable		/* d */,
    const  char*	/* data */,
    unsigned int	/* width */,
    unsigned int	/* height */
);
extern Pixmap XCreatePixmapFromBitmapData(
    Display*		/* display */,
    Drawable		/* d */,
    char*		/* data */,
    unsigned int	/* width */,
    unsigned int	/* height */,
    unsigned long	/* fg */,
    unsigned long	/* bg */,
    unsigned int	/* depth */
);
extern Window XCreateSimpleWindow(
    Display*		/* display */,
    Window		/* parent */,
    int			/* x */,
    int			/* y */,
    unsigned int	/* width */,
    unsigned int	/* height */,
    unsigned int	/* border_width */,
    unsigned long	/* border */,
    unsigned long	/* background */
);
extern Window XGetSelectionOwner(
    Display*		/* display */,
    Atom		/* selection */
);
extern Window XCreateWindow(
    Display*		/* display */,
    Window		/* parent */,
    int			/* x */,
    int			/* y */,
    unsigned int	/* width */,
    unsigned int	/* height */,
    unsigned int	/* border_width */,
    int			/* depth */,
    unsigned int	/* class */,
    Visual*		/* visual */,
    unsigned long	/* valuemask */,
    XSetWindowAttributes*	/* attributes */
);
extern Colormap *XListInstalledColormaps(
    Display*		/* display */,
    Window		/* w */,
    int*		/* num_return */
);
extern char **XListFonts(
    Display*		/* display */,
    const  char*	/* pattern */,
    int			/* maxnames */,
    int*		/* actual_count_return */
);
extern char **XListFontsWithInfo(
    Display*		/* display */,
    const  char*	/* pattern */,
    int			/* maxnames */,
    int*		/* count_return */,
    XFontStruct**	/* info_return */
);
extern char **XGetFontPath(
    Display*		/* display */,
    int*		/* npaths_return */
);
extern char **XListExtensions(
    Display*		/* display */,
    int*		/* nextensions_return */
);
extern Atom *XListProperties(
    Display*		/* display */,
    Window		/* w */,
    int*		/* num_prop_return */
);
extern XHostAddress *XListHosts(
    Display*		/* display */,
    int*		/* nhosts_return */,
    int *		/* state_return */
);
__attribute__((deprecated)) 
extern KeySym XKeycodeToKeysym(
    Display*		/* display */,



    KeyCode		/* keycode */,

    int			/* index */
);
extern KeySym XLookupKeysym(
    XKeyEvent*		/* key_event */,
    int			/* index */
);
extern KeySym *XGetKeyboardMapping(
    Display*		/* display */,



    KeyCode		/* first_keycode */,

    int			/* keycode_count */,
    int*		/* keysyms_per_keycode_return */
);
extern KeySym XStringToKeysym(
    const  char*	/* string */
);
extern long XMaxRequestSize(
    Display*		/* display */
);
extern long XExtendedMaxRequestSize(
    Display*		/* display */
);
extern char *XResourceManagerString(
    Display*		/* display */
);
extern char *XScreenResourceString(
	Screen*		/* screen */
);
extern unsigned long XDisplayMotionBufferSize(
    Display*		/* display */
);
extern VisualID XVisualIDFromVisual(
    Visual*		/* visual */
);

/* multithread routines */

extern int  XInitThreads(
    void
);

extern void XLockDisplay(
    Display*		/* display */
);

extern void XUnlockDisplay(
    Display*		/* display */
);

/* routines for dealing with extensions */

extern XExtCodes *XInitExtension(
    Display*		/* display */,
    const  char*	/* name */
);

extern XExtCodes *XAddExtension(
    Display*		/* display */
);
extern XExtData *XFindOnExtensionList(
    XExtData**		/* structure */,
    int			/* number */
);
extern XExtData **XEHeadOfExtensionList(
    XEDataObject	/* object */
);

/* these are routines for which there are also macros */
extern Window XRootWindow(
    Display*		/* display */,
    int			/* screen_number */
);
extern Window XDefaultRootWindow(
    Display*		/* display */
);
extern Window XRootWindowOfScreen(
    Screen*		/* screen */
);
extern Visual *XDefaultVisual(
    Display*		/* display */,
    int			/* screen_number */
);
extern Visual *XDefaultVisualOfScreen(
    Screen*		/* screen */
);
extern GC XDefaultGC(
    Display*		/* display */,
    int			/* screen_number */
);
extern GC XDefaultGCOfScreen(
    Screen*		/* screen */
);
extern unsigned long XBlackPixel(
    Display*		/* display */,
    int			/* screen_number */
);
extern unsigned long XWhitePixel(
    Display*		/* display */,
    int			/* screen_number */
);
extern unsigned long XAllPlanes(
    void
);
extern unsigned long XBlackPixelOfScreen(
    Screen*		/* screen */
);
extern unsigned long XWhitePixelOfScreen(
    Screen*		/* screen */
);
extern unsigned long XNextRequest(
    Display*		/* display */
);
extern unsigned long XLastKnownRequestProcessed(
    Display*		/* display */
);
extern char *XServerVendor(
    Display*		/* display */
);
extern char *XDisplayString(
    Display*		/* display */
);
extern Colormap XDefaultColormap(
    Display*		/* display */,
    int			/* screen_number */
);
extern Colormap XDefaultColormapOfScreen(
    Screen*		/* screen */
);
extern Display *XDisplayOfScreen(
    Screen*		/* screen */
);
extern Screen *XScreenOfDisplay(
    Display*		/* display */,
    int			/* screen_number */
);
extern Screen *XDefaultScreenOfDisplay(
    Display*		/* display */
);
extern long XEventMaskOfScreen(
    Screen*		/* screen */
);

extern int XScreenNumberOfScreen(
    Screen*		/* screen */
);

typedef int (*XErrorHandler) (	    /* WARNING, this type not in Xlib spec */
    Display*		/* display */,
    XErrorEvent*	/* error_event */
);

extern XErrorHandler XSetErrorHandler (
    XErrorHandler	/* handler */
);


typedef int (*XIOErrorHandler) (    /* WARNING, this type not in Xlib spec */
    Display*		/* display */
);

extern XIOErrorHandler XSetIOErrorHandler (
    XIOErrorHandler	/* handler */
);


extern XPixmapFormatValues *XListPixmapFormats(
    Display*		/* display */,
    int*		/* count_return */
);
extern int *XListDepths(
    Display*		/* display */,
    int			/* screen_number */,
    int*		/* count_return */
);

/* ICCCM routines for things that don't require special include files; */
/* other declarations are given in Xutil.h                             */
extern int  XReconfigureWMWindow(
    Display*		/* display */,
    Window		/* w */,
    int			/* screen_number */,
    unsigned int	/* mask */,
    XWindowChanges*	/* changes */
);

extern int  XGetWMProtocols(
    Display*		/* display */,
    Window		/* w */,
    Atom**		/* protocols_return */,
    int*		/* count_return */
);
extern int  XSetWMProtocols(
    Display*		/* display */,
    Window		/* w */,
    Atom*		/* protocols */,
    int			/* count */
);
extern int  XIconifyWindow(
    Display*		/* display */,
    Window		/* w */,
    int			/* screen_number */
);
extern int  XWithdrawWindow(
    Display*		/* display */,
    Window		/* w */,
    int			/* screen_number */
);
extern int  XGetCommand(
    Display*		/* display */,
    Window		/* w */,
    char***		/* argv_return */,
    int*		/* argc_return */
);
extern int  XGetWMColormapWindows(
    Display*		/* display */,
    Window		/* w */,
    Window**		/* windows_return */,
    int*		/* count_return */
);
extern int  XSetWMColormapWindows(
    Display*		/* display */,
    Window		/* w */,
    Window*		/* colormap_windows */,
    int			/* count */
);
extern void XFreeStringList(
    char**		/* list */
);
extern int XSetTransientForHint(
    Display*		/* display */,
    Window		/* w */,
    Window		/* prop_window */
);

/* The following are given in alphabetical order */

extern int XActivateScreenSaver(
    Display*		/* display */
);

extern int XAddHost(
    Display*		/* display */,
    XHostAddress*	/* host */
);

extern int XAddHosts(
    Display*		/* display */,
    XHostAddress*	/* hosts */,
    int			/* num_hosts */
);

extern int XAddToExtensionList(
    struct _XExtData**	/* structure */,
    XExtData*		/* ext_data */
);

extern int XAddToSaveSet(
    Display*		/* display */,
    Window		/* w */
);

extern int  XAllocColor(
    Display*		/* display */,
    Colormap		/* colormap */,
    XColor*		/* screen_in_out */
);

extern int  XAllocColorCells(
    Display*		/* display */,
    Colormap		/* colormap */,
    int 	        /* contig */,
    unsigned long*	/* plane_masks_return */,
    unsigned int	/* nplanes */,
    unsigned long*	/* pixels_return */,
    unsigned int 	/* npixels */
);

extern int  XAllocColorPlanes(
    Display*		/* display */,
    Colormap		/* colormap */,
    int 		/* contig */,
    unsigned long*	/* pixels_return */,
    int			/* ncolors */,
    int			/* nreds */,
    int			/* ngreens */,
    int			/* nblues */,
    unsigned long*	/* rmask_return */,
    unsigned long*	/* gmask_return */,
    unsigned long*	/* bmask_return */
);

extern int  XAllocNamedColor(
    Display*		/* display */,
    Colormap		/* colormap */,
    const  char*	/* color_name */,
    XColor*		/* screen_def_return */,
    XColor*		/* exact_def_return */
);

extern int XAllowEvents(
    Display*		/* display */,
    int			/* event_mode */,
    Time		/* time */
);

extern int XAutoRepeatOff(
    Display*		/* display */
);

extern int XAutoRepeatOn(
    Display*		/* display */
);

extern int XBell(
    Display*		/* display */,
    int			/* percent */
);

extern int XBitmapBitOrder(
    Display*		/* display */
);

extern int XBitmapPad(
    Display*		/* display */
);

extern int XBitmapUnit(
    Display*		/* display */
);

extern int XCellsOfScreen(
    Screen*		/* screen */
);

extern int XChangeActivePointerGrab(
    Display*		/* display */,
    unsigned int	/* event_mask */,
    Cursor		/* cursor */,
    Time		/* time */
);

extern int XChangeGC(
    Display*		/* display */,
    GC			/* gc */,
    unsigned long	/* valuemask */,
    XGCValues*		/* values */
);

extern int XChangeKeyboardControl(
    Display*		/* display */,
    unsigned long	/* value_mask */,
    XKeyboardControl*	/* values */
);

extern int XChangeKeyboardMapping(
    Display*		/* display */,
    int			/* first_keycode */,
    int			/* keysyms_per_keycode */,
    KeySym*		/* keysyms */,
    int			/* num_codes */
);

extern int XChangePointerControl(
    Display*		/* display */,
    int 		/* do_accel */,
    int 		/* do_threshold */,
    int			/* accel_numerator */,
    int			/* accel_denominator */,
    int			/* threshold */
);

extern int XChangeProperty(
    Display*		/* display */,
    Window		/* w */,
    Atom		/* property */,
    Atom		/* type */,
    int			/* format */,
    int			/* mode */,
    const  unsigned char*	/* data */,
    int			/* nelements */
);

extern int XChangeSaveSet(
    Display*		/* display */,
    Window		/* w */,
    int			/* change_mode */
);

extern int XChangeWindowAttributes(
    Display*		/* display */,
    Window		/* w */,
    unsigned long	/* valuemask */,
    XSetWindowAttributes* /* attributes */
);

extern int  XCheckIfEvent(
    Display*		/* display */,
    XEvent*		/* event_return */,
    int  (*) (
	       Display*			/* display */,
               XEvent*			/* event */,
               XPointer			/* arg */
             )		/* predicate */,
    XPointer		/* arg */
);

extern int  XCheckMaskEvent(
    Display*		/* display */,
    long		/* event_mask */,
    XEvent*		/* event_return */
);

extern int  XCheckTypedEvent(
    Display*		/* display */,
    int			/* event_type */,
    XEvent*		/* event_return */
);

extern int  XCheckTypedWindowEvent(
    Display*		/* display */,
    Window		/* w */,
    int			/* event_type */,
    XEvent*		/* event_return */
);

extern int  XCheckWindowEvent(
    Display*		/* display */,
    Window		/* w */,
    long		/* event_mask */,
    XEvent*		/* event_return */
);

extern int XCirculateSubwindows(
    Display*		/* display */,
    Window		/* w */,
    int			/* direction */
);

extern int XCirculateSubwindowsDown(
    Display*		/* display */,
    Window		/* w */
);

extern int XCirculateSubwindowsUp(
    Display*		/* display */,
    Window		/* w */
);

extern int XClearArea(
    Display*		/* display */,
    Window		/* w */,
    int			/* x */,
    int			/* y */,
    unsigned int	/* width */,
    unsigned int	/* height */,
    int 		/* exposures */
);

extern int XClearWindow(
    Display*		/* display */,
    Window		/* w */
);

extern int XCloseDisplay(
    Display*		/* display */
);

extern int XConfigureWindow(
    Display*		/* display */,
    Window		/* w */,
    unsigned int	/* value_mask */,
    XWindowChanges*	/* values */
);

extern int XConnectionNumber(
    Display*		/* display */
);

extern int XConvertSelection(
    Display*		/* display */,
    Atom		/* selection */,
    Atom 		/* target */,
    Atom		/* property */,
    Window		/* requestor */,
    Time		/* time */
);

extern int XCopyArea(
    Display*		/* display */,
    Drawable		/* src */,
    Drawable		/* dest */,
    GC			/* gc */,
    int			/* src_x */,
    int			/* src_y */,
    unsigned int	/* width */,
    unsigned int	/* height */,
    int			/* dest_x */,
    int			/* dest_y */
);

extern int XCopyGC(
    Display*		/* display */,
    GC			/* src */,
    unsigned long	/* valuemask */,
    GC			/* dest */
);

extern int XCopyPlane(
    Display*		/* display */,
    Drawable		/* src */,
    Drawable		/* dest */,
    GC			/* gc */,
    int			/* src_x */,
    int			/* src_y */,
    unsigned int	/* width */,
    unsigned int	/* height */,
    int			/* dest_x */,
    int			/* dest_y */,
    unsigned long	/* plane */
);

extern int XDefaultDepth(
    Display*		/* display */,
    int			/* screen_number */
);

extern int XDefaultDepthOfScreen(
    Screen*		/* screen */
);

extern int XDefaultScreen(
    Display*		/* display */
);

extern int XDefineCursor(
    Display*		/* display */,
    Window		/* w */,
    Cursor		/* cursor */
);

extern int XDeleteProperty(
    Display*		/* display */,
    Window		/* w */,
    Atom		/* property */
);

extern int XDestroyWindow(
    Display*		/* display */,
    Window		/* w */
);

extern int XDestroySubwindows(
    Display*		/* display */,
    Window		/* w */
);

extern int XDoesBackingStore(
    Screen*		/* screen */
);

extern int  XDoesSaveUnders(
    Screen*		/* screen */
);

extern int XDisableAccessControl(
    Display*		/* display */
);


extern int XDisplayCells(
    Display*		/* display */,
    int			/* screen_number */
);

extern int XDisplayHeight(
    Display*		/* display */,
    int			/* screen_number */
);

extern int XDisplayHeightMM(
    Display*		/* display */,
    int			/* screen_number */
);

extern int XDisplayKeycodes(
    Display*		/* display */,
    int*		/* min_keycodes_return */,
    int*		/* max_keycodes_return */
);

extern int XDisplayPlanes(
    Display*		/* display */,
    int			/* screen_number */
);

extern int XDisplayWidth(
    Display*		/* display */,
    int			/* screen_number */
);

extern int XDisplayWidthMM(
    Display*		/* display */,
    int			/* screen_number */
);

extern int XDrawArc(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    unsigned int	/* width */,
    unsigned int	/* height */,
    int			/* angle1 */,
    int			/* angle2 */
);

extern int XDrawArcs(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    XArc*		/* arcs */,
    int			/* narcs */
);

extern int XDrawImageString(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    const  char*	/* string */,
    int			/* length */
);

extern int XDrawImageString16(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    const  XChar2b*	/* string */,
    int			/* length */
);

extern int XDrawLine(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    int			/* x1 */,
    int			/* y1 */,
    int			/* x2 */,
    int			/* y2 */
);

extern int XDrawLines(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    XPoint*		/* points */,
    int			/* npoints */,
    int			/* mode */
);

extern int XDrawPoint(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */
);

extern int XDrawPoints(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    XPoint*		/* points */,
    int			/* npoints */,
    int			/* mode */
);

extern int XDrawRectangle(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    unsigned int	/* width */,
    unsigned int	/* height */
);

extern int XDrawRectangles(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    XRectangle*		/* rectangles */,
    int			/* nrectangles */
);

extern int XDrawSegments(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    XSegment*		/* segments */,
    int			/* nsegments */
);

extern int XDrawString(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    const  char*	/* string */,
    int			/* length */
);

extern int XDrawString16(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    const  XChar2b*	/* string */,
    int			/* length */
);

extern int XDrawText(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    XTextItem*		/* items */,
    int			/* nitems */
);

extern int XDrawText16(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    XTextItem16*	/* items */,
    int			/* nitems */
);

extern int XEnableAccessControl(
    Display*		/* display */
);

extern int XEventsQueued(
    Display*		/* display */,
    int			/* mode */
);

extern int  XFetchName(
    Display*		/* display */,
    Window		/* w */,
    char**		/* window_name_return */
);

extern int XFillArc(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    unsigned int	/* width */,
    unsigned int	/* height */,
    int			/* angle1 */,
    int			/* angle2 */
);

extern int XFillArcs(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    XArc*		/* arcs */,
    int			/* narcs */
);

extern int XFillPolygon(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    XPoint*		/* points */,
    int			/* npoints */,
    int			/* shape */,
    int			/* mode */
);

extern int XFillRectangle(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    unsigned int	/* width */,
    unsigned int	/* height */
);

extern int XFillRectangles(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    XRectangle*		/* rectangles */,
    int			/* nrectangles */
);

extern int XFlush(
    Display*		/* display */
);

extern int XForceScreenSaver(
    Display*		/* display */,
    int			/* mode */
);

extern int XFree(
    void*		/* data */
);

extern int XFreeColormap(
    Display*		/* display */,
    Colormap		/* colormap */
);

extern int XFreeColors(
    Display*		/* display */,
    Colormap		/* colormap */,
    unsigned long*	/* pixels */,
    int			/* npixels */,
    unsigned long	/* planes */
);

extern int XFreeCursor(
    Display*		/* display */,
    Cursor		/* cursor */
);

extern int XFreeExtensionList(
    char**		/* list */
);

extern int XFreeFont(
    Display*		/* display */,
    XFontStruct*	/* font_struct */
);

extern int XFreeFontInfo(
    char**		/* names */,
    XFontStruct*	/* free_info */,
    int			/* actual_count */
);

extern int XFreeFontNames(
    char**		/* list */
);

extern int XFreeFontPath(
    char**		/* list */
);

extern int XFreeGC(
    Display*		/* display */,
    GC			/* gc */
);

extern int XFreeModifiermap(
    XModifierKeymap*	/* modmap */
);

extern int XFreePixmap(
    Display*		/* display */,
    Pixmap		/* pixmap */
);

extern int XGeometry(
    Display*		/* display */,
    int			/* screen */,
    const  char*	/* position */,
    const  char*	/* default_position */,
    unsigned int	/* bwidth */,
    unsigned int	/* fwidth */,
    unsigned int	/* fheight */,
    int			/* xadder */,
    int			/* yadder */,
    int*		/* x_return */,
    int*		/* y_return */,
    int*		/* width_return */,
    int*		/* height_return */
);

extern int XGetErrorDatabaseText(
    Display*		/* display */,
    const  char*	/* name */,
    const  char*	/* message */,
    const  char*	/* default_string */,
    char*		/* buffer_return */,
    int			/* length */
);

extern int XGetErrorText(
    Display*		/* display */,
    int			/* code */,
    char*		/* buffer_return */,
    int			/* length */
);

extern int  XGetFontProperty(
    XFontStruct*	/* font_struct */,
    Atom		/* atom */,
    unsigned long*	/* value_return */
);

extern int  XGetGCValues(
    Display*		/* display */,
    GC			/* gc */,
    unsigned long	/* valuemask */,
    XGCValues*		/* values_return */
);

extern int  XGetGeometry(
    Display*		/* display */,
    Drawable		/* d */,
    Window*		/* root_return */,
    int*		/* x_return */,
    int*		/* y_return */,
    unsigned int*	/* width_return */,
    unsigned int*	/* height_return */,
    unsigned int*	/* border_width_return */,
    unsigned int*	/* depth_return */
);

extern int  XGetIconName(
    Display*		/* display */,
    Window		/* w */,
    char**		/* icon_name_return */
);

extern int XGetInputFocus(
    Display*		/* display */,
    Window*		/* focus_return */,
    int*		/* revert_to_return */
);

extern int XGetKeyboardControl(
    Display*		/* display */,
    XKeyboardState*	/* values_return */
);

extern int XGetPointerControl(
    Display*		/* display */,
    int*		/* accel_numerator_return */,
    int*		/* accel_denominator_return */,
    int*		/* threshold_return */
);

extern int XGetPointerMapping(
    Display*		/* display */,
    unsigned char*	/* map_return */,
    int			/* nmap */
);

extern int XGetScreenSaver(
    Display*		/* display */,
    int*		/* timeout_return */,
    int*		/* interval_return */,
    int*		/* prefer_blanking_return */,
    int*		/* allow_exposures_return */
);

extern int  XGetTransientForHint(
    Display*		/* display */,
    Window		/* w */,
    Window*		/* prop_window_return */
);

extern int XGetWindowProperty(
    Display*		/* display */,
    Window		/* w */,
    Atom		/* property */,
    long		/* long_offset */,
    long		/* long_length */,
    int 		/* delete */,
    Atom		/* req_type */,
    Atom*		/* actual_type_return */,
    int*		/* actual_format_return */,
    unsigned long*	/* nitems_return */,
    unsigned long*	/* bytes_after_return */,
    unsigned char**	/* prop_return */
);

extern int  XGetWindowAttributes(
    Display*		/* display */,
    Window		/* w */,
    XWindowAttributes*	/* window_attributes_return */
);

extern int XGrabButton(
    Display*		/* display */,
    unsigned int	/* button */,
    unsigned int	/* modifiers */,
    Window		/* grab_window */,
    int 		/* owner_events */,
    unsigned int	/* event_mask */,
    int			/* pointer_mode */,
    int			/* keyboard_mode */,
    Window		/* confine_to */,
    Cursor		/* cursor */
);

extern int XGrabKey(
    Display*		/* display */,
    int			/* keycode */,
    unsigned int	/* modifiers */,
    Window		/* grab_window */,
    int 		/* owner_events */,
    int			/* pointer_mode */,
    int			/* keyboard_mode */
);

extern int XGrabKeyboard(
    Display*		/* display */,
    Window		/* grab_window */,
    int 		/* owner_events */,
    int			/* pointer_mode */,
    int			/* keyboard_mode */,
    Time		/* time */
);

extern int XGrabPointer(
    Display*		/* display */,
    Window		/* grab_window */,
    int 		/* owner_events */,
    unsigned int	/* event_mask */,
    int			/* pointer_mode */,
    int			/* keyboard_mode */,
    Window		/* confine_to */,
    Cursor		/* cursor */,
    Time		/* time */
);

extern int XGrabServer(
    Display*		/* display */
);

extern int XHeightMMOfScreen(
    Screen*		/* screen */
);

extern int XHeightOfScreen(
    Screen*		/* screen */
);

extern int XIfEvent(
    Display*		/* display */,
    XEvent*		/* event_return */,
    int  (*) (
	       Display*			/* display */,
               XEvent*			/* event */,
               XPointer			/* arg */
             )		/* predicate */,
    XPointer		/* arg */
);

extern int XImageByteOrder(
    Display*		/* display */
);

extern int XInstallColormap(
    Display*		/* display */,
    Colormap		/* colormap */
);

extern KeyCode XKeysymToKeycode(
    Display*		/* display */,
    KeySym		/* keysym */
);

extern int XKillClient(
    Display*		/* display */,
    XID			/* resource */
);

extern int  XLookupColor(
    Display*		/* display */,
    Colormap		/* colormap */,
    const  char*	/* color_name */,
    XColor*		/* exact_def_return */,
    XColor*		/* screen_def_return */
);

extern int XLowerWindow(
    Display*		/* display */,
    Window		/* w */
);

extern int XMapRaised(
    Display*		/* display */,
    Window		/* w */
);

extern int XMapSubwindows(
    Display*		/* display */,
    Window		/* w */
);

extern int XMapWindow(
    Display*		/* display */,
    Window		/* w */
);

extern int XMaskEvent(
    Display*		/* display */,
    long		/* event_mask */,
    XEvent*		/* event_return */
);

extern int XMaxCmapsOfScreen(
    Screen*		/* screen */
);

extern int XMinCmapsOfScreen(
    Screen*		/* screen */
);

extern int XMoveResizeWindow(
    Display*		/* display */,
    Window		/* w */,
    int			/* x */,
    int			/* y */,
    unsigned int	/* width */,
    unsigned int	/* height */
);

extern int XMoveWindow(
    Display*		/* display */,
    Window		/* w */,
    int			/* x */,
    int			/* y */
);

extern int XNextEvent(
    Display*		/* display */,
    XEvent*		/* event_return */
);

extern int XNoOp(
    Display*		/* display */
);

extern int  XParseColor(
    Display*		/* display */,
    Colormap		/* colormap */,
    const  char*	/* spec */,
    XColor*		/* exact_def_return */
);

extern int XParseGeometry(
    const  char*	/* parsestring */,
    int*		/* x_return */,
    int*		/* y_return */,
    unsigned int*	/* width_return */,
    unsigned int*	/* height_return */
);

extern int XPeekEvent(
    Display*		/* display */,
    XEvent*		/* event_return */
);

extern int XPeekIfEvent(
    Display*		/* display */,
    XEvent*		/* event_return */,
    int  (*) (
	       Display*		/* display */,
               XEvent*		/* event */,
               XPointer		/* arg */
             )		/* predicate */,
    XPointer		/* arg */
);

extern int XPending(
    Display*		/* display */
);

extern int XPlanesOfScreen(
    Screen*		/* screen */
);

extern int XProtocolRevision(
    Display*		/* display */
);

extern int XProtocolVersion(
    Display*		/* display */
);


extern int XPutBackEvent(
    Display*		/* display */,
    XEvent*		/* event */
);

extern int XPutImage(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    XImage*		/* image */,
    int			/* src_x */,
    int			/* src_y */,
    int			/* dest_x */,
    int			/* dest_y */,
    unsigned int	/* width */,
    unsigned int	/* height */
);

extern int XQLength(
    Display*		/* display */
);

extern int  XQueryBestCursor(
    Display*		/* display */,
    Drawable		/* d */,
    unsigned int        /* width */,
    unsigned int	/* height */,
    unsigned int*	/* width_return */,
    unsigned int*	/* height_return */
);

extern int  XQueryBestSize(
    Display*		/* display */,
    int			/* class */,
    Drawable		/* which_screen */,
    unsigned int	/* width */,
    unsigned int	/* height */,
    unsigned int*	/* width_return */,
    unsigned int*	/* height_return */
);

extern int  XQueryBestStipple(
    Display*		/* display */,
    Drawable		/* which_screen */,
    unsigned int	/* width */,
    unsigned int	/* height */,
    unsigned int*	/* width_return */,
    unsigned int*	/* height_return */
);

extern int  XQueryBestTile(
    Display*		/* display */,
    Drawable		/* which_screen */,
    unsigned int	/* width */,
    unsigned int	/* height */,
    unsigned int*	/* width_return */,
    unsigned int*	/* height_return */
);

extern int XQueryColor(
    Display*		/* display */,
    Colormap		/* colormap */,
    XColor*		/* def_in_out */
);

extern int XQueryColors(
    Display*		/* display */,
    Colormap		/* colormap */,
    XColor*		/* defs_in_out */,
    int			/* ncolors */
);

extern int  XQueryExtension(
    Display*		/* display */,
    const  char*	/* name */,
    int*		/* major_opcode_return */,
    int*		/* first_event_return */,
    int*		/* first_error_return */
);

extern int XQueryKeymap(
    Display*		/* display */,
    char [32]		/* keys_return */
);

extern int  XQueryPointer(
    Display*		/* display */,
    Window		/* w */,
    Window*		/* root_return */,
    Window*		/* child_return */,
    int*		/* root_x_return */,
    int*		/* root_y_return */,
    int*		/* win_x_return */,
    int*		/* win_y_return */,
    unsigned int*       /* mask_return */
);

extern int XQueryTextExtents(
    Display*		/* display */,
    XID			/* font_ID */,
    const  char*	/* string */,
    int			/* nchars */,
    int*		/* direction_return */,
    int*		/* font_ascent_return */,
    int*		/* font_descent_return */,
    XCharStruct*	/* overall_return */
);

extern int XQueryTextExtents16(
    Display*		/* display */,
    XID			/* font_ID */,
    const  XChar2b*	/* string */,
    int			/* nchars */,
    int*		/* direction_return */,
    int*		/* font_ascent_return */,
    int*		/* font_descent_return */,
    XCharStruct*	/* overall_return */
);

extern int  XQueryTree(
    Display*		/* display */,
    Window		/* w */,
    Window*		/* root_return */,
    Window*		/* parent_return */,
    Window**		/* children_return */,
    unsigned int*	/* nchildren_return */
);

extern int XRaiseWindow(
    Display*		/* display */,
    Window		/* w */
);

extern int XReadBitmapFile(
    Display*		/* display */,
    Drawable 		/* d */,
    const  char*	/* filename */,
    unsigned int*	/* width_return */,
    unsigned int*	/* height_return */,
    Pixmap*		/* bitmap_return */,
    int*		/* x_hot_return */,
    int*		/* y_hot_return */
);

extern int XReadBitmapFileData(
    const  char*	/* filename */,
    unsigned int*	/* width_return */,
    unsigned int*	/* height_return */,
    unsigned char**	/* data_return */,
    int*		/* x_hot_return */,
    int*		/* y_hot_return */
);

extern int XRebindKeysym(
    Display*		/* display */,
    KeySym		/* keysym */,
    KeySym*		/* list */,
    int			/* mod_count */,
    const  unsigned char*	/* string */,
    int			/* bytes_string */
);

extern int XRecolorCursor(
    Display*		/* display */,
    Cursor		/* cursor */,
    XColor*		/* foreground_color */,
    XColor*		/* background_color */
);

extern int XRefreshKeyboardMapping(
    XMappingEvent*	/* event_map */
);

extern int XRemoveFromSaveSet(
    Display*		/* display */,
    Window		/* w */
);

extern int XRemoveHost(
    Display*		/* display */,
    XHostAddress*	/* host */
);

extern int XRemoveHosts(
    Display*		/* display */,
    XHostAddress*	/* hosts */,
    int			/* num_hosts */
);

extern int XReparentWindow(
    Display*		/* display */,
    Window		/* w */,
    Window		/* parent */,
    int			/* x */,
    int			/* y */
);

extern int XResetScreenSaver(
    Display*		/* display */
);

extern int XResizeWindow(
    Display*		/* display */,
    Window		/* w */,
    unsigned int	/* width */,
    unsigned int	/* height */
);

extern int XRestackWindows(
    Display*		/* display */,
    Window*		/* windows */,
    int			/* nwindows */
);

extern int XRotateBuffers(
    Display*		/* display */,
    int			/* rotate */
);

extern int XRotateWindowProperties(
    Display*		/* display */,
    Window		/* w */,
    Atom*		/* properties */,
    int			/* num_prop */,
    int			/* npositions */
);

extern int XScreenCount(
    Display*		/* display */
);

extern int XSelectInput(
    Display*		/* display */,
    Window		/* w */,
    long		/* event_mask */
);

extern int  XSendEvent(
    Display*		/* display */,
    Window		/* w */,
    int 		/* propagate */,
    long		/* event_mask */,
    XEvent*		/* event_send */
);

extern int XSetAccessControl(
    Display*		/* display */,
    int			/* mode */
);

extern int XSetArcMode(
    Display*		/* display */,
    GC			/* gc */,
    int			/* arc_mode */
);

extern int XSetBackground(
    Display*		/* display */,
    GC			/* gc */,
    unsigned long	/* background */
);

extern int XSetClipMask(
    Display*		/* display */,
    GC			/* gc */,
    Pixmap		/* pixmap */
);

extern int XSetClipOrigin(
    Display*		/* display */,
    GC			/* gc */,
    int			/* clip_x_origin */,
    int			/* clip_y_origin */
);

extern int XSetClipRectangles(
    Display*		/* display */,
    GC			/* gc */,
    int			/* clip_x_origin */,
    int			/* clip_y_origin */,
    XRectangle*		/* rectangles */,
    int			/* n */,
    int			/* ordering */
);

extern int XSetCloseDownMode(
    Display*		/* display */,
    int			/* close_mode */
);

extern int XSetCommand(
    Display*		/* display */,
    Window		/* w */,
    char**		/* argv */,
    int			/* argc */
);

extern int XSetDashes(
    Display*		/* display */,
    GC			/* gc */,
    int			/* dash_offset */,
    const  char*	/* dash_list */,
    int			/* n */
);

extern int XSetFillRule(
    Display*		/* display */,
    GC			/* gc */,
    int			/* fill_rule */
);

extern int XSetFillStyle(
    Display*		/* display */,
    GC			/* gc */,
    int			/* fill_style */
);

extern int XSetFont(
    Display*		/* display */,
    GC			/* gc */,
    Font		/* font */
);

extern int XSetFontPath(
    Display*		/* display */,
    char**		/* directories */,
    int			/* ndirs */
);

extern int XSetForeground(
    Display*		/* display */,
    GC			/* gc */,
    unsigned long	/* foreground */
);

extern int XSetFunction(
    Display*		/* display */,
    GC			/* gc */,
    int			/* function */
);

extern int XSetGraphicsExposures(
    Display*		/* display */,
    GC			/* gc */,
    int 		/* graphics_exposures */
);

extern int XSetIconName(
    Display*		/* display */,
    Window		/* w */,
    const  char*	/* icon_name */
);

extern int XSetInputFocus(
    Display*		/* display */,
    Window		/* focus */,
    int			/* revert_to */,
    Time		/* time */
);

extern int XSetLineAttributes(
    Display*		/* display */,
    GC			/* gc */,
    unsigned int	/* line_width */,
    int			/* line_style */,
    int			/* cap_style */,
    int			/* join_style */
);

extern int XSetModifierMapping(
    Display*		/* display */,
    XModifierKeymap*	/* modmap */
);

extern int XSetPlaneMask(
    Display*		/* display */,
    GC			/* gc */,
    unsigned long	/* plane_mask */
);

extern int XSetPointerMapping(
    Display*		/* display */,
    const  unsigned char*	/* map */,
    int			/* nmap */
);

extern int XSetScreenSaver(
    Display*		/* display */,
    int			/* timeout */,
    int			/* interval */,
    int			/* prefer_blanking */,
    int			/* allow_exposures */
);

extern int XSetSelectionOwner(
    Display*		/* display */,
    Atom	        /* selection */,
    Window		/* owner */,
    Time		/* time */
);

extern int XSetState(
    Display*		/* display */,
    GC			/* gc */,
    unsigned long 	/* foreground */,
    unsigned long	/* background */,
    int			/* function */,
    unsigned long	/* plane_mask */
);

extern int XSetStipple(
    Display*		/* display */,
    GC			/* gc */,
    Pixmap		/* stipple */
);

extern int XSetSubwindowMode(
    Display*		/* display */,
    GC			/* gc */,
    int			/* subwindow_mode */
);

extern int XSetTSOrigin(
    Display*		/* display */,
    GC			/* gc */,
    int			/* ts_x_origin */,
    int			/* ts_y_origin */
);

extern int XSetTile(
    Display*		/* display */,
    GC			/* gc */,
    Pixmap		/* tile */
);

extern int XSetWindowBackground(
    Display*		/* display */,
    Window		/* w */,
    unsigned long	/* background_pixel */
);

extern int XSetWindowBackgroundPixmap(
    Display*		/* display */,
    Window		/* w */,
    Pixmap		/* background_pixmap */
);

extern int XSetWindowBorder(
    Display*		/* display */,
    Window		/* w */,
    unsigned long	/* border_pixel */
);

extern int XSetWindowBorderPixmap(
    Display*		/* display */,
    Window		/* w */,
    Pixmap		/* border_pixmap */
);

extern int XSetWindowBorderWidth(
    Display*		/* display */,
    Window		/* w */,
    unsigned int	/* width */
);

extern int XSetWindowColormap(
    Display*		/* display */,
    Window		/* w */,
    Colormap		/* colormap */
);

extern int XStoreBuffer(
    Display*		/* display */,
    const  char*	/* bytes */,
    int			/* nbytes */,
    int			/* buffer */
);

extern int XStoreBytes(
    Display*		/* display */,
    const  char*	/* bytes */,
    int			/* nbytes */
);

extern int XStoreColor(
    Display*		/* display */,
    Colormap		/* colormap */,
    XColor*		/* color */
);

extern int XStoreColors(
    Display*		/* display */,
    Colormap		/* colormap */,
    XColor*		/* color */,
    int			/* ncolors */
);

extern int XStoreName(
    Display*		/* display */,
    Window		/* w */,
    const  char*	/* window_name */
);

extern int XStoreNamedColor(
    Display*		/* display */,
    Colormap		/* colormap */,
    const  char*	/* color */,
    unsigned long	/* pixel */,
    int			/* flags */
);

extern int XSync(
    Display*		/* display */,
    int 		/* discard */
);

extern int XTextExtents(
    XFontStruct*	/* font_struct */,
    const  char*	/* string */,
    int			/* nchars */,
    int*		/* direction_return */,
    int*		/* font_ascent_return */,
    int*		/* font_descent_return */,
    XCharStruct*	/* overall_return */
);

extern int XTextExtents16(
    XFontStruct*	/* font_struct */,
    const  XChar2b*	/* string */,
    int			/* nchars */,
    int*		/* direction_return */,
    int*		/* font_ascent_return */,
    int*		/* font_descent_return */,
    XCharStruct*	/* overall_return */
);

extern int XTextWidth(
    XFontStruct*	/* font_struct */,
    const  char*	/* string */,
    int			/* count */
);

extern int XTextWidth16(
    XFontStruct*	/* font_struct */,
    const  XChar2b*	/* string */,
    int			/* count */
);

extern int  XTranslateCoordinates(
    Display*		/* display */,
    Window		/* src_w */,
    Window		/* dest_w */,
    int			/* src_x */,
    int			/* src_y */,
    int*		/* dest_x_return */,
    int*		/* dest_y_return */,
    Window*		/* child_return */
);

extern int XUndefineCursor(
    Display*		/* display */,
    Window		/* w */
);

extern int XUngrabButton(
    Display*		/* display */,
    unsigned int	/* button */,
    unsigned int	/* modifiers */,
    Window		/* grab_window */
);

extern int XUngrabKey(
    Display*		/* display */,
    int			/* keycode */,
    unsigned int	/* modifiers */,
    Window		/* grab_window */
);

extern int XUngrabKeyboard(
    Display*		/* display */,
    Time		/* time */
);

extern int XUngrabPointer(
    Display*		/* display */,
    Time		/* time */
);

extern int XUngrabServer(
    Display*		/* display */
);

extern int XUninstallColormap(
    Display*		/* display */,
    Colormap		/* colormap */
);

extern int XUnloadFont(
    Display*		/* display */,
    Font		/* font */
);

extern int XUnmapSubwindows(
    Display*		/* display */,
    Window		/* w */
);

extern int XUnmapWindow(
    Display*		/* display */,
    Window		/* w */
);

extern int XVendorRelease(
    Display*		/* display */
);

extern int XWarpPointer(
    Display*		/* display */,
    Window		/* src_w */,
    Window		/* dest_w */,
    int			/* src_x */,
    int			/* src_y */,
    unsigned int	/* src_width */,
    unsigned int	/* src_height */,
    int			/* dest_x */,
    int			/* dest_y */
);

extern int XWidthMMOfScreen(
    Screen*		/* screen */
);

extern int XWidthOfScreen(
    Screen*		/* screen */
);

extern int XWindowEvent(
    Display*		/* display */,
    Window		/* w */,
    long		/* event_mask */,
    XEvent*		/* event_return */
);

extern int XWriteBitmapFile(
    Display*		/* display */,
    const  char*	/* filename */,
    Pixmap		/* bitmap */,
    unsigned int	/* width */,
    unsigned int	/* height */,
    int			/* x_hot */,
    int			/* y_hot */
);

extern int  XSupportsLocale (void);

extern char *XSetLocaleModifiers(
    const char*		/* modifier_list */
);

extern XOM XOpenOM(
    Display*			/* display */,
    struct _XrmHashBucketRec*	/* rdb */,
    const  char*		/* res_name */,
    const  char*		/* res_class */
);

extern int  XCloseOM(
    XOM			/* om */
);

extern char *XSetOMValues(
    XOM			/* om */,
    ...
) __attribute__ ((__sentinel__( 0 ))) ;

extern char *XGetOMValues(
    XOM			/* om */,
    ...
) __attribute__ ((__sentinel__( 0 ))) ;

extern Display *XDisplayOfOM(
    XOM			/* om */
);

extern char *XLocaleOfOM(
    XOM			/* om */
);

extern XOC XCreateOC(
    XOM			/* om */,
    ...
) __attribute__ ((__sentinel__( 0 ))) ;

extern void XDestroyOC(
    XOC			/* oc */
);

extern XOM XOMOfOC(
    XOC			/* oc */
);

extern char *XSetOCValues(
    XOC			/* oc */,
    ...
) __attribute__ ((__sentinel__( 0 ))) ;

extern char *XGetOCValues(
    XOC			/* oc */,
    ...
) __attribute__ ((__sentinel__( 0 ))) ;

extern XFontSet XCreateFontSet(
    Display*		/* display */,
    const  char*	/* base_font_name_list */,
    char***		/* missing_charset_list */,
    int*		/* missing_charset_count */,
    char**		/* def_string */
);

extern void XFreeFontSet(
    Display*		/* display */,
    XFontSet		/* font_set */
);

extern int XFontsOfFontSet(
    XFontSet		/* font_set */,
    XFontStruct***	/* font_struct_list */,
    char***		/* font_name_list */
);

extern char *XBaseFontNameListOfFontSet(
    XFontSet		/* font_set */
);

extern char *XLocaleOfFontSet(
    XFontSet		/* font_set */
);

extern int  XContextDependentDrawing(
    XFontSet		/* font_set */
);

extern int  XDirectionalDependentDrawing(
    XFontSet		/* font_set */
);

extern int  XContextualDrawing(
    XFontSet		/* font_set */
);

extern XFontSetExtents *XExtentsOfFontSet(
    XFontSet		/* font_set */
);

extern int XmbTextEscapement(
    XFontSet		/* font_set */,
    const  char*	/* text */,
    int			/* bytes_text */
);

extern int XwcTextEscapement(
    XFontSet		/* font_set */,
    const  wchar_t*	/* text */,
    int			/* num_wchars */
);

extern int Xutf8TextEscapement(
    XFontSet		/* font_set */,
    const  char*	/* text */,
    int			/* bytes_text */
);

extern int XmbTextExtents(
    XFontSet		/* font_set */,
    const  char*	/* text */,
    int			/* bytes_text */,
    XRectangle*		/* overall_ink_return */,
    XRectangle*		/* overall_logical_return */
);

extern int XwcTextExtents(
    XFontSet		/* font_set */,
    const  wchar_t*	/* text */,
    int			/* num_wchars */,
    XRectangle*		/* overall_ink_return */,
    XRectangle*		/* overall_logical_return */
);

extern int Xutf8TextExtents(
    XFontSet		/* font_set */,
    const  char*	/* text */,
    int			/* bytes_text */,
    XRectangle*		/* overall_ink_return */,
    XRectangle*		/* overall_logical_return */
);

extern int  XmbTextPerCharExtents(
    XFontSet		/* font_set */,
    const  char*	/* text */,
    int			/* bytes_text */,
    XRectangle*		/* ink_extents_buffer */,
    XRectangle*		/* logical_extents_buffer */,
    int			/* buffer_size */,
    int*		/* num_chars */,
    XRectangle*		/* overall_ink_return */,
    XRectangle*		/* overall_logical_return */
);

extern int  XwcTextPerCharExtents(
    XFontSet		/* font_set */,
    const  wchar_t*	/* text */,
    int			/* num_wchars */,
    XRectangle*		/* ink_extents_buffer */,
    XRectangle*		/* logical_extents_buffer */,
    int			/* buffer_size */,
    int*		/* num_chars */,
    XRectangle*		/* overall_ink_return */,
    XRectangle*		/* overall_logical_return */
);

extern int  Xutf8TextPerCharExtents(
    XFontSet		/* font_set */,
    const  char*	/* text */,
    int			/* bytes_text */,
    XRectangle*		/* ink_extents_buffer */,
    XRectangle*		/* logical_extents_buffer */,
    int			/* buffer_size */,
    int*		/* num_chars */,
    XRectangle*		/* overall_ink_return */,
    XRectangle*		/* overall_logical_return */
);

extern void XmbDrawText(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    XmbTextItem*	/* text_items */,
    int			/* nitems */
);

extern void XwcDrawText(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    XwcTextItem*	/* text_items */,
    int			/* nitems */
);

extern void Xutf8DrawText(
    Display*		/* display */,
    Drawable		/* d */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    XmbTextItem*	/* text_items */,
    int			/* nitems */
);

extern void XmbDrawString(
    Display*		/* display */,
    Drawable		/* d */,
    XFontSet		/* font_set */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    const  char*	/* text */,
    int			/* bytes_text */
);

extern void XwcDrawString(
    Display*		/* display */,
    Drawable		/* d */,
    XFontSet		/* font_set */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    const  wchar_t*	/* text */,
    int			/* num_wchars */
);

extern void Xutf8DrawString(
    Display*		/* display */,
    Drawable		/* d */,
    XFontSet		/* font_set */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    const  char*	/* text */,
    int			/* bytes_text */
);

extern void XmbDrawImageString(
    Display*		/* display */,
    Drawable		/* d */,
    XFontSet		/* font_set */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    const  char*	/* text */,
    int			/* bytes_text */
);

extern void XwcDrawImageString(
    Display*		/* display */,
    Drawable		/* d */,
    XFontSet		/* font_set */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    const  wchar_t*	/* text */,
    int			/* num_wchars */
);

extern void Xutf8DrawImageString(
    Display*		/* display */,
    Drawable		/* d */,
    XFontSet		/* font_set */,
    GC			/* gc */,
    int			/* x */,
    int			/* y */,
    const  char*	/* text */,
    int			/* bytes_text */
);

extern XIM XOpenIM(
    Display*			/* dpy */,
    struct _XrmHashBucketRec*	/* rdb */,
    char*			/* res_name */,
    char*			/* res_class */
);

extern int  XCloseIM(
    XIM /* im */
);

extern char *XGetIMValues(
    XIM /* im */, ...
) __attribute__ ((__sentinel__( 0 ))) ;

extern char *XSetIMValues(
    XIM /* im */, ...
) __attribute__ ((__sentinel__( 0 ))) ;

extern Display *XDisplayOfIM(
    XIM /* im */
);

extern char *XLocaleOfIM(
    XIM /* im*/
);

extern XIC XCreateIC(
    XIM /* im */, ...
) __attribute__ ((__sentinel__( 0 ))) ;

extern void XDestroyIC(
    XIC /* ic */
);

extern void XSetICFocus(
    XIC /* ic */
);

extern void XUnsetICFocus(
    XIC /* ic */
);

extern wchar_t *XwcResetIC(
    XIC /* ic */
);

extern char *XmbResetIC(
    XIC /* ic */
);

extern char *Xutf8ResetIC(
    XIC /* ic */
);

extern char *XSetICValues(
    XIC /* ic */, ...
) __attribute__ ((__sentinel__( 0 ))) ;

extern char *XGetICValues(
    XIC /* ic */, ...
) __attribute__ ((__sentinel__( 0 ))) ;

extern XIM XIMOfIC(
    XIC /* ic */
);

extern int  XFilterEvent(
    XEvent*	/* event */,
    Window	/* window */
);

extern int XmbLookupString(
    XIC			/* ic */,
    XKeyPressedEvent*	/* event */,
    char*		/* buffer_return */,
    int			/* bytes_buffer */,
    KeySym*		/* keysym_return */,
    int *		/* status_return */
);

extern int XwcLookupString(
    XIC			/* ic */,
    XKeyPressedEvent*	/* event */,
    wchar_t*		/* buffer_return */,
    int			/* wchars_buffer */,
    KeySym*		/* keysym_return */,
    int *		/* status_return */
);

extern int Xutf8LookupString(
    XIC			/* ic */,
    XKeyPressedEvent*	/* event */,
    char*		/* buffer_return */,
    int			/* bytes_buffer */,
    KeySym*		/* keysym_return */,
    int *		/* status_return */
);

extern XVaNestedList XVaCreateNestedList(
    int /*unused*/, ...
) __attribute__ ((__sentinel__( 0 ))) ;

/* internal connections for IMs */

extern int  XRegisterIMInstantiateCallback(
    Display*			/* dpy */,
    struct _XrmHashBucketRec*	/* rdb */,
    char*			/* res_name */,
    char*			/* res_class */,
    XIDProc			/* callback */,
    XPointer			/* client_data */
);

extern int  XUnregisterIMInstantiateCallback(
    Display*			/* dpy */,
    struct _XrmHashBucketRec*	/* rdb */,
    char*			/* res_name */,
    char*			/* res_class */,
    XIDProc			/* callback */,
    XPointer			/* client_data */
);

typedef void (*XConnectionWatchProc)(
    Display*			/* dpy */,
    XPointer			/* client_data */,
    int				/* fd */,
    int 			/* opening */,	 /* open or close flag */
    XPointer*			/* watch_data */ /* open sets, close uses */
);


extern int  XInternalConnectionNumbers(
    Display*			/* dpy */,
    int**			/* fd_return */,
    int*			/* count_return */
);

extern void XProcessInternalConnection(
    Display*			/* dpy */,
    int				/* fd */
);

extern int  XAddConnectionWatch(
    Display*			/* dpy */,
    XConnectionWatchProc	/* callback */,
    XPointer			/* client_data */
);

extern void XRemoveConnectionWatch(
    Display*			/* dpy */,
    XConnectionWatchProc	/* callback */,
    XPointer			/* client_data */
);

extern void XSetAuthorization(
    char *			/* name */,
    int				/* namelen */,
    char *			/* data */,
    int				/* datalen */
);

extern int _Xmbtowc(
    wchar_t *			/* wstr */,




    char *			/* str */,
    int				/* len */

);

extern int _Xwctomb(
    char *			/* str */,
    wchar_t			/* wc */
);

extern int  XGetEventData(
    Display*			/* dpy */,
    XGenericEventCookie*	/* cookie*/
);

extern void XFreeEventData(
    Display*			/* dpy */,
    XGenericEventCookie*	/* cookie*/
);

 

/* _X11_XLIB_H_ */
# 99 "include/forms.h" 2

#include <X11/Xutil.h>
# 1 "/usr/include/X11/Xutil.h" 1 3

/***********************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.


Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/


#define _X11_XUTIL_H_

/* You must include <X11/Xlib.h> before including this file */
#include <X11/Xlib.h>
#include <X11/keysym.h>
# 1 "/usr/include/X11/keysym.h" 1 3
/***********************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.


Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/* default keysyms */
#define XK_MISCELLANY
#define XK_XKB_KEYS
#define XK_LATIN1
#define XK_LATIN2
#define XK_LATIN3
#define XK_LATIN4
#define XK_LATIN8
#define XK_LATIN9
#define XK_CAUCASUS
#define XK_GREEK
#define XK_KATAKANA
#define XK_ARABIC
#define XK_CYRILLIC
#define XK_HEBREW
#define XK_THAI
#define XK_KOREAN
#define XK_ARMENIAN
#define XK_GEORGIAN
#define XK_VIETNAMESE
#define XK_CURRENCY
#define XK_MATHEMATICAL
#define XK_BRAILLE
#define XK_SINHALA

#include <X11/keysymdef.h>
# 1 "/usr/include/X11/keysymdef.h" 1 3
/***********************************************************
Copyright 1987, 1994, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.


Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/*
 * The "X11 Window System Protocol" standard defines in Appendix A the
 * keysym codes. These 29-bit integer values identify characters or
 * functions associated with each key (e.g., via the visible
 * engraving) of a keyboard layout. This file assigns mnemonic macro
 * names for these keysyms.
 *
 * This file is also compiled (by src/util/makekeys.c in libX11) into
 * hash tables that can be accessed with X11 library functions such as
 * XStringToKeysym() and XKeysymToString().
 *
 * Where a keysym corresponds one-to-one to an ISO 10646 / Unicode
 * character, this is noted in a comment that provides both the U+xxxx
 * Unicode position, as well as the official Unicode name of the
 * character.
 *
 * Where the correspondence is either not one-to-one or semantically
 * unclear, the Unicode position and name are enclosed in
 * parentheses. Such legacy keysyms should be considered deprecated
 * and are not recommended for use in future keyboard mappings.
 *
 * For any future extension of the keysyms with characters already
 * found in ISO 10646 / Unicode, the following algorithm shall be
 * used. The new keysym code position will simply be the character's
 * Unicode number plus 0x01000000. The keysym values in the range
 * 0x01000100 to 0x0110ffff are reserved to represent Unicode
 * characters in the range U+0100 to U+10FFFF.
 * 
 * While most newer Unicode-based X11 clients do already accept
 * Unicode-mapped keysyms in the range 0x01000100 to 0x0110ffff, it
 * will remain necessary for clients -- in the interest of
 * compatibility with existing servers -- to also understand the
 * existing legacy keysym values in the range 0x0100 to 0x20ff.
 *
 * Where several mnemonic names are defined for the same keysym in this
 * file, all but the first one listed should be considered deprecated.
 *
 * Mnemonic names for keysyms are defined in this file with lines
 * that match one of these Perl regular expressions:
 *
 *    /^\#define XK_([a-zA-Z_0-9]+)\s+0x([0-9a-f]+)\s*\/\* U+([0-9A-F]{4,6}) (.*) \*\/\s*$/
 *    /^\#define XK_([a-zA-Z_0-9]+)\s+0x([0-9a-f]+)\s*\/\*\(U+([0-9A-F]{4,6}) (.*)\)\*\/\s*$/
 *    /^\#define XK_([a-zA-Z_0-9]+)\s+0x([0-9a-f]+)\s*(\/\*\s*(.*)\s*\*\/)?\s*$/
 *
 * Before adding new keysyms, please do consider the following: In
 * addition to the keysym names defined in this file, the
 * XStringToKeysym() and XKeysymToString() functions will also handle
 * any keysym string of the form "U0020" to "U007E" and "U00A0" to
 * "U10FFFF" for all possible Unicode characters. In other words,
 * every possible Unicode character has already a keysym string
 * defined algorithmically, even if it is not listed here. Therefore,
 * defining an additional keysym macro is only necessary where a
 * non-hexadecimal mnemonic name is needed, or where the new keysym
 * does not represent any existing Unicode character.
 *
 * When adding new keysyms to this file, do not forget to also update the
 * following:
 *
 *   - the mappings in src/KeyBind.c in the repo
 *     git://anongit.freedesktop.org/xorg/lib/libX11
 *
 *   - the protocol specification in specs/XProtocol/X11.keysyms
 *     in the repo git://anongit.freedesktop.org/xorg/doc/xorg-docs
 *
 */

#define XK_VoidSymbol                  0xffffff  /* Void symbol */


/*
 * TTY function keys, cleverly chosen to map to ASCII, for convenience of
 * programming, but could have been arbitrary (at the cost of lookup
 * tables in client code).
 */

#define XK_BackSpace                     0xff08  /* Back space, back char */
#define XK_Tab                           0xff09
#define XK_Linefeed                      0xff0a  /* Linefeed, LF */
#define XK_Clear                         0xff0b
#define XK_Return                        0xff0d  /* Return, enter */
#define XK_Pause                         0xff13  /* Pause, hold */
#define XK_Scroll_Lock                   0xff14
#define XK_Sys_Req                       0xff15
#define XK_Escape                        0xff1b
#define XK_Delete                        0xffff  /* Delete, rubout */



/* International & multi-key character composition */

#define XK_Multi_key                     0xff20  /* Multi-key character compose */
#define XK_Codeinput                     0xff37
#define XK_SingleCandidate               0xff3c
#define XK_MultipleCandidate             0xff3d
#define XK_PreviousCandidate             0xff3e

/* Japanese keyboard support */

#define XK_Kanji                         0xff21  /* Kanji, Kanji convert */
#define XK_Muhenkan                      0xff22  /* Cancel Conversion */
#define XK_Henkan_Mode                   0xff23  /* Start/Stop Conversion */
#define XK_Henkan                        0xff23  /* Alias for Henkan_Mode */
#define XK_Romaji                        0xff24  /* to Romaji */
#define XK_Hiragana                      0xff25  /* to Hiragana */
#define XK_Katakana                      0xff26  /* to Katakana */
#define XK_Hiragana_Katakana             0xff27  /* Hiragana/Katakana toggle */
#define XK_Zenkaku                       0xff28  /* to Zenkaku */
#define XK_Hankaku                       0xff29  /* to Hankaku */
#define XK_Zenkaku_Hankaku               0xff2a  /* Zenkaku/Hankaku toggle */
#define XK_Touroku                       0xff2b  /* Add to Dictionary */
#define XK_Massyo                        0xff2c  /* Delete from Dictionary */
#define XK_Kana_Lock                     0xff2d  /* Kana Lock */
#define XK_Kana_Shift                    0xff2e  /* Kana Shift */
#define XK_Eisu_Shift                    0xff2f  /* Alphanumeric Shift */
#define XK_Eisu_toggle                   0xff30  /* Alphanumeric toggle */
#define XK_Kanji_Bangou                  0xff37  /* Codeinput */
#define XK_Zen_Koho                      0xff3d  /* Multiple/All Candidate(s) */
#define XK_Mae_Koho                      0xff3e  /* Previous Candidate */

/* 0xff31 thru 0xff3f are under XK_KOREAN */

/* Cursor control & motion */

#define XK_Home                          0xff50
#define XK_Left                          0xff51  /* Move left, left arrow */
#define XK_Up                            0xff52  /* Move up, up arrow */
#define XK_Right                         0xff53  /* Move right, right arrow */
#define XK_Down                          0xff54  /* Move down, down arrow */
#define XK_Prior                         0xff55  /* Prior, previous */
#define XK_Page_Up                       0xff55
#define XK_Next                          0xff56  /* Next */
#define XK_Page_Down                     0xff56
#define XK_End                           0xff57  /* EOL */
#define XK_Begin                         0xff58  /* BOL */


/* Misc functions */

#define XK_Select                        0xff60  /* Select, mark */
#define XK_Print                         0xff61
#define XK_Execute                       0xff62  /* Execute, run, do */
#define XK_Insert                        0xff63  /* Insert, insert here */
#define XK_Undo                          0xff65
#define XK_Redo                          0xff66  /* Redo, again */
#define XK_Menu                          0xff67
#define XK_Find                          0xff68  /* Find, search */
#define XK_Cancel                        0xff69  /* Cancel, stop, abort, exit */
#define XK_Help                          0xff6a  /* Help */
#define XK_Break                         0xff6b
#define XK_Mode_switch                   0xff7e  /* Character set switch */
#define XK_script_switch                 0xff7e  /* Alias for mode_switch */
#define XK_Num_Lock                      0xff7f

/* Keypad functions, keypad numbers cleverly chosen to map to ASCII */

#define XK_KP_Space                      0xff80  /* Space */
#define XK_KP_Tab                        0xff89
#define XK_KP_Enter                      0xff8d  /* Enter */
#define XK_KP_F1                         0xff91  /* PF1, KP_A, ... */
#define XK_KP_F2                         0xff92
#define XK_KP_F3                         0xff93
#define XK_KP_F4                         0xff94
#define XK_KP_Home                       0xff95
#define XK_KP_Left                       0xff96
#define XK_KP_Up                         0xff97
#define XK_KP_Right                      0xff98
#define XK_KP_Down                       0xff99
#define XK_KP_Prior                      0xff9a
#define XK_KP_Page_Up                    0xff9a
#define XK_KP_Next                       0xff9b
#define XK_KP_Page_Down                  0xff9b
#define XK_KP_End                        0xff9c
#define XK_KP_Begin                      0xff9d
#define XK_KP_Insert                     0xff9e
#define XK_KP_Delete                     0xff9f
#define XK_KP_Equal                      0xffbd  /* Equals */
#define XK_KP_Multiply                   0xffaa
#define XK_KP_Add                        0xffab
#define XK_KP_Separator                  0xffac  /* Separator, often comma */
#define XK_KP_Subtract                   0xffad
#define XK_KP_Decimal                    0xffae
#define XK_KP_Divide                     0xffaf

#define XK_KP_0                          0xffb0
#define XK_KP_1                          0xffb1
#define XK_KP_2                          0xffb2
#define XK_KP_3                          0xffb3
#define XK_KP_4                          0xffb4
#define XK_KP_5                          0xffb5
#define XK_KP_6                          0xffb6
#define XK_KP_7                          0xffb7
#define XK_KP_8                          0xffb8
#define XK_KP_9                          0xffb9



/*
 * Auxiliary functions; note the duplicate definitions for left and right
 * function keys;  Sun keyboards and a few other manufacturers have such
 * function key groups on the left and/or right sides of the keyboard.
 * We've not found a keyboard with more than 35 function keys total.
 */

#define XK_F1                            0xffbe
#define XK_F2                            0xffbf
#define XK_F3                            0xffc0
#define XK_F4                            0xffc1
#define XK_F5                            0xffc2
#define XK_F6                            0xffc3
#define XK_F7                            0xffc4
#define XK_F8                            0xffc5
#define XK_F9                            0xffc6
#define XK_F10                           0xffc7
#define XK_F11                           0xffc8
#define XK_L1                            0xffc8
#define XK_F12                           0xffc9
#define XK_L2                            0xffc9
#define XK_F13                           0xffca
#define XK_L3                            0xffca
#define XK_F14                           0xffcb
#define XK_L4                            0xffcb
#define XK_F15                           0xffcc
#define XK_L5                            0xffcc
#define XK_F16                           0xffcd
#define XK_L6                            0xffcd
#define XK_F17                           0xffce
#define XK_L7                            0xffce
#define XK_F18                           0xffcf
#define XK_L8                            0xffcf
#define XK_F19                           0xffd0
#define XK_L9                            0xffd0
#define XK_F20                           0xffd1
#define XK_L10                           0xffd1
#define XK_F21                           0xffd2
#define XK_R1                            0xffd2
#define XK_F22                           0xffd3
#define XK_R2                            0xffd3
#define XK_F23                           0xffd4
#define XK_R3                            0xffd4
#define XK_F24                           0xffd5
#define XK_R4                            0xffd5
#define XK_F25                           0xffd6
#define XK_R5                            0xffd6
#define XK_F26                           0xffd7
#define XK_R6                            0xffd7
#define XK_F27                           0xffd8
#define XK_R7                            0xffd8
#define XK_F28                           0xffd9
#define XK_R8                            0xffd9
#define XK_F29                           0xffda
#define XK_R9                            0xffda
#define XK_F30                           0xffdb
#define XK_R10                           0xffdb
#define XK_F31                           0xffdc
#define XK_R11                           0xffdc
#define XK_F32                           0xffdd
#define XK_R12                           0xffdd
#define XK_F33                           0xffde
#define XK_R13                           0xffde
#define XK_F34                           0xffdf
#define XK_R14                           0xffdf
#define XK_F35                           0xffe0
#define XK_R15                           0xffe0

/* Modifiers */

#define XK_Shift_L                       0xffe1  /* Left shift */
#define XK_Shift_R                       0xffe2  /* Right shift */
#define XK_Control_L                     0xffe3  /* Left control */
#define XK_Control_R                     0xffe4  /* Right control */
#define XK_Caps_Lock                     0xffe5  /* Caps lock */
#define XK_Shift_Lock                    0xffe6  /* Shift lock */

#define XK_Meta_L                        0xffe7  /* Left meta */
#define XK_Meta_R                        0xffe8  /* Right meta */
#define XK_Alt_L                         0xffe9  /* Left alt */
#define XK_Alt_R                         0xffea  /* Right alt */
#define XK_Super_L                       0xffeb  /* Left super */
#define XK_Super_R                       0xffec  /* Right super */
#define XK_Hyper_L                       0xffed  /* Left hyper */
#define XK_Hyper_R                       0xffee  /* Right hyper */
/* XK_MISCELLANY */

/*
 * Keyboard (XKB) Extension function and modifier keys
 * (from Appendix C of "The X Keyboard Extension: Protocol Specification")
 * Byte 3 = 0xfe
 */


#define XK_ISO_Lock                      0xfe01
#define XK_ISO_Level2_Latch              0xfe02
#define XK_ISO_Level3_Shift              0xfe03
#define XK_ISO_Level3_Latch              0xfe04
#define XK_ISO_Level3_Lock               0xfe05
#define XK_ISO_Level5_Shift              0xfe11
#define XK_ISO_Level5_Latch              0xfe12
#define XK_ISO_Level5_Lock               0xfe13
#define XK_ISO_Group_Shift               0xff7e  /* Alias for mode_switch */
#define XK_ISO_Group_Latch               0xfe06
#define XK_ISO_Group_Lock                0xfe07
#define XK_ISO_Next_Group                0xfe08
#define XK_ISO_Next_Group_Lock           0xfe09
#define XK_ISO_Prev_Group                0xfe0a
#define XK_ISO_Prev_Group_Lock           0xfe0b
#define XK_ISO_First_Group               0xfe0c
#define XK_ISO_First_Group_Lock          0xfe0d
#define XK_ISO_Last_Group                0xfe0e
#define XK_ISO_Last_Group_Lock           0xfe0f

#define XK_ISO_Left_Tab                  0xfe20
#define XK_ISO_Move_Line_Up              0xfe21
#define XK_ISO_Move_Line_Down            0xfe22
#define XK_ISO_Partial_Line_Up           0xfe23
#define XK_ISO_Partial_Line_Down         0xfe24
#define XK_ISO_Partial_Space_Left        0xfe25
#define XK_ISO_Partial_Space_Right       0xfe26
#define XK_ISO_Set_Margin_Left           0xfe27
#define XK_ISO_Set_Margin_Right          0xfe28
#define XK_ISO_Release_Margin_Left       0xfe29
#define XK_ISO_Release_Margin_Right      0xfe2a
#define XK_ISO_Release_Both_Margins      0xfe2b
#define XK_ISO_Fast_Cursor_Left          0xfe2c
#define XK_ISO_Fast_Cursor_Right         0xfe2d
#define XK_ISO_Fast_Cursor_Up            0xfe2e
#define XK_ISO_Fast_Cursor_Down          0xfe2f
#define XK_ISO_Continuous_Underline      0xfe30
#define XK_ISO_Discontinuous_Underline   0xfe31
#define XK_ISO_Emphasize                 0xfe32
#define XK_ISO_Center_Object             0xfe33
#define XK_ISO_Enter                     0xfe34

#define XK_dead_grave                    0xfe50
#define XK_dead_acute                    0xfe51
#define XK_dead_circumflex               0xfe52
#define XK_dead_tilde                    0xfe53
#define XK_dead_perispomeni              0xfe53  /* alias for dead_tilde */
#define XK_dead_macron                   0xfe54
#define XK_dead_breve                    0xfe55
#define XK_dead_abovedot                 0xfe56
#define XK_dead_diaeresis                0xfe57
#define XK_dead_abovering                0xfe58
#define XK_dead_doubleacute              0xfe59
#define XK_dead_caron                    0xfe5a
#define XK_dead_cedilla                  0xfe5b
#define XK_dead_ogonek                   0xfe5c
#define XK_dead_iota                     0xfe5d
#define XK_dead_voiced_sound             0xfe5e
#define XK_dead_semivoiced_sound         0xfe5f
#define XK_dead_belowdot                 0xfe60
#define XK_dead_hook                     0xfe61
#define XK_dead_horn                     0xfe62
#define XK_dead_stroke                   0xfe63
#define XK_dead_abovecomma               0xfe64
#define XK_dead_psili                    0xfe64  /* alias for dead_abovecomma */
#define XK_dead_abovereversedcomma       0xfe65
#define XK_dead_dasia                    0xfe65  /* alias for dead_abovereversedcomma */
#define XK_dead_doublegrave              0xfe66
#define XK_dead_belowring                0xfe67
#define XK_dead_belowmacron              0xfe68
#define XK_dead_belowcircumflex          0xfe69
#define XK_dead_belowtilde               0xfe6a
#define XK_dead_belowbreve               0xfe6b
#define XK_dead_belowdiaeresis           0xfe6c
#define XK_dead_invertedbreve            0xfe6d
#define XK_dead_belowcomma               0xfe6e
#define XK_dead_currency                 0xfe6f

/* dead vowels for universal syllable entry */
#define XK_dead_a                        0xfe80
#define XK_dead_A                        0xfe81
#define XK_dead_e                        0xfe82
#define XK_dead_E                        0xfe83
#define XK_dead_i                        0xfe84
#define XK_dead_I                        0xfe85
#define XK_dead_o                        0xfe86
#define XK_dead_O                        0xfe87
#define XK_dead_u                        0xfe88
#define XK_dead_U                        0xfe89
#define XK_dead_small_schwa              0xfe8a
#define XK_dead_capital_schwa            0xfe8b

#define XK_First_Virtual_Screen          0xfed0
#define XK_Prev_Virtual_Screen           0xfed1
#define XK_Next_Virtual_Screen           0xfed2
#define XK_Last_Virtual_Screen           0xfed4
#define XK_Terminate_Server              0xfed5

#define XK_AccessX_Enable                0xfe70
#define XK_AccessX_Feedback_Enable       0xfe71
#define XK_RepeatKeys_Enable             0xfe72
#define XK_SlowKeys_Enable               0xfe73
#define XK_BounceKeys_Enable             0xfe74
#define XK_StickyKeys_Enable             0xfe75
#define XK_MouseKeys_Enable              0xfe76
#define XK_MouseKeys_Accel_Enable        0xfe77
#define XK_Overlay1_Enable               0xfe78
#define XK_Overlay2_Enable               0xfe79
#define XK_AudibleBell_Enable            0xfe7a

#define XK_Pointer_Left                  0xfee0
#define XK_Pointer_Right                 0xfee1
#define XK_Pointer_Up                    0xfee2
#define XK_Pointer_Down                  0xfee3
#define XK_Pointer_UpLeft                0xfee4
#define XK_Pointer_UpRight               0xfee5
#define XK_Pointer_DownLeft              0xfee6
#define XK_Pointer_DownRight             0xfee7
#define XK_Pointer_Button_Dflt           0xfee8
#define XK_Pointer_Button1               0xfee9
#define XK_Pointer_Button2               0xfeea
#define XK_Pointer_Button3               0xfeeb
#define XK_Pointer_Button4               0xfeec
#define XK_Pointer_Button5               0xfeed
#define XK_Pointer_DblClick_Dflt         0xfeee
#define XK_Pointer_DblClick1             0xfeef
#define XK_Pointer_DblClick2             0xfef0
#define XK_Pointer_DblClick3             0xfef1
#define XK_Pointer_DblClick4             0xfef2
#define XK_Pointer_DblClick5             0xfef3
#define XK_Pointer_Drag_Dflt             0xfef4
#define XK_Pointer_Drag1                 0xfef5
#define XK_Pointer_Drag2                 0xfef6
#define XK_Pointer_Drag3                 0xfef7
#define XK_Pointer_Drag4                 0xfef8
#define XK_Pointer_Drag5                 0xfefd

#define XK_Pointer_EnableKeys            0xfef9
#define XK_Pointer_Accelerate            0xfefa
#define XK_Pointer_DfltBtnNext           0xfefb
#define XK_Pointer_DfltBtnPrev           0xfefc

/* XK_XKB_KEYS */

/*
 * 3270 Terminal Keys
 * Byte 3 = 0xfd
 */

/* XK_3270 */
# 519 "/usr/include/X11/keysymdef.h" 3


/*
 * Latin 1
 * (ISO/IEC 8859-1 = Unicode U+0020..U+00FF)
 * Byte 3 = 0
 */

#define XK_space                         0x0020  /* U+0020 SPACE */
#define XK_exclam                        0x0021  /* U+0021 EXCLAMATION MARK */
#define XK_quotedbl                      0x0022  /* U+0022 QUOTATION MARK */
#define XK_numbersign                    0x0023  /* U+0023 NUMBER SIGN */
#define XK_dollar                        0x0024  /* U+0024 DOLLAR SIGN */
#define XK_percent                       0x0025  /* U+0025 PERCENT SIGN */
#define XK_ampersand                     0x0026  /* U+0026 AMPERSAND */
#define XK_apostrophe                    0x0027  /* U+0027 APOSTROPHE */
#define XK_quoteright                    0x0027  /* deprecated */
#define XK_parenleft                     0x0028  /* U+0028 LEFT PARENTHESIS */
#define XK_parenright                    0x0029  /* U+0029 RIGHT PARENTHESIS */
#define XK_asterisk                      0x002a  /* U+002A ASTERISK */
#define XK_plus                          0x002b  /* U+002B PLUS SIGN */
#define XK_comma                         0x002c  /* U+002C COMMA */
#define XK_minus                         0x002d  /* U+002D HYPHEN-MINUS */
#define XK_period                        0x002e  /* U+002E FULL STOP */
#define XK_slash                         0x002f  /* U+002F SOLIDUS */
#define XK_0                             0x0030  /* U+0030 DIGIT ZERO */
#define XK_1                             0x0031  /* U+0031 DIGIT ONE */
#define XK_2                             0x0032  /* U+0032 DIGIT TWO */
#define XK_3                             0x0033  /* U+0033 DIGIT THREE */
#define XK_4                             0x0034  /* U+0034 DIGIT FOUR */
#define XK_5                             0x0035  /* U+0035 DIGIT FIVE */
#define XK_6                             0x0036  /* U+0036 DIGIT SIX */
#define XK_7                             0x0037  /* U+0037 DIGIT SEVEN */
#define XK_8                             0x0038  /* U+0038 DIGIT EIGHT */
#define XK_9                             0x0039  /* U+0039 DIGIT NINE */
#define XK_colon                         0x003a  /* U+003A COLON */
#define XK_semicolon                     0x003b  /* U+003B SEMICOLON */
#define XK_less                          0x003c  /* U+003C LESS-THAN SIGN */
#define XK_equal                         0x003d  /* U+003D EQUALS SIGN */
#define XK_greater                       0x003e  /* U+003E GREATER-THAN SIGN */
#define XK_question                      0x003f  /* U+003F QUESTION MARK */
#define XK_at                            0x0040  /* U+0040 COMMERCIAL AT */
#define XK_A                             0x0041  /* U+0041 LATIN CAPITAL LETTER A */
#define XK_B                             0x0042  /* U+0042 LATIN CAPITAL LETTER B */
#define XK_C                             0x0043  /* U+0043 LATIN CAPITAL LETTER C */
#define XK_D                             0x0044  /* U+0044 LATIN CAPITAL LETTER D */
#define XK_E                             0x0045  /* U+0045 LATIN CAPITAL LETTER E */
#define XK_F                             0x0046  /* U+0046 LATIN CAPITAL LETTER F */
#define XK_G                             0x0047  /* U+0047 LATIN CAPITAL LETTER G */
#define XK_H                             0x0048  /* U+0048 LATIN CAPITAL LETTER H */
#define XK_I                             0x0049  /* U+0049 LATIN CAPITAL LETTER I */
#define XK_J                             0x004a  /* U+004A LATIN CAPITAL LETTER J */
#define XK_K                             0x004b  /* U+004B LATIN CAPITAL LETTER K */
#define XK_L                             0x004c  /* U+004C LATIN CAPITAL LETTER L */
#define XK_M                             0x004d  /* U+004D LATIN CAPITAL LETTER M */
#define XK_N                             0x004e  /* U+004E LATIN CAPITAL LETTER N */
#define XK_O                             0x004f  /* U+004F LATIN CAPITAL LETTER O */
#define XK_P                             0x0050  /* U+0050 LATIN CAPITAL LETTER P */
#define XK_Q                             0x0051  /* U+0051 LATIN CAPITAL LETTER Q */
#define XK_R                             0x0052  /* U+0052 LATIN CAPITAL LETTER R */
#define XK_S                             0x0053  /* U+0053 LATIN CAPITAL LETTER S */
#define XK_T                             0x0054  /* U+0054 LATIN CAPITAL LETTER T */
#define XK_U                             0x0055  /* U+0055 LATIN CAPITAL LETTER U */
#define XK_V                             0x0056  /* U+0056 LATIN CAPITAL LETTER V */
#define XK_W                             0x0057  /* U+0057 LATIN CAPITAL LETTER W */
#define XK_X                             0x0058  /* U+0058 LATIN CAPITAL LETTER X */
#define XK_Y                             0x0059  /* U+0059 LATIN CAPITAL LETTER Y */
#define XK_Z                             0x005a  /* U+005A LATIN CAPITAL LETTER Z */
#define XK_bracketleft                   0x005b  /* U+005B LEFT SQUARE BRACKET */
#define XK_backslash                     0x005c  /* U+005C REVERSE SOLIDUS */
#define XK_bracketright                  0x005d  /* U+005D RIGHT SQUARE BRACKET */
#define XK_asciicircum                   0x005e  /* U+005E CIRCUMFLEX ACCENT */
#define XK_underscore                    0x005f  /* U+005F LOW LINE */
#define XK_grave                         0x0060  /* U+0060 GRAVE ACCENT */
#define XK_quoteleft                     0x0060  /* deprecated */
#define XK_a                             0x0061  /* U+0061 LATIN SMALL LETTER A */
#define XK_b                             0x0062  /* U+0062 LATIN SMALL LETTER B */
#define XK_c                             0x0063  /* U+0063 LATIN SMALL LETTER C */
#define XK_d                             0x0064  /* U+0064 LATIN SMALL LETTER D */
#define XK_e                             0x0065  /* U+0065 LATIN SMALL LETTER E */
#define XK_f                             0x0066  /* U+0066 LATIN SMALL LETTER F */
#define XK_g                             0x0067  /* U+0067 LATIN SMALL LETTER G */
#define XK_h                             0x0068  /* U+0068 LATIN SMALL LETTER H */
#define XK_i                             0x0069  /* U+0069 LATIN SMALL LETTER I */
#define XK_j                             0x006a  /* U+006A LATIN SMALL LETTER J */
#define XK_k                             0x006b  /* U+006B LATIN SMALL LETTER K */
#define XK_l                             0x006c  /* U+006C LATIN SMALL LETTER L */
#define XK_m                             0x006d  /* U+006D LATIN SMALL LETTER M */
#define XK_n                             0x006e  /* U+006E LATIN SMALL LETTER N */
#define XK_o                             0x006f  /* U+006F LATIN SMALL LETTER O */
#define XK_p                             0x0070  /* U+0070 LATIN SMALL LETTER P */
#define XK_q                             0x0071  /* U+0071 LATIN SMALL LETTER Q */
#define XK_r                             0x0072  /* U+0072 LATIN SMALL LETTER R */
#define XK_s                             0x0073  /* U+0073 LATIN SMALL LETTER S */
#define XK_t                             0x0074  /* U+0074 LATIN SMALL LETTER T */
#define XK_u                             0x0075  /* U+0075 LATIN SMALL LETTER U */
#define XK_v                             0x0076  /* U+0076 LATIN SMALL LETTER V */
#define XK_w                             0x0077  /* U+0077 LATIN SMALL LETTER W */
#define XK_x                             0x0078  /* U+0078 LATIN SMALL LETTER X */
#define XK_y                             0x0079  /* U+0079 LATIN SMALL LETTER Y */
#define XK_z                             0x007a  /* U+007A LATIN SMALL LETTER Z */
#define XK_braceleft                     0x007b  /* U+007B LEFT CURLY BRACKET */
#define XK_bar                           0x007c  /* U+007C VERTICAL LINE */
#define XK_braceright                    0x007d  /* U+007D RIGHT CURLY BRACKET */
#define XK_asciitilde                    0x007e  /* U+007E TILDE */

#define XK_nobreakspace                  0x00a0  /* U+00A0 NO-BREAK SPACE */
#define XK_exclamdown                    0x00a1  /* U+00A1 INVERTED EXCLAMATION MARK */
#define XK_cent                          0x00a2  /* U+00A2 CENT SIGN */
#define XK_sterling                      0x00a3  /* U+00A3 POUND SIGN */
#define XK_currency                      0x00a4  /* U+00A4 CURRENCY SIGN */
#define XK_yen                           0x00a5  /* U+00A5 YEN SIGN */
#define XK_brokenbar                     0x00a6  /* U+00A6 BROKEN BAR */
#define XK_section                       0x00a7  /* U+00A7 SECTION SIGN */
#define XK_diaeresis                     0x00a8  /* U+00A8 DIAERESIS */
#define XK_copyright                     0x00a9  /* U+00A9 COPYRIGHT SIGN */
#define XK_ordfeminine                   0x00aa  /* U+00AA FEMININE ORDINAL INDICATOR */
#define XK_guillemotleft                 0x00ab  /* U+00AB LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */
#define XK_notsign                       0x00ac  /* U+00AC NOT SIGN */
#define XK_hyphen                        0x00ad  /* U+00AD SOFT HYPHEN */
#define XK_registered                    0x00ae  /* U+00AE REGISTERED SIGN */
#define XK_macron                        0x00af  /* U+00AF MACRON */
#define XK_degree                        0x00b0  /* U+00B0 DEGREE SIGN */
#define XK_plusminus                     0x00b1  /* U+00B1 PLUS-MINUS SIGN */
#define XK_twosuperior                   0x00b2  /* U+00B2 SUPERSCRIPT TWO */
#define XK_threesuperior                 0x00b3  /* U+00B3 SUPERSCRIPT THREE */
#define XK_acute                         0x00b4  /* U+00B4 ACUTE ACCENT */
#define XK_mu                            0x00b5  /* U+00B5 MICRO SIGN */
#define XK_paragraph                     0x00b6  /* U+00B6 PILCROW SIGN */
#define XK_periodcentered                0x00b7  /* U+00B7 MIDDLE DOT */
#define XK_cedilla                       0x00b8  /* U+00B8 CEDILLA */
#define XK_onesuperior                   0x00b9  /* U+00B9 SUPERSCRIPT ONE */
#define XK_masculine                     0x00ba  /* U+00BA MASCULINE ORDINAL INDICATOR */
#define XK_guillemotright                0x00bb  /* U+00BB RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */
#define XK_onequarter                    0x00bc  /* U+00BC VULGAR FRACTION ONE QUARTER */
#define XK_onehalf                       0x00bd  /* U+00BD VULGAR FRACTION ONE HALF */
#define XK_threequarters                 0x00be  /* U+00BE VULGAR FRACTION THREE QUARTERS */
#define XK_questiondown                  0x00bf  /* U+00BF INVERTED QUESTION MARK */
#define XK_Agrave                        0x00c0  /* U+00C0 LATIN CAPITAL LETTER A WITH GRAVE */
#define XK_Aacute                        0x00c1  /* U+00C1 LATIN CAPITAL LETTER A WITH ACUTE */
#define XK_Acircumflex                   0x00c2  /* U+00C2 LATIN CAPITAL LETTER A WITH CIRCUMFLEX */
#define XK_Atilde                        0x00c3  /* U+00C3 LATIN CAPITAL LETTER A WITH TILDE */
#define XK_Adiaeresis                    0x00c4  /* U+00C4 LATIN CAPITAL LETTER A WITH DIAERESIS */
#define XK_Aring                         0x00c5  /* U+00C5 LATIN CAPITAL LETTER A WITH RING ABOVE */
#define XK_AE                            0x00c6  /* U+00C6 LATIN CAPITAL LETTER AE */
#define XK_Ccedilla                      0x00c7  /* U+00C7 LATIN CAPITAL LETTER C WITH CEDILLA */
#define XK_Egrave                        0x00c8  /* U+00C8 LATIN CAPITAL LETTER E WITH GRAVE */
#define XK_Eacute                        0x00c9  /* U+00C9 LATIN CAPITAL LETTER E WITH ACUTE */
#define XK_Ecircumflex                   0x00ca  /* U+00CA LATIN CAPITAL LETTER E WITH CIRCUMFLEX */
#define XK_Ediaeresis                    0x00cb  /* U+00CB LATIN CAPITAL LETTER E WITH DIAERESIS */
#define XK_Igrave                        0x00cc  /* U+00CC LATIN CAPITAL LETTER I WITH GRAVE */
#define XK_Iacute                        0x00cd  /* U+00CD LATIN CAPITAL LETTER I WITH ACUTE */
#define XK_Icircumflex                   0x00ce  /* U+00CE LATIN CAPITAL LETTER I WITH CIRCUMFLEX */
#define XK_Idiaeresis                    0x00cf  /* U+00CF LATIN CAPITAL LETTER I WITH DIAERESIS */
#define XK_ETH                           0x00d0  /* U+00D0 LATIN CAPITAL LETTER ETH */
#define XK_Eth                           0x00d0  /* deprecated */
#define XK_Ntilde                        0x00d1  /* U+00D1 LATIN CAPITAL LETTER N WITH TILDE */
#define XK_Ograve                        0x00d2  /* U+00D2 LATIN CAPITAL LETTER O WITH GRAVE */
#define XK_Oacute                        0x00d3  /* U+00D3 LATIN CAPITAL LETTER O WITH ACUTE */
#define XK_Ocircumflex                   0x00d4  /* U+00D4 LATIN CAPITAL LETTER O WITH CIRCUMFLEX */
#define XK_Otilde                        0x00d5  /* U+00D5 LATIN CAPITAL LETTER O WITH TILDE */
#define XK_Odiaeresis                    0x00d6  /* U+00D6 LATIN CAPITAL LETTER O WITH DIAERESIS */
#define XK_multiply                      0x00d7  /* U+00D7 MULTIPLICATION SIGN */
#define XK_Oslash                        0x00d8  /* U+00D8 LATIN CAPITAL LETTER O WITH STROKE */
#define XK_Ooblique                      0x00d8  /* U+00D8 LATIN CAPITAL LETTER O WITH STROKE */
#define XK_Ugrave                        0x00d9  /* U+00D9 LATIN CAPITAL LETTER U WITH GRAVE */
#define XK_Uacute                        0x00da  /* U+00DA LATIN CAPITAL LETTER U WITH ACUTE */
#define XK_Ucircumflex                   0x00db  /* U+00DB LATIN CAPITAL LETTER U WITH CIRCUMFLEX */
#define XK_Udiaeresis                    0x00dc  /* U+00DC LATIN CAPITAL LETTER U WITH DIAERESIS */
#define XK_Yacute                        0x00dd  /* U+00DD LATIN CAPITAL LETTER Y WITH ACUTE */
#define XK_THORN                         0x00de  /* U+00DE LATIN CAPITAL LETTER THORN */
#define XK_Thorn                         0x00de  /* deprecated */
#define XK_ssharp                        0x00df  /* U+00DF LATIN SMALL LETTER SHARP S */
#define XK_agrave                        0x00e0  /* U+00E0 LATIN SMALL LETTER A WITH GRAVE */
#define XK_aacute                        0x00e1  /* U+00E1 LATIN SMALL LETTER A WITH ACUTE */
#define XK_acircumflex                   0x00e2  /* U+00E2 LATIN SMALL LETTER A WITH CIRCUMFLEX */
#define XK_atilde                        0x00e3  /* U+00E3 LATIN SMALL LETTER A WITH TILDE */
#define XK_adiaeresis                    0x00e4  /* U+00E4 LATIN SMALL LETTER A WITH DIAERESIS */
#define XK_aring                         0x00e5  /* U+00E5 LATIN SMALL LETTER A WITH RING ABOVE */
#define XK_ae                            0x00e6  /* U+00E6 LATIN SMALL LETTER AE */
#define XK_ccedilla                      0x00e7  /* U+00E7 LATIN SMALL LETTER C WITH CEDILLA */
#define XK_egrave                        0x00e8  /* U+00E8 LATIN SMALL LETTER E WITH GRAVE */
#define XK_eacute                        0x00e9  /* U+00E9 LATIN SMALL LETTER E WITH ACUTE */
#define XK_ecircumflex                   0x00ea  /* U+00EA LATIN SMALL LETTER E WITH CIRCUMFLEX */
#define XK_ediaeresis                    0x00eb  /* U+00EB LATIN SMALL LETTER E WITH DIAERESIS */
#define XK_igrave                        0x00ec  /* U+00EC LATIN SMALL LETTER I WITH GRAVE */
#define XK_iacute                        0x00ed  /* U+00ED LATIN SMALL LETTER I WITH ACUTE */
#define XK_icircumflex                   0x00ee  /* U+00EE LATIN SMALL LETTER I WITH CIRCUMFLEX */
#define XK_idiaeresis                    0x00ef  /* U+00EF LATIN SMALL LETTER I WITH DIAERESIS */
#define XK_eth                           0x00f0  /* U+00F0 LATIN SMALL LETTER ETH */
#define XK_ntilde                        0x00f1  /* U+00F1 LATIN SMALL LETTER N WITH TILDE */
#define XK_ograve                        0x00f2  /* U+00F2 LATIN SMALL LETTER O WITH GRAVE */
#define XK_oacute                        0x00f3  /* U+00F3 LATIN SMALL LETTER O WITH ACUTE */
#define XK_ocircumflex                   0x00f4  /* U+00F4 LATIN SMALL LETTER O WITH CIRCUMFLEX */
#define XK_otilde                        0x00f5  /* U+00F5 LATIN SMALL LETTER O WITH TILDE */
#define XK_odiaeresis                    0x00f6  /* U+00F6 LATIN SMALL LETTER O WITH DIAERESIS */
#define XK_division                      0x00f7  /* U+00F7 DIVISION SIGN */
#define XK_oslash                        0x00f8  /* U+00F8 LATIN SMALL LETTER O WITH STROKE */
#define XK_ooblique                      0x00f8  /* U+00F8 LATIN SMALL LETTER O WITH STROKE */
#define XK_ugrave                        0x00f9  /* U+00F9 LATIN SMALL LETTER U WITH GRAVE */
#define XK_uacute                        0x00fa  /* U+00FA LATIN SMALL LETTER U WITH ACUTE */
#define XK_ucircumflex                   0x00fb  /* U+00FB LATIN SMALL LETTER U WITH CIRCUMFLEX */
#define XK_udiaeresis                    0x00fc  /* U+00FC LATIN SMALL LETTER U WITH DIAERESIS */
#define XK_yacute                        0x00fd  /* U+00FD LATIN SMALL LETTER Y WITH ACUTE */
#define XK_thorn                         0x00fe  /* U+00FE LATIN SMALL LETTER THORN */
#define XK_ydiaeresis                    0x00ff  /* U+00FF LATIN SMALL LETTER Y WITH DIAERESIS */
/* XK_LATIN1 */

/*
 * Latin 2
 * Byte 3 = 1
 */


#define XK_Aogonek                       0x01a1  /* U+0104 LATIN CAPITAL LETTER A WITH OGONEK */
#define XK_breve                         0x01a2  /* U+02D8 BREVE */
#define XK_Lstroke                       0x01a3  /* U+0141 LATIN CAPITAL LETTER L WITH STROKE */
#define XK_Lcaron                        0x01a5  /* U+013D LATIN CAPITAL LETTER L WITH CARON */
#define XK_Sacute                        0x01a6  /* U+015A LATIN CAPITAL LETTER S WITH ACUTE */
#define XK_Scaron                        0x01a9  /* U+0160 LATIN CAPITAL LETTER S WITH CARON */
#define XK_Scedilla                      0x01aa  /* U+015E LATIN CAPITAL LETTER S WITH CEDILLA */
#define XK_Tcaron                        0x01ab  /* U+0164 LATIN CAPITAL LETTER T WITH CARON */
#define XK_Zacute                        0x01ac  /* U+0179 LATIN CAPITAL LETTER Z WITH ACUTE */
#define XK_Zcaron                        0x01ae  /* U+017D LATIN CAPITAL LETTER Z WITH CARON */
#define XK_Zabovedot                     0x01af  /* U+017B LATIN CAPITAL LETTER Z WITH DOT ABOVE */
#define XK_aogonek                       0x01b1  /* U+0105 LATIN SMALL LETTER A WITH OGONEK */
#define XK_ogonek                        0x01b2  /* U+02DB OGONEK */
#define XK_lstroke                       0x01b3  /* U+0142 LATIN SMALL LETTER L WITH STROKE */
#define XK_lcaron                        0x01b5  /* U+013E LATIN SMALL LETTER L WITH CARON */
#define XK_sacute                        0x01b6  /* U+015B LATIN SMALL LETTER S WITH ACUTE */
#define XK_caron                         0x01b7  /* U+02C7 CARON */
#define XK_scaron                        0x01b9  /* U+0161 LATIN SMALL LETTER S WITH CARON */
#define XK_scedilla                      0x01ba  /* U+015F LATIN SMALL LETTER S WITH CEDILLA */
#define XK_tcaron                        0x01bb  /* U+0165 LATIN SMALL LETTER T WITH CARON */
#define XK_zacute                        0x01bc  /* U+017A LATIN SMALL LETTER Z WITH ACUTE */
#define XK_doubleacute                   0x01bd  /* U+02DD DOUBLE ACUTE ACCENT */
#define XK_zcaron                        0x01be  /* U+017E LATIN SMALL LETTER Z WITH CARON */
#define XK_zabovedot                     0x01bf  /* U+017C LATIN SMALL LETTER Z WITH DOT ABOVE */
#define XK_Racute                        0x01c0  /* U+0154 LATIN CAPITAL LETTER R WITH ACUTE */
#define XK_Abreve                        0x01c3  /* U+0102 LATIN CAPITAL LETTER A WITH BREVE */
#define XK_Lacute                        0x01c5  /* U+0139 LATIN CAPITAL LETTER L WITH ACUTE */
#define XK_Cacute                        0x01c6  /* U+0106 LATIN CAPITAL LETTER C WITH ACUTE */
#define XK_Ccaron                        0x01c8  /* U+010C LATIN CAPITAL LETTER C WITH CARON */
#define XK_Eogonek                       0x01ca  /* U+0118 LATIN CAPITAL LETTER E WITH OGONEK */
#define XK_Ecaron                        0x01cc  /* U+011A LATIN CAPITAL LETTER E WITH CARON */
#define XK_Dcaron                        0x01cf  /* U+010E LATIN CAPITAL LETTER D WITH CARON */
#define XK_Dstroke                       0x01d0  /* U+0110 LATIN CAPITAL LETTER D WITH STROKE */
#define XK_Nacute                        0x01d1  /* U+0143 LATIN CAPITAL LETTER N WITH ACUTE */
#define XK_Ncaron                        0x01d2  /* U+0147 LATIN CAPITAL LETTER N WITH CARON */
#define XK_Odoubleacute                  0x01d5  /* U+0150 LATIN CAPITAL LETTER O WITH DOUBLE ACUTE */
#define XK_Rcaron                        0x01d8  /* U+0158 LATIN CAPITAL LETTER R WITH CARON */
#define XK_Uring                         0x01d9  /* U+016E LATIN CAPITAL LETTER U WITH RING ABOVE */
#define XK_Udoubleacute                  0x01db  /* U+0170 LATIN CAPITAL LETTER U WITH DOUBLE ACUTE */
#define XK_Tcedilla                      0x01de  /* U+0162 LATIN CAPITAL LETTER T WITH CEDILLA */
#define XK_racute                        0x01e0  /* U+0155 LATIN SMALL LETTER R WITH ACUTE */
#define XK_abreve                        0x01e3  /* U+0103 LATIN SMALL LETTER A WITH BREVE */
#define XK_lacute                        0x01e5  /* U+013A LATIN SMALL LETTER L WITH ACUTE */
#define XK_cacute                        0x01e6  /* U+0107 LATIN SMALL LETTER C WITH ACUTE */
#define XK_ccaron                        0x01e8  /* U+010D LATIN SMALL LETTER C WITH CARON */
#define XK_eogonek                       0x01ea  /* U+0119 LATIN SMALL LETTER E WITH OGONEK */
#define XK_ecaron                        0x01ec  /* U+011B LATIN SMALL LETTER E WITH CARON */
#define XK_dcaron                        0x01ef  /* U+010F LATIN SMALL LETTER D WITH CARON */
#define XK_dstroke                       0x01f0  /* U+0111 LATIN SMALL LETTER D WITH STROKE */
#define XK_nacute                        0x01f1  /* U+0144 LATIN SMALL LETTER N WITH ACUTE */
#define XK_ncaron                        0x01f2  /* U+0148 LATIN SMALL LETTER N WITH CARON */
#define XK_odoubleacute                  0x01f5  /* U+0151 LATIN SMALL LETTER O WITH DOUBLE ACUTE */
#define XK_rcaron                        0x01f8  /* U+0159 LATIN SMALL LETTER R WITH CARON */
#define XK_uring                         0x01f9  /* U+016F LATIN SMALL LETTER U WITH RING ABOVE */
#define XK_udoubleacute                  0x01fb  /* U+0171 LATIN SMALL LETTER U WITH DOUBLE ACUTE */
#define XK_tcedilla                      0x01fe  /* U+0163 LATIN SMALL LETTER T WITH CEDILLA */
#define XK_abovedot                      0x01ff  /* U+02D9 DOT ABOVE */
/* XK_LATIN2 */

/*
 * Latin 3
 * Byte 3 = 2
 */


#define XK_Hstroke                       0x02a1  /* U+0126 LATIN CAPITAL LETTER H WITH STROKE */
#define XK_Hcircumflex                   0x02a6  /* U+0124 LATIN CAPITAL LETTER H WITH CIRCUMFLEX */
#define XK_Iabovedot                     0x02a9  /* U+0130 LATIN CAPITAL LETTER I WITH DOT ABOVE */
#define XK_Gbreve                        0x02ab  /* U+011E LATIN CAPITAL LETTER G WITH BREVE */
#define XK_Jcircumflex                   0x02ac  /* U+0134 LATIN CAPITAL LETTER J WITH CIRCUMFLEX */
#define XK_hstroke                       0x02b1  /* U+0127 LATIN SMALL LETTER H WITH STROKE */
#define XK_hcircumflex                   0x02b6  /* U+0125 LATIN SMALL LETTER H WITH CIRCUMFLEX */
#define XK_idotless                      0x02b9  /* U+0131 LATIN SMALL LETTER DOTLESS I */
#define XK_gbreve                        0x02bb  /* U+011F LATIN SMALL LETTER G WITH BREVE */
#define XK_jcircumflex                   0x02bc  /* U+0135 LATIN SMALL LETTER J WITH CIRCUMFLEX */
#define XK_Cabovedot                     0x02c5  /* U+010A LATIN CAPITAL LETTER C WITH DOT ABOVE */
#define XK_Ccircumflex                   0x02c6  /* U+0108 LATIN CAPITAL LETTER C WITH CIRCUMFLEX */
#define XK_Gabovedot                     0x02d5  /* U+0120 LATIN CAPITAL LETTER G WITH DOT ABOVE */
#define XK_Gcircumflex                   0x02d8  /* U+011C LATIN CAPITAL LETTER G WITH CIRCUMFLEX */
#define XK_Ubreve                        0x02dd  /* U+016C LATIN CAPITAL LETTER U WITH BREVE */
#define XK_Scircumflex                   0x02de  /* U+015C LATIN CAPITAL LETTER S WITH CIRCUMFLEX */
#define XK_cabovedot                     0x02e5  /* U+010B LATIN SMALL LETTER C WITH DOT ABOVE */
#define XK_ccircumflex                   0x02e6  /* U+0109 LATIN SMALL LETTER C WITH CIRCUMFLEX */
#define XK_gabovedot                     0x02f5  /* U+0121 LATIN SMALL LETTER G WITH DOT ABOVE */
#define XK_gcircumflex                   0x02f8  /* U+011D LATIN SMALL LETTER G WITH CIRCUMFLEX */
#define XK_ubreve                        0x02fd  /* U+016D LATIN SMALL LETTER U WITH BREVE */
#define XK_scircumflex                   0x02fe  /* U+015D LATIN SMALL LETTER S WITH CIRCUMFLEX */
/* XK_LATIN3 */


/*
 * Latin 4
 * Byte 3 = 3
 */


#define XK_kra                           0x03a2  /* U+0138 LATIN SMALL LETTER KRA */
#define XK_kappa                         0x03a2  /* deprecated */
#define XK_Rcedilla                      0x03a3  /* U+0156 LATIN CAPITAL LETTER R WITH CEDILLA */
#define XK_Itilde                        0x03a5  /* U+0128 LATIN CAPITAL LETTER I WITH TILDE */
#define XK_Lcedilla                      0x03a6  /* U+013B LATIN CAPITAL LETTER L WITH CEDILLA */
#define XK_Emacron                       0x03aa  /* U+0112 LATIN CAPITAL LETTER E WITH MACRON */
#define XK_Gcedilla                      0x03ab  /* U+0122 LATIN CAPITAL LETTER G WITH CEDILLA */
#define XK_Tslash                        0x03ac  /* U+0166 LATIN CAPITAL LETTER T WITH STROKE */
#define XK_rcedilla                      0x03b3  /* U+0157 LATIN SMALL LETTER R WITH CEDILLA */
#define XK_itilde                        0x03b5  /* U+0129 LATIN SMALL LETTER I WITH TILDE */
#define XK_lcedilla                      0x03b6  /* U+013C LATIN SMALL LETTER L WITH CEDILLA */
#define XK_emacron                       0x03ba  /* U+0113 LATIN SMALL LETTER E WITH MACRON */
#define XK_gcedilla                      0x03bb  /* U+0123 LATIN SMALL LETTER G WITH CEDILLA */
#define XK_tslash                        0x03bc  /* U+0167 LATIN SMALL LETTER T WITH STROKE */
#define XK_ENG                           0x03bd  /* U+014A LATIN CAPITAL LETTER ENG */
#define XK_eng                           0x03bf  /* U+014B LATIN SMALL LETTER ENG */
#define XK_Amacron                       0x03c0  /* U+0100 LATIN CAPITAL LETTER A WITH MACRON */
#define XK_Iogonek                       0x03c7  /* U+012E LATIN CAPITAL LETTER I WITH OGONEK */
#define XK_Eabovedot                     0x03cc  /* U+0116 LATIN CAPITAL LETTER E WITH DOT ABOVE */
#define XK_Imacron                       0x03cf  /* U+012A LATIN CAPITAL LETTER I WITH MACRON */
#define XK_Ncedilla                      0x03d1  /* U+0145 LATIN CAPITAL LETTER N WITH CEDILLA */
#define XK_Omacron                       0x03d2  /* U+014C LATIN CAPITAL LETTER O WITH MACRON */
#define XK_Kcedilla                      0x03d3  /* U+0136 LATIN CAPITAL LETTER K WITH CEDILLA */
#define XK_Uogonek                       0x03d9  /* U+0172 LATIN CAPITAL LETTER U WITH OGONEK */
#define XK_Utilde                        0x03dd  /* U+0168 LATIN CAPITAL LETTER U WITH TILDE */
#define XK_Umacron                       0x03de  /* U+016A LATIN CAPITAL LETTER U WITH MACRON */
#define XK_amacron                       0x03e0  /* U+0101 LATIN SMALL LETTER A WITH MACRON */
#define XK_iogonek                       0x03e7  /* U+012F LATIN SMALL LETTER I WITH OGONEK */
#define XK_eabovedot                     0x03ec  /* U+0117 LATIN SMALL LETTER E WITH DOT ABOVE */
#define XK_imacron                       0x03ef  /* U+012B LATIN SMALL LETTER I WITH MACRON */
#define XK_ncedilla                      0x03f1  /* U+0146 LATIN SMALL LETTER N WITH CEDILLA */
#define XK_omacron                       0x03f2  /* U+014D LATIN SMALL LETTER O WITH MACRON */
#define XK_kcedilla                      0x03f3  /* U+0137 LATIN SMALL LETTER K WITH CEDILLA */
#define XK_uogonek                       0x03f9  /* U+0173 LATIN SMALL LETTER U WITH OGONEK */
#define XK_utilde                        0x03fd  /* U+0169 LATIN SMALL LETTER U WITH TILDE */
#define XK_umacron                       0x03fe  /* U+016B LATIN SMALL LETTER U WITH MACRON */
/* XK_LATIN4 */

/*
 * Latin 8
 */

#define XK_Wcircumflex                0x1000174  /* U+0174 LATIN CAPITAL LETTER W WITH CIRCUMFLEX */
#define XK_wcircumflex                0x1000175  /* U+0175 LATIN SMALL LETTER W WITH CIRCUMFLEX */
#define XK_Ycircumflex                0x1000176  /* U+0176 LATIN CAPITAL LETTER Y WITH CIRCUMFLEX */
#define XK_ycircumflex                0x1000177  /* U+0177 LATIN SMALL LETTER Y WITH CIRCUMFLEX */
#define XK_Babovedot                  0x1001e02  /* U+1E02 LATIN CAPITAL LETTER B WITH DOT ABOVE */
#define XK_babovedot                  0x1001e03  /* U+1E03 LATIN SMALL LETTER B WITH DOT ABOVE */
#define XK_Dabovedot                  0x1001e0a  /* U+1E0A LATIN CAPITAL LETTER D WITH DOT ABOVE */
#define XK_dabovedot                  0x1001e0b  /* U+1E0B LATIN SMALL LETTER D WITH DOT ABOVE */
#define XK_Fabovedot                  0x1001e1e  /* U+1E1E LATIN CAPITAL LETTER F WITH DOT ABOVE */
#define XK_fabovedot                  0x1001e1f  /* U+1E1F LATIN SMALL LETTER F WITH DOT ABOVE */
#define XK_Mabovedot                  0x1001e40  /* U+1E40 LATIN CAPITAL LETTER M WITH DOT ABOVE */
#define XK_mabovedot                  0x1001e41  /* U+1E41 LATIN SMALL LETTER M WITH DOT ABOVE */
#define XK_Pabovedot                  0x1001e56  /* U+1E56 LATIN CAPITAL LETTER P WITH DOT ABOVE */
#define XK_pabovedot                  0x1001e57  /* U+1E57 LATIN SMALL LETTER P WITH DOT ABOVE */
#define XK_Sabovedot                  0x1001e60  /* U+1E60 LATIN CAPITAL LETTER S WITH DOT ABOVE */
#define XK_sabovedot                  0x1001e61  /* U+1E61 LATIN SMALL LETTER S WITH DOT ABOVE */
#define XK_Tabovedot                  0x1001e6a  /* U+1E6A LATIN CAPITAL LETTER T WITH DOT ABOVE */
#define XK_tabovedot                  0x1001e6b  /* U+1E6B LATIN SMALL LETTER T WITH DOT ABOVE */
#define XK_Wgrave                     0x1001e80  /* U+1E80 LATIN CAPITAL LETTER W WITH GRAVE */
#define XK_wgrave                     0x1001e81  /* U+1E81 LATIN SMALL LETTER W WITH GRAVE */
#define XK_Wacute                     0x1001e82  /* U+1E82 LATIN CAPITAL LETTER W WITH ACUTE */
#define XK_wacute                     0x1001e83  /* U+1E83 LATIN SMALL LETTER W WITH ACUTE */
#define XK_Wdiaeresis                 0x1001e84  /* U+1E84 LATIN CAPITAL LETTER W WITH DIAERESIS */
#define XK_wdiaeresis                 0x1001e85  /* U+1E85 LATIN SMALL LETTER W WITH DIAERESIS */
#define XK_Ygrave                     0x1001ef2  /* U+1EF2 LATIN CAPITAL LETTER Y WITH GRAVE */
#define XK_ygrave                     0x1001ef3  /* U+1EF3 LATIN SMALL LETTER Y WITH GRAVE */
/* XK_LATIN8 */

/*
 * Latin 9
 * Byte 3 = 0x13
 */


#define XK_OE                            0x13bc  /* U+0152 LATIN CAPITAL LIGATURE OE */
#define XK_oe                            0x13bd  /* U+0153 LATIN SMALL LIGATURE OE */
#define XK_Ydiaeresis                    0x13be  /* U+0178 LATIN CAPITAL LETTER Y WITH DIAERESIS */
/* XK_LATIN9 */

/*
 * Katakana
 * Byte 3 = 4
 */


#define XK_overline                      0x047e  /* U+203E OVERLINE */
#define XK_kana_fullstop                 0x04a1  /* U+3002 IDEOGRAPHIC FULL STOP */
#define XK_kana_openingbracket           0x04a2  /* U+300C LEFT CORNER BRACKET */
#define XK_kana_closingbracket           0x04a3  /* U+300D RIGHT CORNER BRACKET */
#define XK_kana_comma                    0x04a4  /* U+3001 IDEOGRAPHIC COMMA */
#define XK_kana_conjunctive              0x04a5  /* U+30FB KATAKANA MIDDLE DOT */
#define XK_kana_middledot                0x04a5  /* deprecated */
#define XK_kana_WO                       0x04a6  /* U+30F2 KATAKANA LETTER WO */
#define XK_kana_a                        0x04a7  /* U+30A1 KATAKANA LETTER SMALL A */
#define XK_kana_i                        0x04a8  /* U+30A3 KATAKANA LETTER SMALL I */
#define XK_kana_u                        0x04a9  /* U+30A5 KATAKANA LETTER SMALL U */
#define XK_kana_e                        0x04aa  /* U+30A7 KATAKANA LETTER SMALL E */
#define XK_kana_o                        0x04ab  /* U+30A9 KATAKANA LETTER SMALL O */
#define XK_kana_ya                       0x04ac  /* U+30E3 KATAKANA LETTER SMALL YA */
#define XK_kana_yu                       0x04ad  /* U+30E5 KATAKANA LETTER SMALL YU */
#define XK_kana_yo                       0x04ae  /* U+30E7 KATAKANA LETTER SMALL YO */
#define XK_kana_tsu                      0x04af  /* U+30C3 KATAKANA LETTER SMALL TU */
#define XK_kana_tu                       0x04af  /* deprecated */
#define XK_prolongedsound                0x04b0  /* U+30FC KATAKANA-HIRAGANA PROLONGED SOUND MARK */
#define XK_kana_A                        0x04b1  /* U+30A2 KATAKANA LETTER A */
#define XK_kana_I                        0x04b2  /* U+30A4 KATAKANA LETTER I */
#define XK_kana_U                        0x04b3  /* U+30A6 KATAKANA LETTER U */
#define XK_kana_E                        0x04b4  /* U+30A8 KATAKANA LETTER E */
#define XK_kana_O                        0x04b5  /* U+30AA KATAKANA LETTER O */
#define XK_kana_KA                       0x04b6  /* U+30AB KATAKANA LETTER KA */
#define XK_kana_KI                       0x04b7  /* U+30AD KATAKANA LETTER KI */
#define XK_kana_KU                       0x04b8  /* U+30AF KATAKANA LETTER KU */
#define XK_kana_KE                       0x04b9  /* U+30B1 KATAKANA LETTER KE */
#define XK_kana_KO                       0x04ba  /* U+30B3 KATAKANA LETTER KO */
#define XK_kana_SA                       0x04bb  /* U+30B5 KATAKANA LETTER SA */
#define XK_kana_SHI                      0x04bc  /* U+30B7 KATAKANA LETTER SI */
#define XK_kana_SU                       0x04bd  /* U+30B9 KATAKANA LETTER SU */
#define XK_kana_SE                       0x04be  /* U+30BB KATAKANA LETTER SE */
#define XK_kana_SO                       0x04bf  /* U+30BD KATAKANA LETTER SO */
#define XK_kana_TA                       0x04c0  /* U+30BF KATAKANA LETTER TA */
#define XK_kana_CHI                      0x04c1  /* U+30C1 KATAKANA LETTER TI */
#define XK_kana_TI                       0x04c1  /* deprecated */
#define XK_kana_TSU                      0x04c2  /* U+30C4 KATAKANA LETTER TU */
#define XK_kana_TU                       0x04c2  /* deprecated */
#define XK_kana_TE                       0x04c3  /* U+30C6 KATAKANA LETTER TE */
#define XK_kana_TO                       0x04c4  /* U+30C8 KATAKANA LETTER TO */
#define XK_kana_NA                       0x04c5  /* U+30CA KATAKANA LETTER NA */
#define XK_kana_NI                       0x04c6  /* U+30CB KATAKANA LETTER NI */
#define XK_kana_NU                       0x04c7  /* U+30CC KATAKANA LETTER NU */
#define XK_kana_NE                       0x04c8  /* U+30CD KATAKANA LETTER NE */
#define XK_kana_NO                       0x04c9  /* U+30CE KATAKANA LETTER NO */
#define XK_kana_HA                       0x04ca  /* U+30CF KATAKANA LETTER HA */
#define XK_kana_HI                       0x04cb  /* U+30D2 KATAKANA LETTER HI */
#define XK_kana_FU                       0x04cc  /* U+30D5 KATAKANA LETTER HU */
#define XK_kana_HU                       0x04cc  /* deprecated */
#define XK_kana_HE                       0x04cd  /* U+30D8 KATAKANA LETTER HE */
#define XK_kana_HO                       0x04ce  /* U+30DB KATAKANA LETTER HO */
#define XK_kana_MA                       0x04cf  /* U+30DE KATAKANA LETTER MA */
#define XK_kana_MI                       0x04d0  /* U+30DF KATAKANA LETTER MI */
#define XK_kana_MU                       0x04d1  /* U+30E0 KATAKANA LETTER MU */
#define XK_kana_ME                       0x04d2  /* U+30E1 KATAKANA LETTER ME */
#define XK_kana_MO                       0x04d3  /* U+30E2 KATAKANA LETTER MO */
#define XK_kana_YA                       0x04d4  /* U+30E4 KATAKANA LETTER YA */
#define XK_kana_YU                       0x04d5  /* U+30E6 KATAKANA LETTER YU */
#define XK_kana_YO                       0x04d6  /* U+30E8 KATAKANA LETTER YO */
#define XK_kana_RA                       0x04d7  /* U+30E9 KATAKANA LETTER RA */
#define XK_kana_RI                       0x04d8  /* U+30EA KATAKANA LETTER RI */
#define XK_kana_RU                       0x04d9  /* U+30EB KATAKANA LETTER RU */
#define XK_kana_RE                       0x04da  /* U+30EC KATAKANA LETTER RE */
#define XK_kana_RO                       0x04db  /* U+30ED KATAKANA LETTER RO */
#define XK_kana_WA                       0x04dc  /* U+30EF KATAKANA LETTER WA */
#define XK_kana_N                        0x04dd  /* U+30F3 KATAKANA LETTER N */
#define XK_voicedsound                   0x04de  /* U+309B KATAKANA-HIRAGANA VOICED SOUND MARK */
#define XK_semivoicedsound               0x04df  /* U+309C KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK */
#define XK_kana_switch                   0xff7e  /* Alias for mode_switch */
/* XK_KATAKANA */

/*
 * Arabic
 * Byte 3 = 5
 */


#define XK_Farsi_0                    0x10006f0  /* U+06F0 EXTENDED ARABIC-INDIC DIGIT ZERO */
#define XK_Farsi_1                    0x10006f1  /* U+06F1 EXTENDED ARABIC-INDIC DIGIT ONE */
#define XK_Farsi_2                    0x10006f2  /* U+06F2 EXTENDED ARABIC-INDIC DIGIT TWO */
#define XK_Farsi_3                    0x10006f3  /* U+06F3 EXTENDED ARABIC-INDIC DIGIT THREE */
#define XK_Farsi_4                    0x10006f4  /* U+06F4 EXTENDED ARABIC-INDIC DIGIT FOUR */
#define XK_Farsi_5                    0x10006f5  /* U+06F5 EXTENDED ARABIC-INDIC DIGIT FIVE */
#define XK_Farsi_6                    0x10006f6  /* U+06F6 EXTENDED ARABIC-INDIC DIGIT SIX */
#define XK_Farsi_7                    0x10006f7  /* U+06F7 EXTENDED ARABIC-INDIC DIGIT SEVEN */
#define XK_Farsi_8                    0x10006f8  /* U+06F8 EXTENDED ARABIC-INDIC DIGIT EIGHT */
#define XK_Farsi_9                    0x10006f9  /* U+06F9 EXTENDED ARABIC-INDIC DIGIT NINE */
#define XK_Arabic_percent             0x100066a  /* U+066A ARABIC PERCENT SIGN */
#define XK_Arabic_superscript_alef    0x1000670  /* U+0670 ARABIC LETTER SUPERSCRIPT ALEF */
#define XK_Arabic_tteh                0x1000679  /* U+0679 ARABIC LETTER TTEH */
#define XK_Arabic_peh                 0x100067e  /* U+067E ARABIC LETTER PEH */
#define XK_Arabic_tcheh               0x1000686  /* U+0686 ARABIC LETTER TCHEH */
#define XK_Arabic_ddal                0x1000688  /* U+0688 ARABIC LETTER DDAL */
#define XK_Arabic_rreh                0x1000691  /* U+0691 ARABIC LETTER RREH */
#define XK_Arabic_comma                  0x05ac  /* U+060C ARABIC COMMA */
#define XK_Arabic_fullstop            0x10006d4  /* U+06D4 ARABIC FULL STOP */
#define XK_Arabic_0                   0x1000660  /* U+0660 ARABIC-INDIC DIGIT ZERO */
#define XK_Arabic_1                   0x1000661  /* U+0661 ARABIC-INDIC DIGIT ONE */
#define XK_Arabic_2                   0x1000662  /* U+0662 ARABIC-INDIC DIGIT TWO */
#define XK_Arabic_3                   0x1000663  /* U+0663 ARABIC-INDIC DIGIT THREE */
#define XK_Arabic_4                   0x1000664  /* U+0664 ARABIC-INDIC DIGIT FOUR */
#define XK_Arabic_5                   0x1000665  /* U+0665 ARABIC-INDIC DIGIT FIVE */
#define XK_Arabic_6                   0x1000666  /* U+0666 ARABIC-INDIC DIGIT SIX */
#define XK_Arabic_7                   0x1000667  /* U+0667 ARABIC-INDIC DIGIT SEVEN */
#define XK_Arabic_8                   0x1000668  /* U+0668 ARABIC-INDIC DIGIT EIGHT */
#define XK_Arabic_9                   0x1000669  /* U+0669 ARABIC-INDIC DIGIT NINE */
#define XK_Arabic_semicolon              0x05bb  /* U+061B ARABIC SEMICOLON */
#define XK_Arabic_question_mark          0x05bf  /* U+061F ARABIC QUESTION MARK */
#define XK_Arabic_hamza                  0x05c1  /* U+0621 ARABIC LETTER HAMZA */
#define XK_Arabic_maddaonalef            0x05c2  /* U+0622 ARABIC LETTER ALEF WITH MADDA ABOVE */
#define XK_Arabic_hamzaonalef            0x05c3  /* U+0623 ARABIC LETTER ALEF WITH HAMZA ABOVE */
#define XK_Arabic_hamzaonwaw             0x05c4  /* U+0624 ARABIC LETTER WAW WITH HAMZA ABOVE */
#define XK_Arabic_hamzaunderalef         0x05c5  /* U+0625 ARABIC LETTER ALEF WITH HAMZA BELOW */
#define XK_Arabic_hamzaonyeh             0x05c6  /* U+0626 ARABIC LETTER YEH WITH HAMZA ABOVE */
#define XK_Arabic_alef                   0x05c7  /* U+0627 ARABIC LETTER ALEF */
#define XK_Arabic_beh                    0x05c8  /* U+0628 ARABIC LETTER BEH */
#define XK_Arabic_tehmarbuta             0x05c9  /* U+0629 ARABIC LETTER TEH MARBUTA */
#define XK_Arabic_teh                    0x05ca  /* U+062A ARABIC LETTER TEH */
#define XK_Arabic_theh                   0x05cb  /* U+062B ARABIC LETTER THEH */
#define XK_Arabic_jeem                   0x05cc  /* U+062C ARABIC LETTER JEEM */
#define XK_Arabic_hah                    0x05cd  /* U+062D ARABIC LETTER HAH */
#define XK_Arabic_khah                   0x05ce  /* U+062E ARABIC LETTER KHAH */
#define XK_Arabic_dal                    0x05cf  /* U+062F ARABIC LETTER DAL */
#define XK_Arabic_thal                   0x05d0  /* U+0630 ARABIC LETTER THAL */
#define XK_Arabic_ra                     0x05d1  /* U+0631 ARABIC LETTER REH */
#define XK_Arabic_zain                   0x05d2  /* U+0632 ARABIC LETTER ZAIN */
#define XK_Arabic_seen                   0x05d3  /* U+0633 ARABIC LETTER SEEN */
#define XK_Arabic_sheen                  0x05d4  /* U+0634 ARABIC LETTER SHEEN */
#define XK_Arabic_sad                    0x05d5  /* U+0635 ARABIC LETTER SAD */
#define XK_Arabic_dad                    0x05d6  /* U+0636 ARABIC LETTER DAD */
#define XK_Arabic_tah                    0x05d7  /* U+0637 ARABIC LETTER TAH */
#define XK_Arabic_zah                    0x05d8  /* U+0638 ARABIC LETTER ZAH */
#define XK_Arabic_ain                    0x05d9  /* U+0639 ARABIC LETTER AIN */
#define XK_Arabic_ghain                  0x05da  /* U+063A ARABIC LETTER GHAIN */
#define XK_Arabic_tatweel                0x05e0  /* U+0640 ARABIC TATWEEL */
#define XK_Arabic_feh                    0x05e1  /* U+0641 ARABIC LETTER FEH */
#define XK_Arabic_qaf                    0x05e2  /* U+0642 ARABIC LETTER QAF */
#define XK_Arabic_kaf                    0x05e3  /* U+0643 ARABIC LETTER KAF */
#define XK_Arabic_lam                    0x05e4  /* U+0644 ARABIC LETTER LAM */
#define XK_Arabic_meem                   0x05e5  /* U+0645 ARABIC LETTER MEEM */
#define XK_Arabic_noon                   0x05e6  /* U+0646 ARABIC LETTER NOON */
#define XK_Arabic_ha                     0x05e7  /* U+0647 ARABIC LETTER HEH */
#define XK_Arabic_heh                    0x05e7  /* deprecated */
#define XK_Arabic_waw                    0x05e8  /* U+0648 ARABIC LETTER WAW */
#define XK_Arabic_alefmaksura            0x05e9  /* U+0649 ARABIC LETTER ALEF MAKSURA */
#define XK_Arabic_yeh                    0x05ea  /* U+064A ARABIC LETTER YEH */
#define XK_Arabic_fathatan               0x05eb  /* U+064B ARABIC FATHATAN */
#define XK_Arabic_dammatan               0x05ec  /* U+064C ARABIC DAMMATAN */
#define XK_Arabic_kasratan               0x05ed  /* U+064D ARABIC KASRATAN */
#define XK_Arabic_fatha                  0x05ee  /* U+064E ARABIC FATHA */
#define XK_Arabic_damma                  0x05ef  /* U+064F ARABIC DAMMA */
#define XK_Arabic_kasra                  0x05f0  /* U+0650 ARABIC KASRA */
#define XK_Arabic_shadda                 0x05f1  /* U+0651 ARABIC SHADDA */
#define XK_Arabic_sukun                  0x05f2  /* U+0652 ARABIC SUKUN */
#define XK_Arabic_madda_above         0x1000653  /* U+0653 ARABIC MADDAH ABOVE */
#define XK_Arabic_hamza_above         0x1000654  /* U+0654 ARABIC HAMZA ABOVE */
#define XK_Arabic_hamza_below         0x1000655  /* U+0655 ARABIC HAMZA BELOW */
#define XK_Arabic_jeh                 0x1000698  /* U+0698 ARABIC LETTER JEH */
#define XK_Arabic_veh                 0x10006a4  /* U+06A4 ARABIC LETTER VEH */
#define XK_Arabic_keheh               0x10006a9  /* U+06A9 ARABIC LETTER KEHEH */
#define XK_Arabic_gaf                 0x10006af  /* U+06AF ARABIC LETTER GAF */
#define XK_Arabic_noon_ghunna         0x10006ba  /* U+06BA ARABIC LETTER NOON GHUNNA */
#define XK_Arabic_heh_doachashmee     0x10006be  /* U+06BE ARABIC LETTER HEH DOACHASHMEE */
#define XK_Farsi_yeh                  0x10006cc  /* U+06CC ARABIC LETTER FARSI YEH */
#define XK_Arabic_farsi_yeh           0x10006cc  /* U+06CC ARABIC LETTER FARSI YEH */
#define XK_Arabic_yeh_baree           0x10006d2  /* U+06D2 ARABIC LETTER YEH BARREE */
#define XK_Arabic_heh_goal            0x10006c1  /* U+06C1 ARABIC LETTER HEH GOAL */
#define XK_Arabic_switch                 0xff7e  /* Alias for mode_switch */
/* XK_ARABIC */

/*
 * Cyrillic
 * Byte 3 = 6
 */

#define XK_Cyrillic_GHE_bar           0x1000492  /* U+0492 CYRILLIC CAPITAL LETTER GHE WITH STROKE */
#define XK_Cyrillic_ghe_bar           0x1000493  /* U+0493 CYRILLIC SMALL LETTER GHE WITH STROKE */
#define XK_Cyrillic_ZHE_descender     0x1000496  /* U+0496 CYRILLIC CAPITAL LETTER ZHE WITH DESCENDER */
#define XK_Cyrillic_zhe_descender     0x1000497  /* U+0497 CYRILLIC SMALL LETTER ZHE WITH DESCENDER */
#define XK_Cyrillic_KA_descender      0x100049a  /* U+049A CYRILLIC CAPITAL LETTER KA WITH DESCENDER */
#define XK_Cyrillic_ka_descender      0x100049b  /* U+049B CYRILLIC SMALL LETTER KA WITH DESCENDER */
#define XK_Cyrillic_KA_vertstroke     0x100049c  /* U+049C CYRILLIC CAPITAL LETTER KA WITH VERTICAL STROKE */
#define XK_Cyrillic_ka_vertstroke     0x100049d  /* U+049D CYRILLIC SMALL LETTER KA WITH VERTICAL STROKE */
#define XK_Cyrillic_EN_descender      0x10004a2  /* U+04A2 CYRILLIC CAPITAL LETTER EN WITH DESCENDER */
#define XK_Cyrillic_en_descender      0x10004a3  /* U+04A3 CYRILLIC SMALL LETTER EN WITH DESCENDER */
#define XK_Cyrillic_U_straight        0x10004ae  /* U+04AE CYRILLIC CAPITAL LETTER STRAIGHT U */
#define XK_Cyrillic_u_straight        0x10004af  /* U+04AF CYRILLIC SMALL LETTER STRAIGHT U */
#define XK_Cyrillic_U_straight_bar    0x10004b0  /* U+04B0 CYRILLIC CAPITAL LETTER STRAIGHT U WITH STROKE */
#define XK_Cyrillic_u_straight_bar    0x10004b1  /* U+04B1 CYRILLIC SMALL LETTER STRAIGHT U WITH STROKE */
#define XK_Cyrillic_HA_descender      0x10004b2  /* U+04B2 CYRILLIC CAPITAL LETTER HA WITH DESCENDER */
#define XK_Cyrillic_ha_descender      0x10004b3  /* U+04B3 CYRILLIC SMALL LETTER HA WITH DESCENDER */
#define XK_Cyrillic_CHE_descender     0x10004b6  /* U+04B6 CYRILLIC CAPITAL LETTER CHE WITH DESCENDER */
#define XK_Cyrillic_che_descender     0x10004b7  /* U+04B7 CYRILLIC SMALL LETTER CHE WITH DESCENDER */
#define XK_Cyrillic_CHE_vertstroke    0x10004b8  /* U+04B8 CYRILLIC CAPITAL LETTER CHE WITH VERTICAL STROKE */
#define XK_Cyrillic_che_vertstroke    0x10004b9  /* U+04B9 CYRILLIC SMALL LETTER CHE WITH VERTICAL STROKE */
#define XK_Cyrillic_SHHA              0x10004ba  /* U+04BA CYRILLIC CAPITAL LETTER SHHA */
#define XK_Cyrillic_shha              0x10004bb  /* U+04BB CYRILLIC SMALL LETTER SHHA */

#define XK_Cyrillic_SCHWA             0x10004d8  /* U+04D8 CYRILLIC CAPITAL LETTER SCHWA */
#define XK_Cyrillic_schwa             0x10004d9  /* U+04D9 CYRILLIC SMALL LETTER SCHWA */
#define XK_Cyrillic_I_macron          0x10004e2  /* U+04E2 CYRILLIC CAPITAL LETTER I WITH MACRON */
#define XK_Cyrillic_i_macron          0x10004e3  /* U+04E3 CYRILLIC SMALL LETTER I WITH MACRON */
#define XK_Cyrillic_O_bar             0x10004e8  /* U+04E8 CYRILLIC CAPITAL LETTER BARRED O */
#define XK_Cyrillic_o_bar             0x10004e9  /* U+04E9 CYRILLIC SMALL LETTER BARRED O */
#define XK_Cyrillic_U_macron          0x10004ee  /* U+04EE CYRILLIC CAPITAL LETTER U WITH MACRON */
#define XK_Cyrillic_u_macron          0x10004ef  /* U+04EF CYRILLIC SMALL LETTER U WITH MACRON */

#define XK_Serbian_dje                   0x06a1  /* U+0452 CYRILLIC SMALL LETTER DJE */
#define XK_Macedonia_gje                 0x06a2  /* U+0453 CYRILLIC SMALL LETTER GJE */
#define XK_Cyrillic_io                   0x06a3  /* U+0451 CYRILLIC SMALL LETTER IO */
#define XK_Ukrainian_ie                  0x06a4  /* U+0454 CYRILLIC SMALL LETTER UKRAINIAN IE */
#define XK_Ukranian_je                   0x06a4  /* deprecated */
#define XK_Macedonia_dse                 0x06a5  /* U+0455 CYRILLIC SMALL LETTER DZE */
#define XK_Ukrainian_i                   0x06a6  /* U+0456 CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I */
#define XK_Ukranian_i                    0x06a6  /* deprecated */
#define XK_Ukrainian_yi                  0x06a7  /* U+0457 CYRILLIC SMALL LETTER YI */
#define XK_Ukranian_yi                   0x06a7  /* deprecated */
#define XK_Cyrillic_je                   0x06a8  /* U+0458 CYRILLIC SMALL LETTER JE */
#define XK_Serbian_je                    0x06a8  /* deprecated */
#define XK_Cyrillic_lje                  0x06a9  /* U+0459 CYRILLIC SMALL LETTER LJE */
#define XK_Serbian_lje                   0x06a9  /* deprecated */
#define XK_Cyrillic_nje                  0x06aa  /* U+045A CYRILLIC SMALL LETTER NJE */
#define XK_Serbian_nje                   0x06aa  /* deprecated */
#define XK_Serbian_tshe                  0x06ab  /* U+045B CYRILLIC SMALL LETTER TSHE */
#define XK_Macedonia_kje                 0x06ac  /* U+045C CYRILLIC SMALL LETTER KJE */
#define XK_Ukrainian_ghe_with_upturn     0x06ad  /* U+0491 CYRILLIC SMALL LETTER GHE WITH UPTURN */
#define XK_Byelorussian_shortu           0x06ae  /* U+045E CYRILLIC SMALL LETTER SHORT U */
#define XK_Cyrillic_dzhe                 0x06af  /* U+045F CYRILLIC SMALL LETTER DZHE */
#define XK_Serbian_dze                   0x06af  /* deprecated */
#define XK_numerosign                    0x06b0  /* U+2116 NUMERO SIGN */
#define XK_Serbian_DJE                   0x06b1  /* U+0402 CYRILLIC CAPITAL LETTER DJE */
#define XK_Macedonia_GJE                 0x06b2  /* U+0403 CYRILLIC CAPITAL LETTER GJE */
#define XK_Cyrillic_IO                   0x06b3  /* U+0401 CYRILLIC CAPITAL LETTER IO */
#define XK_Ukrainian_IE                  0x06b4  /* U+0404 CYRILLIC CAPITAL LETTER UKRAINIAN IE */
#define XK_Ukranian_JE                   0x06b4  /* deprecated */
#define XK_Macedonia_DSE                 0x06b5  /* U+0405 CYRILLIC CAPITAL LETTER DZE */
#define XK_Ukrainian_I                   0x06b6  /* U+0406 CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I */
#define XK_Ukranian_I                    0x06b6  /* deprecated */
#define XK_Ukrainian_YI                  0x06b7  /* U+0407 CYRILLIC CAPITAL LETTER YI */
#define XK_Ukranian_YI                   0x06b7  /* deprecated */
#define XK_Cyrillic_JE                   0x06b8  /* U+0408 CYRILLIC CAPITAL LETTER JE */
#define XK_Serbian_JE                    0x06b8  /* deprecated */
#define XK_Cyrillic_LJE                  0x06b9  /* U+0409 CYRILLIC CAPITAL LETTER LJE */
#define XK_Serbian_LJE                   0x06b9  /* deprecated */
#define XK_Cyrillic_NJE                  0x06ba  /* U+040A CYRILLIC CAPITAL LETTER NJE */
#define XK_Serbian_NJE                   0x06ba  /* deprecated */
#define XK_Serbian_TSHE                  0x06bb  /* U+040B CYRILLIC CAPITAL LETTER TSHE */
#define XK_Macedonia_KJE                 0x06bc  /* U+040C CYRILLIC CAPITAL LETTER KJE */
#define XK_Ukrainian_GHE_WITH_UPTURN     0x06bd  /* U+0490 CYRILLIC CAPITAL LETTER GHE WITH UPTURN */
#define XK_Byelorussian_SHORTU           0x06be  /* U+040E CYRILLIC CAPITAL LETTER SHORT U */
#define XK_Cyrillic_DZHE                 0x06bf  /* U+040F CYRILLIC CAPITAL LETTER DZHE */
#define XK_Serbian_DZE                   0x06bf  /* deprecated */
#define XK_Cyrillic_yu                   0x06c0  /* U+044E CYRILLIC SMALL LETTER YU */
#define XK_Cyrillic_a                    0x06c1  /* U+0430 CYRILLIC SMALL LETTER A */
#define XK_Cyrillic_be                   0x06c2  /* U+0431 CYRILLIC SMALL LETTER BE */
#define XK_Cyrillic_tse                  0x06c3  /* U+0446 CYRILLIC SMALL LETTER TSE */
#define XK_Cyrillic_de                   0x06c4  /* U+0434 CYRILLIC SMALL LETTER DE */
#define XK_Cyrillic_ie                   0x06c5  /* U+0435 CYRILLIC SMALL LETTER IE */
#define XK_Cyrillic_ef                   0x06c6  /* U+0444 CYRILLIC SMALL LETTER EF */
#define XK_Cyrillic_ghe                  0x06c7  /* U+0433 CYRILLIC SMALL LETTER GHE */
#define XK_Cyrillic_ha                   0x06c8  /* U+0445 CYRILLIC SMALL LETTER HA */
#define XK_Cyrillic_i                    0x06c9  /* U+0438 CYRILLIC SMALL LETTER I */
#define XK_Cyrillic_shorti               0x06ca  /* U+0439 CYRILLIC SMALL LETTER SHORT I */
#define XK_Cyrillic_ka                   0x06cb  /* U+043A CYRILLIC SMALL LETTER KA */
#define XK_Cyrillic_el                   0x06cc  /* U+043B CYRILLIC SMALL LETTER EL */
#define XK_Cyrillic_em                   0x06cd  /* U+043C CYRILLIC SMALL LETTER EM */
#define XK_Cyrillic_en                   0x06ce  /* U+043D CYRILLIC SMALL LETTER EN */
#define XK_Cyrillic_o                    0x06cf  /* U+043E CYRILLIC SMALL LETTER O */
#define XK_Cyrillic_pe                   0x06d0  /* U+043F CYRILLIC SMALL LETTER PE */
#define XK_Cyrillic_ya                   0x06d1  /* U+044F CYRILLIC SMALL LETTER YA */
#define XK_Cyrillic_er                   0x06d2  /* U+0440 CYRILLIC SMALL LETTER ER */
#define XK_Cyrillic_es                   0x06d3  /* U+0441 CYRILLIC SMALL LETTER ES */
#define XK_Cyrillic_te                   0x06d4  /* U+0442 CYRILLIC SMALL LETTER TE */
#define XK_Cyrillic_u                    0x06d5  /* U+0443 CYRILLIC SMALL LETTER U */
#define XK_Cyrillic_zhe                  0x06d6  /* U+0436 CYRILLIC SMALL LETTER ZHE */
#define XK_Cyrillic_ve                   0x06d7  /* U+0432 CYRILLIC SMALL LETTER VE */
#define XK_Cyrillic_softsign             0x06d8  /* U+044C CYRILLIC SMALL LETTER SOFT SIGN */
#define XK_Cyrillic_yeru                 0x06d9  /* U+044B CYRILLIC SMALL LETTER YERU */
#define XK_Cyrillic_ze                   0x06da  /* U+0437 CYRILLIC SMALL LETTER ZE */
#define XK_Cyrillic_sha                  0x06db  /* U+0448 CYRILLIC SMALL LETTER SHA */
#define XK_Cyrillic_e                    0x06dc  /* U+044D CYRILLIC SMALL LETTER E */
#define XK_Cyrillic_shcha                0x06dd  /* U+0449 CYRILLIC SMALL LETTER SHCHA */
#define XK_Cyrillic_che                  0x06de  /* U+0447 CYRILLIC SMALL LETTER CHE */
#define XK_Cyrillic_hardsign             0x06df  /* U+044A CYRILLIC SMALL LETTER HARD SIGN */
#define XK_Cyrillic_YU                   0x06e0  /* U+042E CYRILLIC CAPITAL LETTER YU */
#define XK_Cyrillic_A                    0x06e1  /* U+0410 CYRILLIC CAPITAL LETTER A */
#define XK_Cyrillic_BE                   0x06e2  /* U+0411 CYRILLIC CAPITAL LETTER BE */
#define XK_Cyrillic_TSE                  0x06e3  /* U+0426 CYRILLIC CAPITAL LETTER TSE */
#define XK_Cyrillic_DE                   0x06e4  /* U+0414 CYRILLIC CAPITAL LETTER DE */
#define XK_Cyrillic_IE                   0x06e5  /* U+0415 CYRILLIC CAPITAL LETTER IE */
#define XK_Cyrillic_EF                   0x06e6  /* U+0424 CYRILLIC CAPITAL LETTER EF */
#define XK_Cyrillic_GHE                  0x06e7  /* U+0413 CYRILLIC CAPITAL LETTER GHE */
#define XK_Cyrillic_HA                   0x06e8  /* U+0425 CYRILLIC CAPITAL LETTER HA */
#define XK_Cyrillic_I                    0x06e9  /* U+0418 CYRILLIC CAPITAL LETTER I */
#define XK_Cyrillic_SHORTI               0x06ea  /* U+0419 CYRILLIC CAPITAL LETTER SHORT I */
#define XK_Cyrillic_KA                   0x06eb  /* U+041A CYRILLIC CAPITAL LETTER KA */
#define XK_Cyrillic_EL                   0x06ec  /* U+041B CYRILLIC CAPITAL LETTER EL */
#define XK_Cyrillic_EM                   0x06ed  /* U+041C CYRILLIC CAPITAL LETTER EM */
#define XK_Cyrillic_EN                   0x06ee  /* U+041D CYRILLIC CAPITAL LETTER EN */
#define XK_Cyrillic_O                    0x06ef  /* U+041E CYRILLIC CAPITAL LETTER O */
#define XK_Cyrillic_PE                   0x06f0  /* U+041F CYRILLIC CAPITAL LETTER PE */
#define XK_Cyrillic_YA                   0x06f1  /* U+042F CYRILLIC CAPITAL LETTER YA */
#define XK_Cyrillic_ER                   0x06f2  /* U+0420 CYRILLIC CAPITAL LETTER ER */
#define XK_Cyrillic_ES                   0x06f3  /* U+0421 CYRILLIC CAPITAL LETTER ES */
#define XK_Cyrillic_TE                   0x06f4  /* U+0422 CYRILLIC CAPITAL LETTER TE */
#define XK_Cyrillic_U                    0x06f5  /* U+0423 CYRILLIC CAPITAL LETTER U */
#define XK_Cyrillic_ZHE                  0x06f6  /* U+0416 CYRILLIC CAPITAL LETTER ZHE */
#define XK_Cyrillic_VE                   0x06f7  /* U+0412 CYRILLIC CAPITAL LETTER VE */
#define XK_Cyrillic_SOFTSIGN             0x06f8  /* U+042C CYRILLIC CAPITAL LETTER SOFT SIGN */
#define XK_Cyrillic_YERU                 0x06f9  /* U+042B CYRILLIC CAPITAL LETTER YERU */
#define XK_Cyrillic_ZE                   0x06fa  /* U+0417 CYRILLIC CAPITAL LETTER ZE */
#define XK_Cyrillic_SHA                  0x06fb  /* U+0428 CYRILLIC CAPITAL LETTER SHA */
#define XK_Cyrillic_E                    0x06fc  /* U+042D CYRILLIC CAPITAL LETTER E */
#define XK_Cyrillic_SHCHA                0x06fd  /* U+0429 CYRILLIC CAPITAL LETTER SHCHA */
#define XK_Cyrillic_CHE                  0x06fe  /* U+0427 CYRILLIC CAPITAL LETTER CHE */
#define XK_Cyrillic_HARDSIGN             0x06ff  /* U+042A CYRILLIC CAPITAL LETTER HARD SIGN */
/* XK_CYRILLIC */

/*
 * Greek
 * (based on an early draft of, and not quite identical to, ISO/IEC 8859-7)
 * Byte 3 = 7
 */


#define XK_Greek_ALPHAaccent             0x07a1  /* U+0386 GREEK CAPITAL LETTER ALPHA WITH TONOS */
#define XK_Greek_EPSILONaccent           0x07a2  /* U+0388 GREEK CAPITAL LETTER EPSILON WITH TONOS */
#define XK_Greek_ETAaccent               0x07a3  /* U+0389 GREEK CAPITAL LETTER ETA WITH TONOS */
#define XK_Greek_IOTAaccent              0x07a4  /* U+038A GREEK CAPITAL LETTER IOTA WITH TONOS */
#define XK_Greek_IOTAdieresis            0x07a5  /* U+03AA GREEK CAPITAL LETTER IOTA WITH DIALYTIKA */
#define XK_Greek_IOTAdiaeresis           0x07a5  /* old typo */
#define XK_Greek_OMICRONaccent           0x07a7  /* U+038C GREEK CAPITAL LETTER OMICRON WITH TONOS */
#define XK_Greek_UPSILONaccent           0x07a8  /* U+038E GREEK CAPITAL LETTER UPSILON WITH TONOS */
#define XK_Greek_UPSILONdieresis         0x07a9  /* U+03AB GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA */
#define XK_Greek_OMEGAaccent             0x07ab  /* U+038F GREEK CAPITAL LETTER OMEGA WITH TONOS */
#define XK_Greek_accentdieresis          0x07ae  /* U+0385 GREEK DIALYTIKA TONOS */
#define XK_Greek_horizbar                0x07af  /* U+2015 HORIZONTAL BAR */
#define XK_Greek_alphaaccent             0x07b1  /* U+03AC GREEK SMALL LETTER ALPHA WITH TONOS */
#define XK_Greek_epsilonaccent           0x07b2  /* U+03AD GREEK SMALL LETTER EPSILON WITH TONOS */
#define XK_Greek_etaaccent               0x07b3  /* U+03AE GREEK SMALL LETTER ETA WITH TONOS */
#define XK_Greek_iotaaccent              0x07b4  /* U+03AF GREEK SMALL LETTER IOTA WITH TONOS */
#define XK_Greek_iotadieresis            0x07b5  /* U+03CA GREEK SMALL LETTER IOTA WITH DIALYTIKA */
#define XK_Greek_iotaaccentdieresis      0x07b6  /* U+0390 GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */
#define XK_Greek_omicronaccent           0x07b7  /* U+03CC GREEK SMALL LETTER OMICRON WITH TONOS */
#define XK_Greek_upsilonaccent           0x07b8  /* U+03CD GREEK SMALL LETTER UPSILON WITH TONOS */
#define XK_Greek_upsilondieresis         0x07b9  /* U+03CB GREEK SMALL LETTER UPSILON WITH DIALYTIKA */
#define XK_Greek_upsilonaccentdieresis   0x07ba  /* U+03B0 GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS */
#define XK_Greek_omegaaccent             0x07bb  /* U+03CE GREEK SMALL LETTER OMEGA WITH TONOS */
#define XK_Greek_ALPHA                   0x07c1  /* U+0391 GREEK CAPITAL LETTER ALPHA */
#define XK_Greek_BETA                    0x07c2  /* U+0392 GREEK CAPITAL LETTER BETA */
#define XK_Greek_GAMMA                   0x07c3  /* U+0393 GREEK CAPITAL LETTER GAMMA */
#define XK_Greek_DELTA                   0x07c4  /* U+0394 GREEK CAPITAL LETTER DELTA */
#define XK_Greek_EPSILON                 0x07c5  /* U+0395 GREEK CAPITAL LETTER EPSILON */
#define XK_Greek_ZETA                    0x07c6  /* U+0396 GREEK CAPITAL LETTER ZETA */
#define XK_Greek_ETA                     0x07c7  /* U+0397 GREEK CAPITAL LETTER ETA */
#define XK_Greek_THETA                   0x07c8  /* U+0398 GREEK CAPITAL LETTER THETA */
#define XK_Greek_IOTA                    0x07c9  /* U+0399 GREEK CAPITAL LETTER IOTA */
#define XK_Greek_KAPPA                   0x07ca  /* U+039A GREEK CAPITAL LETTER KAPPA */
#define XK_Greek_LAMDA                   0x07cb  /* U+039B GREEK CAPITAL LETTER LAMDA */
#define XK_Greek_LAMBDA                  0x07cb  /* U+039B GREEK CAPITAL LETTER LAMDA */
#define XK_Greek_MU                      0x07cc  /* U+039C GREEK CAPITAL LETTER MU */
#define XK_Greek_NU                      0x07cd  /* U+039D GREEK CAPITAL LETTER NU */
#define XK_Greek_XI                      0x07ce  /* U+039E GREEK CAPITAL LETTER XI */
#define XK_Greek_OMICRON                 0x07cf  /* U+039F GREEK CAPITAL LETTER OMICRON */
#define XK_Greek_PI                      0x07d0  /* U+03A0 GREEK CAPITAL LETTER PI */
#define XK_Greek_RHO                     0x07d1  /* U+03A1 GREEK CAPITAL LETTER RHO */
#define XK_Greek_SIGMA                   0x07d2  /* U+03A3 GREEK CAPITAL LETTER SIGMA */
#define XK_Greek_TAU                     0x07d4  /* U+03A4 GREEK CAPITAL LETTER TAU */
#define XK_Greek_UPSILON                 0x07d5  /* U+03A5 GREEK CAPITAL LETTER UPSILON */
#define XK_Greek_PHI                     0x07d6  /* U+03A6 GREEK CAPITAL LETTER PHI */
#define XK_Greek_CHI                     0x07d7  /* U+03A7 GREEK CAPITAL LETTER CHI */
#define XK_Greek_PSI                     0x07d8  /* U+03A8 GREEK CAPITAL LETTER PSI */
#define XK_Greek_OMEGA                   0x07d9  /* U+03A9 GREEK CAPITAL LETTER OMEGA */
#define XK_Greek_alpha                   0x07e1  /* U+03B1 GREEK SMALL LETTER ALPHA */
#define XK_Greek_beta                    0x07e2  /* U+03B2 GREEK SMALL LETTER BETA */
#define XK_Greek_gamma                   0x07e3  /* U+03B3 GREEK SMALL LETTER GAMMA */
#define XK_Greek_delta                   0x07e4  /* U+03B4 GREEK SMALL LETTER DELTA */
#define XK_Greek_epsilon                 0x07e5  /* U+03B5 GREEK SMALL LETTER EPSILON */
#define XK_Greek_zeta                    0x07e6  /* U+03B6 GREEK SMALL LETTER ZETA */
#define XK_Greek_eta                     0x07e7  /* U+03B7 GREEK SMALL LETTER ETA */
#define XK_Greek_theta                   0x07e8  /* U+03B8 GREEK SMALL LETTER THETA */
#define XK_Greek_iota                    0x07e9  /* U+03B9 GREEK SMALL LETTER IOTA */
#define XK_Greek_kappa                   0x07ea  /* U+03BA GREEK SMALL LETTER KAPPA */
#define XK_Greek_lamda                   0x07eb  /* U+03BB GREEK SMALL LETTER LAMDA */
#define XK_Greek_lambda                  0x07eb  /* U+03BB GREEK SMALL LETTER LAMDA */
#define XK_Greek_mu                      0x07ec  /* U+03BC GREEK SMALL LETTER MU */
#define XK_Greek_nu                      0x07ed  /* U+03BD GREEK SMALL LETTER NU */
#define XK_Greek_xi                      0x07ee  /* U+03BE GREEK SMALL LETTER XI */
#define XK_Greek_omicron                 0x07ef  /* U+03BF GREEK SMALL LETTER OMICRON */
#define XK_Greek_pi                      0x07f0  /* U+03C0 GREEK SMALL LETTER PI */
#define XK_Greek_rho                     0x07f1  /* U+03C1 GREEK SMALL LETTER RHO */
#define XK_Greek_sigma                   0x07f2  /* U+03C3 GREEK SMALL LETTER SIGMA */
#define XK_Greek_finalsmallsigma         0x07f3  /* U+03C2 GREEK SMALL LETTER FINAL SIGMA */
#define XK_Greek_tau                     0x07f4  /* U+03C4 GREEK SMALL LETTER TAU */
#define XK_Greek_upsilon                 0x07f5  /* U+03C5 GREEK SMALL LETTER UPSILON */
#define XK_Greek_phi                     0x07f6  /* U+03C6 GREEK SMALL LETTER PHI */
#define XK_Greek_chi                     0x07f7  /* U+03C7 GREEK SMALL LETTER CHI */
#define XK_Greek_psi                     0x07f8  /* U+03C8 GREEK SMALL LETTER PSI */
#define XK_Greek_omega                   0x07f9  /* U+03C9 GREEK SMALL LETTER OMEGA */
#define XK_Greek_switch                  0xff7e  /* Alias for mode_switch */
/* XK_GREEK */

/*
 * Technical
 * (from the DEC VT330/VT420 Technical Character Set, http://vt100.net/charsets/technical.html)
 * Byte 3 = 8
 */

/* XK_TECHNICAL */
# 1375 "/usr/include/X11/keysymdef.h" 3


/*
 * Special
 * (from the DEC VT100 Special Graphics Character Set)
 * Byte 3 = 9
 */

/* XK_SPECIAL */
# 1408 "/usr/include/X11/keysymdef.h" 3


/*
 * Publishing
 * (these are probably from a long forgotten DEC Publishing
 * font that once shipped with DECwrite)
 * Byte 3 = 0x0a
 */

/* XK_PUBLISHING */
# 1501 "/usr/include/X11/keysymdef.h" 3


/*
 * APL
 * Byte 3 = 0x0b
 */

/* XK_APL */
# 1528 "/usr/include/X11/keysymdef.h" 3


/*
 * Hebrew
 * Byte 3 = 0x0c
 */


#define XK_hebrew_doublelowline          0x0cdf  /* U+2017 DOUBLE LOW LINE */
#define XK_hebrew_aleph                  0x0ce0  /* U+05D0 HEBREW LETTER ALEF */
#define XK_hebrew_bet                    0x0ce1  /* U+05D1 HEBREW LETTER BET */
#define XK_hebrew_beth                   0x0ce1  /* deprecated */
#define XK_hebrew_gimel                  0x0ce2  /* U+05D2 HEBREW LETTER GIMEL */
#define XK_hebrew_gimmel                 0x0ce2  /* deprecated */
#define XK_hebrew_dalet                  0x0ce3  /* U+05D3 HEBREW LETTER DALET */
#define XK_hebrew_daleth                 0x0ce3  /* deprecated */
#define XK_hebrew_he                     0x0ce4  /* U+05D4 HEBREW LETTER HE */
#define XK_hebrew_waw                    0x0ce5  /* U+05D5 HEBREW LETTER VAV */
#define XK_hebrew_zain                   0x0ce6  /* U+05D6 HEBREW LETTER ZAYIN */
#define XK_hebrew_zayin                  0x0ce6  /* deprecated */
#define XK_hebrew_chet                   0x0ce7  /* U+05D7 HEBREW LETTER HET */
#define XK_hebrew_het                    0x0ce7  /* deprecated */
#define XK_hebrew_tet                    0x0ce8  /* U+05D8 HEBREW LETTER TET */
#define XK_hebrew_teth                   0x0ce8  /* deprecated */
#define XK_hebrew_yod                    0x0ce9  /* U+05D9 HEBREW LETTER YOD */
#define XK_hebrew_finalkaph              0x0cea  /* U+05DA HEBREW LETTER FINAL KAF */
#define XK_hebrew_kaph                   0x0ceb  /* U+05DB HEBREW LETTER KAF */
#define XK_hebrew_lamed                  0x0cec  /* U+05DC HEBREW LETTER LAMED */
#define XK_hebrew_finalmem               0x0ced  /* U+05DD HEBREW LETTER FINAL MEM */
#define XK_hebrew_mem                    0x0cee  /* U+05DE HEBREW LETTER MEM */
#define XK_hebrew_finalnun               0x0cef  /* U+05DF HEBREW LETTER FINAL NUN */
#define XK_hebrew_nun                    0x0cf0  /* U+05E0 HEBREW LETTER NUN */
#define XK_hebrew_samech                 0x0cf1  /* U+05E1 HEBREW LETTER SAMEKH */
#define XK_hebrew_samekh                 0x0cf1  /* deprecated */
#define XK_hebrew_ayin                   0x0cf2  /* U+05E2 HEBREW LETTER AYIN */
#define XK_hebrew_finalpe                0x0cf3  /* U+05E3 HEBREW LETTER FINAL PE */
#define XK_hebrew_pe                     0x0cf4  /* U+05E4 HEBREW LETTER PE */
#define XK_hebrew_finalzade              0x0cf5  /* U+05E5 HEBREW LETTER FINAL TSADI */
#define XK_hebrew_finalzadi              0x0cf5  /* deprecated */
#define XK_hebrew_zade                   0x0cf6  /* U+05E6 HEBREW LETTER TSADI */
#define XK_hebrew_zadi                   0x0cf6  /* deprecated */
#define XK_hebrew_qoph                   0x0cf7  /* U+05E7 HEBREW LETTER QOF */
#define XK_hebrew_kuf                    0x0cf7  /* deprecated */
#define XK_hebrew_resh                   0x0cf8  /* U+05E8 HEBREW LETTER RESH */
#define XK_hebrew_shin                   0x0cf9  /* U+05E9 HEBREW LETTER SHIN */
#define XK_hebrew_taw                    0x0cfa  /* U+05EA HEBREW LETTER TAV */
#define XK_hebrew_taf                    0x0cfa  /* deprecated */
#define XK_Hebrew_switch                 0xff7e  /* Alias for mode_switch */
/* XK_HEBREW */

/*
 * Thai
 * Byte 3 = 0x0d
 */


#define XK_Thai_kokai                    0x0da1  /* U+0E01 THAI CHARACTER KO KAI */
#define XK_Thai_khokhai                  0x0da2  /* U+0E02 THAI CHARACTER KHO KHAI */
#define XK_Thai_khokhuat                 0x0da3  /* U+0E03 THAI CHARACTER KHO KHUAT */
#define XK_Thai_khokhwai                 0x0da4  /* U+0E04 THAI CHARACTER KHO KHWAI */
#define XK_Thai_khokhon                  0x0da5  /* U+0E05 THAI CHARACTER KHO KHON */
#define XK_Thai_khorakhang               0x0da6  /* U+0E06 THAI CHARACTER KHO RAKHANG */
#define XK_Thai_ngongu                   0x0da7  /* U+0E07 THAI CHARACTER NGO NGU */
#define XK_Thai_chochan                  0x0da8  /* U+0E08 THAI CHARACTER CHO CHAN */
#define XK_Thai_choching                 0x0da9  /* U+0E09 THAI CHARACTER CHO CHING */
#define XK_Thai_chochang                 0x0daa  /* U+0E0A THAI CHARACTER CHO CHANG */
#define XK_Thai_soso                     0x0dab  /* U+0E0B THAI CHARACTER SO SO */
#define XK_Thai_chochoe                  0x0dac  /* U+0E0C THAI CHARACTER CHO CHOE */
#define XK_Thai_yoying                   0x0dad  /* U+0E0D THAI CHARACTER YO YING */
#define XK_Thai_dochada                  0x0dae  /* U+0E0E THAI CHARACTER DO CHADA */
#define XK_Thai_topatak                  0x0daf  /* U+0E0F THAI CHARACTER TO PATAK */
#define XK_Thai_thothan                  0x0db0  /* U+0E10 THAI CHARACTER THO THAN */
#define XK_Thai_thonangmontho            0x0db1  /* U+0E11 THAI CHARACTER THO NANGMONTHO */
#define XK_Thai_thophuthao               0x0db2  /* U+0E12 THAI CHARACTER THO PHUTHAO */
#define XK_Thai_nonen                    0x0db3  /* U+0E13 THAI CHARACTER NO NEN */
#define XK_Thai_dodek                    0x0db4  /* U+0E14 THAI CHARACTER DO DEK */
#define XK_Thai_totao                    0x0db5  /* U+0E15 THAI CHARACTER TO TAO */
#define XK_Thai_thothung                 0x0db6  /* U+0E16 THAI CHARACTER THO THUNG */
#define XK_Thai_thothahan                0x0db7  /* U+0E17 THAI CHARACTER THO THAHAN */
#define XK_Thai_thothong                 0x0db8  /* U+0E18 THAI CHARACTER THO THONG */
#define XK_Thai_nonu                     0x0db9  /* U+0E19 THAI CHARACTER NO NU */
#define XK_Thai_bobaimai                 0x0dba  /* U+0E1A THAI CHARACTER BO BAIMAI */
#define XK_Thai_popla                    0x0dbb  /* U+0E1B THAI CHARACTER PO PLA */
#define XK_Thai_phophung                 0x0dbc  /* U+0E1C THAI CHARACTER PHO PHUNG */
#define XK_Thai_fofa                     0x0dbd  /* U+0E1D THAI CHARACTER FO FA */
#define XK_Thai_phophan                  0x0dbe  /* U+0E1E THAI CHARACTER PHO PHAN */
#define XK_Thai_fofan                    0x0dbf  /* U+0E1F THAI CHARACTER FO FAN */
#define XK_Thai_phosamphao               0x0dc0  /* U+0E20 THAI CHARACTER PHO SAMPHAO */
#define XK_Thai_moma                     0x0dc1  /* U+0E21 THAI CHARACTER MO MA */
#define XK_Thai_yoyak                    0x0dc2  /* U+0E22 THAI CHARACTER YO YAK */
#define XK_Thai_rorua                    0x0dc3  /* U+0E23 THAI CHARACTER RO RUA */
#define XK_Thai_ru                       0x0dc4  /* U+0E24 THAI CHARACTER RU */
#define XK_Thai_loling                   0x0dc5  /* U+0E25 THAI CHARACTER LO LING */
#define XK_Thai_lu                       0x0dc6  /* U+0E26 THAI CHARACTER LU */
#define XK_Thai_wowaen                   0x0dc7  /* U+0E27 THAI CHARACTER WO WAEN */
#define XK_Thai_sosala                   0x0dc8  /* U+0E28 THAI CHARACTER SO SALA */
#define XK_Thai_sorusi                   0x0dc9  /* U+0E29 THAI CHARACTER SO RUSI */
#define XK_Thai_sosua                    0x0dca  /* U+0E2A THAI CHARACTER SO SUA */
#define XK_Thai_hohip                    0x0dcb  /* U+0E2B THAI CHARACTER HO HIP */
#define XK_Thai_lochula                  0x0dcc  /* U+0E2C THAI CHARACTER LO CHULA */
#define XK_Thai_oang                     0x0dcd  /* U+0E2D THAI CHARACTER O ANG */
#define XK_Thai_honokhuk                 0x0dce  /* U+0E2E THAI CHARACTER HO NOKHUK */
#define XK_Thai_paiyannoi                0x0dcf  /* U+0E2F THAI CHARACTER PAIYANNOI */
#define XK_Thai_saraa                    0x0dd0  /* U+0E30 THAI CHARACTER SARA A */
#define XK_Thai_maihanakat               0x0dd1  /* U+0E31 THAI CHARACTER MAI HAN-AKAT */
#define XK_Thai_saraaa                   0x0dd2  /* U+0E32 THAI CHARACTER SARA AA */
#define XK_Thai_saraam                   0x0dd3  /* U+0E33 THAI CHARACTER SARA AM */
#define XK_Thai_sarai                    0x0dd4  /* U+0E34 THAI CHARACTER SARA I */
#define XK_Thai_saraii                   0x0dd5  /* U+0E35 THAI CHARACTER SARA II */
#define XK_Thai_saraue                   0x0dd6  /* U+0E36 THAI CHARACTER SARA UE */
#define XK_Thai_sarauee                  0x0dd7  /* U+0E37 THAI CHARACTER SARA UEE */
#define XK_Thai_sarau                    0x0dd8  /* U+0E38 THAI CHARACTER SARA U */
#define XK_Thai_sarauu                   0x0dd9  /* U+0E39 THAI CHARACTER SARA UU */
#define XK_Thai_phinthu                  0x0dda  /* U+0E3A THAI CHARACTER PHINTHU */
#define XK_Thai_maihanakat_maitho        0x0dde
#define XK_Thai_baht                     0x0ddf  /* U+0E3F THAI CURRENCY SYMBOL BAHT */
#define XK_Thai_sarae                    0x0de0  /* U+0E40 THAI CHARACTER SARA E */
#define XK_Thai_saraae                   0x0de1  /* U+0E41 THAI CHARACTER SARA AE */
#define XK_Thai_sarao                    0x0de2  /* U+0E42 THAI CHARACTER SARA O */
#define XK_Thai_saraaimaimuan            0x0de3  /* U+0E43 THAI CHARACTER SARA AI MAIMUAN */
#define XK_Thai_saraaimaimalai           0x0de4  /* U+0E44 THAI CHARACTER SARA AI MAIMALAI */
#define XK_Thai_lakkhangyao              0x0de5  /* U+0E45 THAI CHARACTER LAKKHANGYAO */
#define XK_Thai_maiyamok                 0x0de6  /* U+0E46 THAI CHARACTER MAIYAMOK */
#define XK_Thai_maitaikhu                0x0de7  /* U+0E47 THAI CHARACTER MAITAIKHU */
#define XK_Thai_maiek                    0x0de8  /* U+0E48 THAI CHARACTER MAI EK */
#define XK_Thai_maitho                   0x0de9  /* U+0E49 THAI CHARACTER MAI THO */
#define XK_Thai_maitri                   0x0dea  /* U+0E4A THAI CHARACTER MAI TRI */
#define XK_Thai_maichattawa              0x0deb  /* U+0E4B THAI CHARACTER MAI CHATTAWA */
#define XK_Thai_thanthakhat              0x0dec  /* U+0E4C THAI CHARACTER THANTHAKHAT */
#define XK_Thai_nikhahit                 0x0ded  /* U+0E4D THAI CHARACTER NIKHAHIT */
#define XK_Thai_leksun                   0x0df0  /* U+0E50 THAI DIGIT ZERO */
#define XK_Thai_leknung                  0x0df1  /* U+0E51 THAI DIGIT ONE */
#define XK_Thai_leksong                  0x0df2  /* U+0E52 THAI DIGIT TWO */
#define XK_Thai_leksam                   0x0df3  /* U+0E53 THAI DIGIT THREE */
#define XK_Thai_leksi                    0x0df4  /* U+0E54 THAI DIGIT FOUR */
#define XK_Thai_lekha                    0x0df5  /* U+0E55 THAI DIGIT FIVE */
#define XK_Thai_lekhok                   0x0df6  /* U+0E56 THAI DIGIT SIX */
#define XK_Thai_lekchet                  0x0df7  /* U+0E57 THAI DIGIT SEVEN */
#define XK_Thai_lekpaet                  0x0df8  /* U+0E58 THAI DIGIT EIGHT */
#define XK_Thai_lekkao                   0x0df9  /* U+0E59 THAI DIGIT NINE */
/* XK_THAI */

/*
 * Korean
 * Byte 3 = 0x0e
 */



#define XK_Hangul                        0xff31  /* Hangul start/stop(toggle) */
#define XK_Hangul_Start                  0xff32  /* Hangul start */
#define XK_Hangul_End                    0xff33  /* Hangul end, English start */
#define XK_Hangul_Hanja                  0xff34  /* Start Hangul->Hanja Conversion */
#define XK_Hangul_Jamo                   0xff35  /* Hangul Jamo mode */
#define XK_Hangul_Romaja                 0xff36  /* Hangul Romaja mode */
#define XK_Hangul_Codeinput              0xff37  /* Hangul code input mode */
#define XK_Hangul_Jeonja                 0xff38  /* Jeonja mode */
#define XK_Hangul_Banja                  0xff39  /* Banja mode */
#define XK_Hangul_PreHanja               0xff3a  /* Pre Hanja conversion */
#define XK_Hangul_PostHanja              0xff3b  /* Post Hanja conversion */
#define XK_Hangul_SingleCandidate        0xff3c  /* Single candidate */
#define XK_Hangul_MultipleCandidate      0xff3d  /* Multiple candidate */
#define XK_Hangul_PreviousCandidate      0xff3e  /* Previous candidate */
#define XK_Hangul_Special                0xff3f  /* Special symbols */
#define XK_Hangul_switch                 0xff7e  /* Alias for mode_switch */

/* Hangul Consonant Characters */
#define XK_Hangul_Kiyeog                 0x0ea1
#define XK_Hangul_SsangKiyeog            0x0ea2
#define XK_Hangul_KiyeogSios             0x0ea3
#define XK_Hangul_Nieun                  0x0ea4
#define XK_Hangul_NieunJieuj             0x0ea5
#define XK_Hangul_NieunHieuh             0x0ea6
#define XK_Hangul_Dikeud                 0x0ea7
#define XK_Hangul_SsangDikeud            0x0ea8
#define XK_Hangul_Rieul                  0x0ea9
#define XK_Hangul_RieulKiyeog            0x0eaa
#define XK_Hangul_RieulMieum             0x0eab
#define XK_Hangul_RieulPieub             0x0eac
#define XK_Hangul_RieulSios              0x0ead
#define XK_Hangul_RieulTieut             0x0eae
#define XK_Hangul_RieulPhieuf            0x0eaf
#define XK_Hangul_RieulHieuh             0x0eb0
#define XK_Hangul_Mieum                  0x0eb1
#define XK_Hangul_Pieub                  0x0eb2
#define XK_Hangul_SsangPieub             0x0eb3
#define XK_Hangul_PieubSios              0x0eb4
#define XK_Hangul_Sios                   0x0eb5
#define XK_Hangul_SsangSios              0x0eb6
#define XK_Hangul_Ieung                  0x0eb7
#define XK_Hangul_Jieuj                  0x0eb8
#define XK_Hangul_SsangJieuj             0x0eb9
#define XK_Hangul_Cieuc                  0x0eba
#define XK_Hangul_Khieuq                 0x0ebb
#define XK_Hangul_Tieut                  0x0ebc
#define XK_Hangul_Phieuf                 0x0ebd
#define XK_Hangul_Hieuh                  0x0ebe

/* Hangul Vowel Characters */
#define XK_Hangul_A                      0x0ebf
#define XK_Hangul_AE                     0x0ec0
#define XK_Hangul_YA                     0x0ec1
#define XK_Hangul_YAE                    0x0ec2
#define XK_Hangul_EO                     0x0ec3
#define XK_Hangul_E                      0x0ec4
#define XK_Hangul_YEO                    0x0ec5
#define XK_Hangul_YE                     0x0ec6
#define XK_Hangul_O                      0x0ec7
#define XK_Hangul_WA                     0x0ec8
#define XK_Hangul_WAE                    0x0ec9
#define XK_Hangul_OE                     0x0eca
#define XK_Hangul_YO                     0x0ecb
#define XK_Hangul_U                      0x0ecc
#define XK_Hangul_WEO                    0x0ecd
#define XK_Hangul_WE                     0x0ece
#define XK_Hangul_WI                     0x0ecf
#define XK_Hangul_YU                     0x0ed0
#define XK_Hangul_EU                     0x0ed1
#define XK_Hangul_YI                     0x0ed2
#define XK_Hangul_I                      0x0ed3

/* Hangul syllable-final (JongSeong) Characters */
#define XK_Hangul_J_Kiyeog               0x0ed4
#define XK_Hangul_J_SsangKiyeog          0x0ed5
#define XK_Hangul_J_KiyeogSios           0x0ed6
#define XK_Hangul_J_Nieun                0x0ed7
#define XK_Hangul_J_NieunJieuj           0x0ed8
#define XK_Hangul_J_NieunHieuh           0x0ed9
#define XK_Hangul_J_Dikeud               0x0eda
#define XK_Hangul_J_Rieul                0x0edb
#define XK_Hangul_J_RieulKiyeog          0x0edc
#define XK_Hangul_J_RieulMieum           0x0edd
#define XK_Hangul_J_RieulPieub           0x0ede
#define XK_Hangul_J_RieulSios            0x0edf
#define XK_Hangul_J_RieulTieut           0x0ee0
#define XK_Hangul_J_RieulPhieuf          0x0ee1
#define XK_Hangul_J_RieulHieuh           0x0ee2
#define XK_Hangul_J_Mieum                0x0ee3
#define XK_Hangul_J_Pieub                0x0ee4
#define XK_Hangul_J_PieubSios            0x0ee5
#define XK_Hangul_J_Sios                 0x0ee6
#define XK_Hangul_J_SsangSios            0x0ee7
#define XK_Hangul_J_Ieung                0x0ee8
#define XK_Hangul_J_Jieuj                0x0ee9
#define XK_Hangul_J_Cieuc                0x0eea
#define XK_Hangul_J_Khieuq               0x0eeb
#define XK_Hangul_J_Tieut                0x0eec
#define XK_Hangul_J_Phieuf               0x0eed
#define XK_Hangul_J_Hieuh                0x0eee

/* Ancient Hangul Consonant Characters */
#define XK_Hangul_RieulYeorinHieuh       0x0eef
#define XK_Hangul_SunkyeongeumMieum      0x0ef0
#define XK_Hangul_SunkyeongeumPieub      0x0ef1
#define XK_Hangul_PanSios                0x0ef2
#define XK_Hangul_KkogjiDalrinIeung      0x0ef3
#define XK_Hangul_SunkyeongeumPhieuf     0x0ef4
#define XK_Hangul_YeorinHieuh            0x0ef5

/* Ancient Hangul Vowel Characters */
#define XK_Hangul_AraeA                  0x0ef6
#define XK_Hangul_AraeAE                 0x0ef7

/* Ancient Hangul syllable-final (JongSeong) Characters */
#define XK_Hangul_J_PanSios              0x0ef8
#define XK_Hangul_J_KkogjiDalrinIeung    0x0ef9
#define XK_Hangul_J_YeorinHieuh          0x0efa

/* Korean currency symbol */
#define XK_Korean_Won                    0x0eff  /*(U+20A9 WON SIGN)*/

/* XK_KOREAN */

/*
 * Armenian
 */


#define XK_Armenian_ligature_ew       0x1000587  /* U+0587 ARMENIAN SMALL LIGATURE ECH YIWN */
#define XK_Armenian_full_stop         0x1000589  /* U+0589 ARMENIAN FULL STOP */
#define XK_Armenian_verjaket          0x1000589  /* U+0589 ARMENIAN FULL STOP */
#define XK_Armenian_separation_mark   0x100055d  /* U+055D ARMENIAN COMMA */
#define XK_Armenian_but               0x100055d  /* U+055D ARMENIAN COMMA */
#define XK_Armenian_hyphen            0x100058a  /* U+058A ARMENIAN HYPHEN */
#define XK_Armenian_yentamna          0x100058a  /* U+058A ARMENIAN HYPHEN */
#define XK_Armenian_exclam            0x100055c  /* U+055C ARMENIAN EXCLAMATION MARK */
#define XK_Armenian_amanak            0x100055c  /* U+055C ARMENIAN EXCLAMATION MARK */
#define XK_Armenian_accent            0x100055b  /* U+055B ARMENIAN EMPHASIS MARK */
#define XK_Armenian_shesht            0x100055b  /* U+055B ARMENIAN EMPHASIS MARK */
#define XK_Armenian_question          0x100055e  /* U+055E ARMENIAN QUESTION MARK */
#define XK_Armenian_paruyk            0x100055e  /* U+055E ARMENIAN QUESTION MARK */
#define XK_Armenian_AYB               0x1000531  /* U+0531 ARMENIAN CAPITAL LETTER AYB */
#define XK_Armenian_ayb               0x1000561  /* U+0561 ARMENIAN SMALL LETTER AYB */
#define XK_Armenian_BEN               0x1000532  /* U+0532 ARMENIAN CAPITAL LETTER BEN */
#define XK_Armenian_ben               0x1000562  /* U+0562 ARMENIAN SMALL LETTER BEN */
#define XK_Armenian_GIM               0x1000533  /* U+0533 ARMENIAN CAPITAL LETTER GIM */
#define XK_Armenian_gim               0x1000563  /* U+0563 ARMENIAN SMALL LETTER GIM */
#define XK_Armenian_DA                0x1000534  /* U+0534 ARMENIAN CAPITAL LETTER DA */
#define XK_Armenian_da                0x1000564  /* U+0564 ARMENIAN SMALL LETTER DA */
#define XK_Armenian_YECH              0x1000535  /* U+0535 ARMENIAN CAPITAL LETTER ECH */
#define XK_Armenian_yech              0x1000565  /* U+0565 ARMENIAN SMALL LETTER ECH */
#define XK_Armenian_ZA                0x1000536  /* U+0536 ARMENIAN CAPITAL LETTER ZA */
#define XK_Armenian_za                0x1000566  /* U+0566 ARMENIAN SMALL LETTER ZA */
#define XK_Armenian_E                 0x1000537  /* U+0537 ARMENIAN CAPITAL LETTER EH */
#define XK_Armenian_e                 0x1000567  /* U+0567 ARMENIAN SMALL LETTER EH */
#define XK_Armenian_AT                0x1000538  /* U+0538 ARMENIAN CAPITAL LETTER ET */
#define XK_Armenian_at                0x1000568  /* U+0568 ARMENIAN SMALL LETTER ET */
#define XK_Armenian_TO                0x1000539  /* U+0539 ARMENIAN CAPITAL LETTER TO */
#define XK_Armenian_to                0x1000569  /* U+0569 ARMENIAN SMALL LETTER TO */
#define XK_Armenian_ZHE               0x100053a  /* U+053A ARMENIAN CAPITAL LETTER ZHE */
#define XK_Armenian_zhe               0x100056a  /* U+056A ARMENIAN SMALL LETTER ZHE */
#define XK_Armenian_INI               0x100053b  /* U+053B ARMENIAN CAPITAL LETTER INI */
#define XK_Armenian_ini               0x100056b  /* U+056B ARMENIAN SMALL LETTER INI */
#define XK_Armenian_LYUN              0x100053c  /* U+053C ARMENIAN CAPITAL LETTER LIWN */
#define XK_Armenian_lyun              0x100056c  /* U+056C ARMENIAN SMALL LETTER LIWN */
#define XK_Armenian_KHE               0x100053d  /* U+053D ARMENIAN CAPITAL LETTER XEH */
#define XK_Armenian_khe               0x100056d  /* U+056D ARMENIAN SMALL LETTER XEH */
#define XK_Armenian_TSA               0x100053e  /* U+053E ARMENIAN CAPITAL LETTER CA */
#define XK_Armenian_tsa               0x100056e  /* U+056E ARMENIAN SMALL LETTER CA */
#define XK_Armenian_KEN               0x100053f  /* U+053F ARMENIAN CAPITAL LETTER KEN */
#define XK_Armenian_ken               0x100056f  /* U+056F ARMENIAN SMALL LETTER KEN */
#define XK_Armenian_HO                0x1000540  /* U+0540 ARMENIAN CAPITAL LETTER HO */
#define XK_Armenian_ho                0x1000570  /* U+0570 ARMENIAN SMALL LETTER HO */
#define XK_Armenian_DZA               0x1000541  /* U+0541 ARMENIAN CAPITAL LETTER JA */
#define XK_Armenian_dza               0x1000571  /* U+0571 ARMENIAN SMALL LETTER JA */
#define XK_Armenian_GHAT              0x1000542  /* U+0542 ARMENIAN CAPITAL LETTER GHAD */
#define XK_Armenian_ghat              0x1000572  /* U+0572 ARMENIAN SMALL LETTER GHAD */
#define XK_Armenian_TCHE              0x1000543  /* U+0543 ARMENIAN CAPITAL LETTER CHEH */
#define XK_Armenian_tche              0x1000573  /* U+0573 ARMENIAN SMALL LETTER CHEH */
#define XK_Armenian_MEN               0x1000544  /* U+0544 ARMENIAN CAPITAL LETTER MEN */
#define XK_Armenian_men               0x1000574  /* U+0574 ARMENIAN SMALL LETTER MEN */
#define XK_Armenian_HI                0x1000545  /* U+0545 ARMENIAN CAPITAL LETTER YI */
#define XK_Armenian_hi                0x1000575  /* U+0575 ARMENIAN SMALL LETTER YI */
#define XK_Armenian_NU                0x1000546  /* U+0546 ARMENIAN CAPITAL LETTER NOW */
#define XK_Armenian_nu                0x1000576  /* U+0576 ARMENIAN SMALL LETTER NOW */
#define XK_Armenian_SHA               0x1000547  /* U+0547 ARMENIAN CAPITAL LETTER SHA */
#define XK_Armenian_sha               0x1000577  /* U+0577 ARMENIAN SMALL LETTER SHA */
#define XK_Armenian_VO                0x1000548  /* U+0548 ARMENIAN CAPITAL LETTER VO */
#define XK_Armenian_vo                0x1000578  /* U+0578 ARMENIAN SMALL LETTER VO */
#define XK_Armenian_CHA               0x1000549  /* U+0549 ARMENIAN CAPITAL LETTER CHA */
#define XK_Armenian_cha               0x1000579  /* U+0579 ARMENIAN SMALL LETTER CHA */
#define XK_Armenian_PE                0x100054a  /* U+054A ARMENIAN CAPITAL LETTER PEH */
#define XK_Armenian_pe                0x100057a  /* U+057A ARMENIAN SMALL LETTER PEH */
#define XK_Armenian_JE                0x100054b  /* U+054B ARMENIAN CAPITAL LETTER JHEH */
#define XK_Armenian_je                0x100057b  /* U+057B ARMENIAN SMALL LETTER JHEH */
#define XK_Armenian_RA                0x100054c  /* U+054C ARMENIAN CAPITAL LETTER RA */
#define XK_Armenian_ra                0x100057c  /* U+057C ARMENIAN SMALL LETTER RA */
#define XK_Armenian_SE                0x100054d  /* U+054D ARMENIAN CAPITAL LETTER SEH */
#define XK_Armenian_se                0x100057d  /* U+057D ARMENIAN SMALL LETTER SEH */
#define XK_Armenian_VEV               0x100054e  /* U+054E ARMENIAN CAPITAL LETTER VEW */
#define XK_Armenian_vev               0x100057e  /* U+057E ARMENIAN SMALL LETTER VEW */
#define XK_Armenian_TYUN              0x100054f  /* U+054F ARMENIAN CAPITAL LETTER TIWN */
#define XK_Armenian_tyun              0x100057f  /* U+057F ARMENIAN SMALL LETTER TIWN */
#define XK_Armenian_RE                0x1000550  /* U+0550 ARMENIAN CAPITAL LETTER REH */
#define XK_Armenian_re                0x1000580  /* U+0580 ARMENIAN SMALL LETTER REH */
#define XK_Armenian_TSO               0x1000551  /* U+0551 ARMENIAN CAPITAL LETTER CO */
#define XK_Armenian_tso               0x1000581  /* U+0581 ARMENIAN SMALL LETTER CO */
#define XK_Armenian_VYUN              0x1000552  /* U+0552 ARMENIAN CAPITAL LETTER YIWN */
#define XK_Armenian_vyun              0x1000582  /* U+0582 ARMENIAN SMALL LETTER YIWN */
#define XK_Armenian_PYUR              0x1000553  /* U+0553 ARMENIAN CAPITAL LETTER PIWR */
#define XK_Armenian_pyur              0x1000583  /* U+0583 ARMENIAN SMALL LETTER PIWR */
#define XK_Armenian_KE                0x1000554  /* U+0554 ARMENIAN CAPITAL LETTER KEH */
#define XK_Armenian_ke                0x1000584  /* U+0584 ARMENIAN SMALL LETTER KEH */
#define XK_Armenian_O                 0x1000555  /* U+0555 ARMENIAN CAPITAL LETTER OH */
#define XK_Armenian_o                 0x1000585  /* U+0585 ARMENIAN SMALL LETTER OH */
#define XK_Armenian_FE                0x1000556  /* U+0556 ARMENIAN CAPITAL LETTER FEH */
#define XK_Armenian_fe                0x1000586  /* U+0586 ARMENIAN SMALL LETTER FEH */
#define XK_Armenian_apostrophe        0x100055a  /* U+055A ARMENIAN APOSTROPHE */
/* XK_ARMENIAN */

/*
 * Georgian
 */


#define XK_Georgian_an                0x10010d0  /* U+10D0 GEORGIAN LETTER AN */
#define XK_Georgian_ban               0x10010d1  /* U+10D1 GEORGIAN LETTER BAN */
#define XK_Georgian_gan               0x10010d2  /* U+10D2 GEORGIAN LETTER GAN */
#define XK_Georgian_don               0x10010d3  /* U+10D3 GEORGIAN LETTER DON */
#define XK_Georgian_en                0x10010d4  /* U+10D4 GEORGIAN LETTER EN */
#define XK_Georgian_vin               0x10010d5  /* U+10D5 GEORGIAN LETTER VIN */
#define XK_Georgian_zen               0x10010d6  /* U+10D6 GEORGIAN LETTER ZEN */
#define XK_Georgian_tan               0x10010d7  /* U+10D7 GEORGIAN LETTER TAN */
#define XK_Georgian_in                0x10010d8  /* U+10D8 GEORGIAN LETTER IN */
#define XK_Georgian_kan               0x10010d9  /* U+10D9 GEORGIAN LETTER KAN */
#define XK_Georgian_las               0x10010da  /* U+10DA GEORGIAN LETTER LAS */
#define XK_Georgian_man               0x10010db  /* U+10DB GEORGIAN LETTER MAN */
#define XK_Georgian_nar               0x10010dc  /* U+10DC GEORGIAN LETTER NAR */
#define XK_Georgian_on                0x10010dd  /* U+10DD GEORGIAN LETTER ON */
#define XK_Georgian_par               0x10010de  /* U+10DE GEORGIAN LETTER PAR */
#define XK_Georgian_zhar              0x10010df  /* U+10DF GEORGIAN LETTER ZHAR */
#define XK_Georgian_rae               0x10010e0  /* U+10E0 GEORGIAN LETTER RAE */
#define XK_Georgian_san               0x10010e1  /* U+10E1 GEORGIAN LETTER SAN */
#define XK_Georgian_tar               0x10010e2  /* U+10E2 GEORGIAN LETTER TAR */
#define XK_Georgian_un                0x10010e3  /* U+10E3 GEORGIAN LETTER UN */
#define XK_Georgian_phar              0x10010e4  /* U+10E4 GEORGIAN LETTER PHAR */
#define XK_Georgian_khar              0x10010e5  /* U+10E5 GEORGIAN LETTER KHAR */
#define XK_Georgian_ghan              0x10010e6  /* U+10E6 GEORGIAN LETTER GHAN */
#define XK_Georgian_qar               0x10010e7  /* U+10E7 GEORGIAN LETTER QAR */
#define XK_Georgian_shin              0x10010e8  /* U+10E8 GEORGIAN LETTER SHIN */
#define XK_Georgian_chin              0x10010e9  /* U+10E9 GEORGIAN LETTER CHIN */
#define XK_Georgian_can               0x10010ea  /* U+10EA GEORGIAN LETTER CAN */
#define XK_Georgian_jil               0x10010eb  /* U+10EB GEORGIAN LETTER JIL */
#define XK_Georgian_cil               0x10010ec  /* U+10EC GEORGIAN LETTER CIL */
#define XK_Georgian_char              0x10010ed  /* U+10ED GEORGIAN LETTER CHAR */
#define XK_Georgian_xan               0x10010ee  /* U+10EE GEORGIAN LETTER XAN */
#define XK_Georgian_jhan              0x10010ef  /* U+10EF GEORGIAN LETTER JHAN */
#define XK_Georgian_hae               0x10010f0  /* U+10F0 GEORGIAN LETTER HAE */
#define XK_Georgian_he                0x10010f1  /* U+10F1 GEORGIAN LETTER HE */
#define XK_Georgian_hie               0x10010f2  /* U+10F2 GEORGIAN LETTER HIE */
#define XK_Georgian_we                0x10010f3  /* U+10F3 GEORGIAN LETTER WE */
#define XK_Georgian_har               0x10010f4  /* U+10F4 GEORGIAN LETTER HAR */
#define XK_Georgian_hoe               0x10010f5  /* U+10F5 GEORGIAN LETTER HOE */
#define XK_Georgian_fi                0x10010f6  /* U+10F6 GEORGIAN LETTER FI */
/* XK_GEORGIAN */

/*
 * Azeri (and other Turkic or Caucasian languages)
 */


/* latin */
#define XK_Xabovedot                  0x1001e8a  /* U+1E8A LATIN CAPITAL LETTER X WITH DOT ABOVE */
#define XK_Ibreve                     0x100012c  /* U+012C LATIN CAPITAL LETTER I WITH BREVE */
#define XK_Zstroke                    0x10001b5  /* U+01B5 LATIN CAPITAL LETTER Z WITH STROKE */
#define XK_Gcaron                     0x10001e6  /* U+01E6 LATIN CAPITAL LETTER G WITH CARON */
#define XK_Ocaron                     0x10001d1  /* U+01D2 LATIN CAPITAL LETTER O WITH CARON */
#define XK_Obarred                    0x100019f  /* U+019F LATIN CAPITAL LETTER O WITH MIDDLE TILDE */
#define XK_xabovedot                  0x1001e8b  /* U+1E8B LATIN SMALL LETTER X WITH DOT ABOVE */
#define XK_ibreve                     0x100012d  /* U+012D LATIN SMALL LETTER I WITH BREVE */
#define XK_zstroke                    0x10001b6  /* U+01B6 LATIN SMALL LETTER Z WITH STROKE */
#define XK_gcaron                     0x10001e7  /* U+01E7 LATIN SMALL LETTER G WITH CARON */
#define XK_ocaron                     0x10001d2  /* U+01D2 LATIN SMALL LETTER O WITH CARON */
#define XK_obarred                    0x1000275  /* U+0275 LATIN SMALL LETTER BARRED O */
#define XK_SCHWA                      0x100018f  /* U+018F LATIN CAPITAL LETTER SCHWA */
#define XK_schwa                      0x1000259  /* U+0259 LATIN SMALL LETTER SCHWA */
/* those are not really Caucasus */
/* For Inupiak */
#define XK_Lbelowdot                  0x1001e36  /* U+1E36 LATIN CAPITAL LETTER L WITH DOT BELOW */
#define XK_lbelowdot                  0x1001e37  /* U+1E37 LATIN SMALL LETTER L WITH DOT BELOW */
/* XK_CAUCASUS */

/*
 * Vietnamese
 */
 

#define XK_Abelowdot                  0x1001ea0  /* U+1EA0 LATIN CAPITAL LETTER A WITH DOT BELOW */
#define XK_abelowdot                  0x1001ea1  /* U+1EA1 LATIN SMALL LETTER A WITH DOT BELOW */
#define XK_Ahook                      0x1001ea2  /* U+1EA2 LATIN CAPITAL LETTER A WITH HOOK ABOVE */
#define XK_ahook                      0x1001ea3  /* U+1EA3 LATIN SMALL LETTER A WITH HOOK ABOVE */
#define XK_Acircumflexacute           0x1001ea4  /* U+1EA4 LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE */
#define XK_acircumflexacute           0x1001ea5  /* U+1EA5 LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE */
#define XK_Acircumflexgrave           0x1001ea6  /* U+1EA6 LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE */
#define XK_acircumflexgrave           0x1001ea7  /* U+1EA7 LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE */
#define XK_Acircumflexhook            0x1001ea8  /* U+1EA8 LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE */
#define XK_acircumflexhook            0x1001ea9  /* U+1EA9 LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE */
#define XK_Acircumflextilde           0x1001eaa  /* U+1EAA LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE */
#define XK_acircumflextilde           0x1001eab  /* U+1EAB LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE */
#define XK_Acircumflexbelowdot        0x1001eac  /* U+1EAC LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW */
#define XK_acircumflexbelowdot        0x1001ead  /* U+1EAD LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW */
#define XK_Abreveacute                0x1001eae  /* U+1EAE LATIN CAPITAL LETTER A WITH BREVE AND ACUTE */
#define XK_abreveacute                0x1001eaf  /* U+1EAF LATIN SMALL LETTER A WITH BREVE AND ACUTE */
#define XK_Abrevegrave                0x1001eb0  /* U+1EB0 LATIN CAPITAL LETTER A WITH BREVE AND GRAVE */
#define XK_abrevegrave                0x1001eb1  /* U+1EB1 LATIN SMALL LETTER A WITH BREVE AND GRAVE */
#define XK_Abrevehook                 0x1001eb2  /* U+1EB2 LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE */
#define XK_abrevehook                 0x1001eb3  /* U+1EB3 LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE */
#define XK_Abrevetilde                0x1001eb4  /* U+1EB4 LATIN CAPITAL LETTER A WITH BREVE AND TILDE */
#define XK_abrevetilde                0x1001eb5  /* U+1EB5 LATIN SMALL LETTER A WITH BREVE AND TILDE */
#define XK_Abrevebelowdot             0x1001eb6  /* U+1EB6 LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW */
#define XK_abrevebelowdot             0x1001eb7  /* U+1EB7 LATIN SMALL LETTER A WITH BREVE AND DOT BELOW */
#define XK_Ebelowdot                  0x1001eb8  /* U+1EB8 LATIN CAPITAL LETTER E WITH DOT BELOW */
#define XK_ebelowdot                  0x1001eb9  /* U+1EB9 LATIN SMALL LETTER E WITH DOT BELOW */
#define XK_Ehook                      0x1001eba  /* U+1EBA LATIN CAPITAL LETTER E WITH HOOK ABOVE */
#define XK_ehook                      0x1001ebb  /* U+1EBB LATIN SMALL LETTER E WITH HOOK ABOVE */
#define XK_Etilde                     0x1001ebc  /* U+1EBC LATIN CAPITAL LETTER E WITH TILDE */
#define XK_etilde                     0x1001ebd  /* U+1EBD LATIN SMALL LETTER E WITH TILDE */
#define XK_Ecircumflexacute           0x1001ebe  /* U+1EBE LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE */
#define XK_ecircumflexacute           0x1001ebf  /* U+1EBF LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE */
#define XK_Ecircumflexgrave           0x1001ec0  /* U+1EC0 LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE */
#define XK_ecircumflexgrave           0x1001ec1  /* U+1EC1 LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE */
#define XK_Ecircumflexhook            0x1001ec2  /* U+1EC2 LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE */
#define XK_ecircumflexhook            0x1001ec3  /* U+1EC3 LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE */
#define XK_Ecircumflextilde           0x1001ec4  /* U+1EC4 LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE */
#define XK_ecircumflextilde           0x1001ec5  /* U+1EC5 LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE */
#define XK_Ecircumflexbelowdot        0x1001ec6  /* U+1EC6 LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW */
#define XK_ecircumflexbelowdot        0x1001ec7  /* U+1EC7 LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW */
#define XK_Ihook                      0x1001ec8  /* U+1EC8 LATIN CAPITAL LETTER I WITH HOOK ABOVE */
#define XK_ihook                      0x1001ec9  /* U+1EC9 LATIN SMALL LETTER I WITH HOOK ABOVE */
#define XK_Ibelowdot                  0x1001eca  /* U+1ECA LATIN CAPITAL LETTER I WITH DOT BELOW */
#define XK_ibelowdot                  0x1001ecb  /* U+1ECB LATIN SMALL LETTER I WITH DOT BELOW */
#define XK_Obelowdot                  0x1001ecc  /* U+1ECC LATIN CAPITAL LETTER O WITH DOT BELOW */
#define XK_obelowdot                  0x1001ecd  /* U+1ECD LATIN SMALL LETTER O WITH DOT BELOW */
#define XK_Ohook                      0x1001ece  /* U+1ECE LATIN CAPITAL LETTER O WITH HOOK ABOVE */
#define XK_ohook                      0x1001ecf  /* U+1ECF LATIN SMALL LETTER O WITH HOOK ABOVE */
#define XK_Ocircumflexacute           0x1001ed0  /* U+1ED0 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE */
#define XK_ocircumflexacute           0x1001ed1  /* U+1ED1 LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE */
#define XK_Ocircumflexgrave           0x1001ed2  /* U+1ED2 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE */
#define XK_ocircumflexgrave           0x1001ed3  /* U+1ED3 LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE */
#define XK_Ocircumflexhook            0x1001ed4  /* U+1ED4 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE */
#define XK_ocircumflexhook            0x1001ed5  /* U+1ED5 LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE */
#define XK_Ocircumflextilde           0x1001ed6  /* U+1ED6 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE */
#define XK_ocircumflextilde           0x1001ed7  /* U+1ED7 LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE */
#define XK_Ocircumflexbelowdot        0x1001ed8  /* U+1ED8 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW */
#define XK_ocircumflexbelowdot        0x1001ed9  /* U+1ED9 LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW */
#define XK_Ohornacute                 0x1001eda  /* U+1EDA LATIN CAPITAL LETTER O WITH HORN AND ACUTE */
#define XK_ohornacute                 0x1001edb  /* U+1EDB LATIN SMALL LETTER O WITH HORN AND ACUTE */
#define XK_Ohorngrave                 0x1001edc  /* U+1EDC LATIN CAPITAL LETTER O WITH HORN AND GRAVE */
#define XK_ohorngrave                 0x1001edd  /* U+1EDD LATIN SMALL LETTER O WITH HORN AND GRAVE */
#define XK_Ohornhook                  0x1001ede  /* U+1EDE LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE */
#define XK_ohornhook                  0x1001edf  /* U+1EDF LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE */
#define XK_Ohorntilde                 0x1001ee0  /* U+1EE0 LATIN CAPITAL LETTER O WITH HORN AND TILDE */
#define XK_ohorntilde                 0x1001ee1  /* U+1EE1 LATIN SMALL LETTER O WITH HORN AND TILDE */
#define XK_Ohornbelowdot              0x1001ee2  /* U+1EE2 LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW */
#define XK_ohornbelowdot              0x1001ee3  /* U+1EE3 LATIN SMALL LETTER O WITH HORN AND DOT BELOW */
#define XK_Ubelowdot                  0x1001ee4  /* U+1EE4 LATIN CAPITAL LETTER U WITH DOT BELOW */
#define XK_ubelowdot                  0x1001ee5  /* U+1EE5 LATIN SMALL LETTER U WITH DOT BELOW */
#define XK_Uhook                      0x1001ee6  /* U+1EE6 LATIN CAPITAL LETTER U WITH HOOK ABOVE */
#define XK_uhook                      0x1001ee7  /* U+1EE7 LATIN SMALL LETTER U WITH HOOK ABOVE */
#define XK_Uhornacute                 0x1001ee8  /* U+1EE8 LATIN CAPITAL LETTER U WITH HORN AND ACUTE */
#define XK_uhornacute                 0x1001ee9  /* U+1EE9 LATIN SMALL LETTER U WITH HORN AND ACUTE */
#define XK_Uhorngrave                 0x1001eea  /* U+1EEA LATIN CAPITAL LETTER U WITH HORN AND GRAVE */
#define XK_uhorngrave                 0x1001eeb  /* U+1EEB LATIN SMALL LETTER U WITH HORN AND GRAVE */
#define XK_Uhornhook                  0x1001eec  /* U+1EEC LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE */
#define XK_uhornhook                  0x1001eed  /* U+1EED LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE */
#define XK_Uhorntilde                 0x1001eee  /* U+1EEE LATIN CAPITAL LETTER U WITH HORN AND TILDE */
#define XK_uhorntilde                 0x1001eef  /* U+1EEF LATIN SMALL LETTER U WITH HORN AND TILDE */
#define XK_Uhornbelowdot              0x1001ef0  /* U+1EF0 LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW */
#define XK_uhornbelowdot              0x1001ef1  /* U+1EF1 LATIN SMALL LETTER U WITH HORN AND DOT BELOW */
#define XK_Ybelowdot                  0x1001ef4  /* U+1EF4 LATIN CAPITAL LETTER Y WITH DOT BELOW */
#define XK_ybelowdot                  0x1001ef5  /* U+1EF5 LATIN SMALL LETTER Y WITH DOT BELOW */
#define XK_Yhook                      0x1001ef6  /* U+1EF6 LATIN CAPITAL LETTER Y WITH HOOK ABOVE */
#define XK_yhook                      0x1001ef7  /* U+1EF7 LATIN SMALL LETTER Y WITH HOOK ABOVE */
#define XK_Ytilde                     0x1001ef8  /* U+1EF8 LATIN CAPITAL LETTER Y WITH TILDE */
#define XK_ytilde                     0x1001ef9  /* U+1EF9 LATIN SMALL LETTER Y WITH TILDE */
#define XK_Ohorn                      0x10001a0  /* U+01A0 LATIN CAPITAL LETTER O WITH HORN */
#define XK_ohorn                      0x10001a1  /* U+01A1 LATIN SMALL LETTER O WITH HORN */
#define XK_Uhorn                      0x10001af  /* U+01AF LATIN CAPITAL LETTER U WITH HORN */
#define XK_uhorn                      0x10001b0  /* U+01B0 LATIN SMALL LETTER U WITH HORN */

/* XK_VIETNAMESE */


#define XK_EcuSign                    0x10020a0  /* U+20A0 EURO-CURRENCY SIGN */
#define XK_ColonSign                  0x10020a1  /* U+20A1 COLON SIGN */
#define XK_CruzeiroSign               0x10020a2  /* U+20A2 CRUZEIRO SIGN */
#define XK_FFrancSign                 0x10020a3  /* U+20A3 FRENCH FRANC SIGN */
#define XK_LiraSign                   0x10020a4  /* U+20A4 LIRA SIGN */
#define XK_MillSign                   0x10020a5  /* U+20A5 MILL SIGN */
#define XK_NairaSign                  0x10020a6  /* U+20A6 NAIRA SIGN */
#define XK_PesetaSign                 0x10020a7  /* U+20A7 PESETA SIGN */
#define XK_RupeeSign                  0x10020a8  /* U+20A8 RUPEE SIGN */
#define XK_WonSign                    0x10020a9  /* U+20A9 WON SIGN */
#define XK_NewSheqelSign              0x10020aa  /* U+20AA NEW SHEQEL SIGN */
#define XK_DongSign                   0x10020ab  /* U+20AB DONG SIGN */
#define XK_EuroSign                      0x20ac  /* U+20AC EURO SIGN */
/* XK_CURRENCY */


/* one, two and three are defined above. */
#define XK_zerosuperior               0x1002070  /* U+2070 SUPERSCRIPT ZERO */
#define XK_foursuperior               0x1002074  /* U+2074 SUPERSCRIPT FOUR */
#define XK_fivesuperior               0x1002075  /* U+2075 SUPERSCRIPT FIVE */
#define XK_sixsuperior                0x1002076  /* U+2076 SUPERSCRIPT SIX */
#define XK_sevensuperior              0x1002077  /* U+2077 SUPERSCRIPT SEVEN */
#define XK_eightsuperior              0x1002078  /* U+2078 SUPERSCRIPT EIGHT */
#define XK_ninesuperior               0x1002079  /* U+2079 SUPERSCRIPT NINE */
#define XK_zerosubscript              0x1002080  /* U+2080 SUBSCRIPT ZERO */
#define XK_onesubscript               0x1002081  /* U+2081 SUBSCRIPT ONE */
#define XK_twosubscript               0x1002082  /* U+2082 SUBSCRIPT TWO */
#define XK_threesubscript             0x1002083  /* U+2083 SUBSCRIPT THREE */
#define XK_foursubscript              0x1002084  /* U+2084 SUBSCRIPT FOUR */
#define XK_fivesubscript              0x1002085  /* U+2085 SUBSCRIPT FIVE */
#define XK_sixsubscript               0x1002086  /* U+2086 SUBSCRIPT SIX */
#define XK_sevensubscript             0x1002087  /* U+2087 SUBSCRIPT SEVEN */
#define XK_eightsubscript             0x1002088  /* U+2088 SUBSCRIPT EIGHT */
#define XK_ninesubscript              0x1002089  /* U+2089 SUBSCRIPT NINE */
#define XK_partdifferential           0x1002202  /* U+2202 PARTIAL DIFFERENTIAL */
#define XK_emptyset                   0x1002205  /* U+2205 NULL SET */
#define XK_elementof                  0x1002208  /* U+2208 ELEMENT OF */
#define XK_notelementof               0x1002209  /* U+2209 NOT AN ELEMENT OF */
#define XK_containsas                 0x100220B  /* U+220B CONTAINS AS MEMBER */
#define XK_squareroot                 0x100221A  /* U+221A SQUARE ROOT */
#define XK_cuberoot                   0x100221B  /* U+221B CUBE ROOT */
#define XK_fourthroot                 0x100221C  /* U+221C FOURTH ROOT */
#define XK_dintegral                  0x100222C  /* U+222C DOUBLE INTEGRAL */
#define XK_tintegral                  0x100222D  /* U+222D TRIPLE INTEGRAL */
#define XK_because                    0x1002235  /* U+2235 BECAUSE */
#define XK_approxeq                   0x1002248  /* U+2245 ALMOST EQUAL TO */
#define XK_notapproxeq                0x1002247  /* U+2247 NOT ALMOST EQUAL TO */
#define XK_notidentical               0x1002262  /* U+2262 NOT IDENTICAL TO */
#define XK_stricteq                   0x1002263  /* U+2263 STRICTLY EQUIVALENT TO */          
/* XK_MATHEMATICAL */


#define XK_braille_dot_1                 0xfff1
#define XK_braille_dot_2                 0xfff2
#define XK_braille_dot_3                 0xfff3
#define XK_braille_dot_4                 0xfff4
#define XK_braille_dot_5                 0xfff5
#define XK_braille_dot_6                 0xfff6
#define XK_braille_dot_7                 0xfff7
#define XK_braille_dot_8                 0xfff8
#define XK_braille_dot_9                 0xfff9
#define XK_braille_dot_10                0xfffa
#define XK_braille_blank              0x1002800  /* U+2800 BRAILLE PATTERN BLANK */
#define XK_braille_dots_1             0x1002801  /* U+2801 BRAILLE PATTERN DOTS-1 */
#define XK_braille_dots_2             0x1002802  /* U+2802 BRAILLE PATTERN DOTS-2 */
#define XK_braille_dots_12            0x1002803  /* U+2803 BRAILLE PATTERN DOTS-12 */
#define XK_braille_dots_3             0x1002804  /* U+2804 BRAILLE PATTERN DOTS-3 */
#define XK_braille_dots_13            0x1002805  /* U+2805 BRAILLE PATTERN DOTS-13 */
#define XK_braille_dots_23            0x1002806  /* U+2806 BRAILLE PATTERN DOTS-23 */
#define XK_braille_dots_123           0x1002807  /* U+2807 BRAILLE PATTERN DOTS-123 */
#define XK_braille_dots_4             0x1002808  /* U+2808 BRAILLE PATTERN DOTS-4 */
#define XK_braille_dots_14            0x1002809  /* U+2809 BRAILLE PATTERN DOTS-14 */
#define XK_braille_dots_24            0x100280a  /* U+280a BRAILLE PATTERN DOTS-24 */
#define XK_braille_dots_124           0x100280b  /* U+280b BRAILLE PATTERN DOTS-124 */
#define XK_braille_dots_34            0x100280c  /* U+280c BRAILLE PATTERN DOTS-34 */
#define XK_braille_dots_134           0x100280d  /* U+280d BRAILLE PATTERN DOTS-134 */
#define XK_braille_dots_234           0x100280e  /* U+280e BRAILLE PATTERN DOTS-234 */
#define XK_braille_dots_1234          0x100280f  /* U+280f BRAILLE PATTERN DOTS-1234 */
#define XK_braille_dots_5             0x1002810  /* U+2810 BRAILLE PATTERN DOTS-5 */
#define XK_braille_dots_15            0x1002811  /* U+2811 BRAILLE PATTERN DOTS-15 */
#define XK_braille_dots_25            0x1002812  /* U+2812 BRAILLE PATTERN DOTS-25 */
#define XK_braille_dots_125           0x1002813  /* U+2813 BRAILLE PATTERN DOTS-125 */
#define XK_braille_dots_35            0x1002814  /* U+2814 BRAILLE PATTERN DOTS-35 */
#define XK_braille_dots_135           0x1002815  /* U+2815 BRAILLE PATTERN DOTS-135 */
#define XK_braille_dots_235           0x1002816  /* U+2816 BRAILLE PATTERN DOTS-235 */
#define XK_braille_dots_1235          0x1002817  /* U+2817 BRAILLE PATTERN DOTS-1235 */
#define XK_braille_dots_45            0x1002818  /* U+2818 BRAILLE PATTERN DOTS-45 */
#define XK_braille_dots_145           0x1002819  /* U+2819 BRAILLE PATTERN DOTS-145 */
#define XK_braille_dots_245           0x100281a  /* U+281a BRAILLE PATTERN DOTS-245 */
#define XK_braille_dots_1245          0x100281b  /* U+281b BRAILLE PATTERN DOTS-1245 */
#define XK_braille_dots_345           0x100281c  /* U+281c BRAILLE PATTERN DOTS-345 */
#define XK_braille_dots_1345          0x100281d  /* U+281d BRAILLE PATTERN DOTS-1345 */
#define XK_braille_dots_2345          0x100281e  /* U+281e BRAILLE PATTERN DOTS-2345 */
#define XK_braille_dots_12345         0x100281f  /* U+281f BRAILLE PATTERN DOTS-12345 */
#define XK_braille_dots_6             0x1002820  /* U+2820 BRAILLE PATTERN DOTS-6 */
#define XK_braille_dots_16            0x1002821  /* U+2821 BRAILLE PATTERN DOTS-16 */
#define XK_braille_dots_26            0x1002822  /* U+2822 BRAILLE PATTERN DOTS-26 */
#define XK_braille_dots_126           0x1002823  /* U+2823 BRAILLE PATTERN DOTS-126 */
#define XK_braille_dots_36            0x1002824  /* U+2824 BRAILLE PATTERN DOTS-36 */
#define XK_braille_dots_136           0x1002825  /* U+2825 BRAILLE PATTERN DOTS-136 */
#define XK_braille_dots_236           0x1002826  /* U+2826 BRAILLE PATTERN DOTS-236 */
#define XK_braille_dots_1236          0x1002827  /* U+2827 BRAILLE PATTERN DOTS-1236 */
#define XK_braille_dots_46            0x1002828  /* U+2828 BRAILLE PATTERN DOTS-46 */
#define XK_braille_dots_146           0x1002829  /* U+2829 BRAILLE PATTERN DOTS-146 */
#define XK_braille_dots_246           0x100282a  /* U+282a BRAILLE PATTERN DOTS-246 */
#define XK_braille_dots_1246          0x100282b  /* U+282b BRAILLE PATTERN DOTS-1246 */
#define XK_braille_dots_346           0x100282c  /* U+282c BRAILLE PATTERN DOTS-346 */
#define XK_braille_dots_1346          0x100282d  /* U+282d BRAILLE PATTERN DOTS-1346 */
#define XK_braille_dots_2346          0x100282e  /* U+282e BRAILLE PATTERN DOTS-2346 */
#define XK_braille_dots_12346         0x100282f  /* U+282f BRAILLE PATTERN DOTS-12346 */
#define XK_braille_dots_56            0x1002830  /* U+2830 BRAILLE PATTERN DOTS-56 */
#define XK_braille_dots_156           0x1002831  /* U+2831 BRAILLE PATTERN DOTS-156 */
#define XK_braille_dots_256           0x1002832  /* U+2832 BRAILLE PATTERN DOTS-256 */
#define XK_braille_dots_1256          0x1002833  /* U+2833 BRAILLE PATTERN DOTS-1256 */
#define XK_braille_dots_356           0x1002834  /* U+2834 BRAILLE PATTERN DOTS-356 */
#define XK_braille_dots_1356          0x1002835  /* U+2835 BRAILLE PATTERN DOTS-1356 */
#define XK_braille_dots_2356          0x1002836  /* U+2836 BRAILLE PATTERN DOTS-2356 */
#define XK_braille_dots_12356         0x1002837  /* U+2837 BRAILLE PATTERN DOTS-12356 */
#define XK_braille_dots_456           0x1002838  /* U+2838 BRAILLE PATTERN DOTS-456 */
#define XK_braille_dots_1456          0x1002839  /* U+2839 BRAILLE PATTERN DOTS-1456 */
#define XK_braille_dots_2456          0x100283a  /* U+283a BRAILLE PATTERN DOTS-2456 */
#define XK_braille_dots_12456         0x100283b  /* U+283b BRAILLE PATTERN DOTS-12456 */
#define XK_braille_dots_3456          0x100283c  /* U+283c BRAILLE PATTERN DOTS-3456 */
#define XK_braille_dots_13456         0x100283d  /* U+283d BRAILLE PATTERN DOTS-13456 */
#define XK_braille_dots_23456         0x100283e  /* U+283e BRAILLE PATTERN DOTS-23456 */
#define XK_braille_dots_123456        0x100283f  /* U+283f BRAILLE PATTERN DOTS-123456 */
#define XK_braille_dots_7             0x1002840  /* U+2840 BRAILLE PATTERN DOTS-7 */
#define XK_braille_dots_17            0x1002841  /* U+2841 BRAILLE PATTERN DOTS-17 */
#define XK_braille_dots_27            0x1002842  /* U+2842 BRAILLE PATTERN DOTS-27 */
#define XK_braille_dots_127           0x1002843  /* U+2843 BRAILLE PATTERN DOTS-127 */
#define XK_braille_dots_37            0x1002844  /* U+2844 BRAILLE PATTERN DOTS-37 */
#define XK_braille_dots_137           0x1002845  /* U+2845 BRAILLE PATTERN DOTS-137 */
#define XK_braille_dots_237           0x1002846  /* U+2846 BRAILLE PATTERN DOTS-237 */
#define XK_braille_dots_1237          0x1002847  /* U+2847 BRAILLE PATTERN DOTS-1237 */
#define XK_braille_dots_47            0x1002848  /* U+2848 BRAILLE PATTERN DOTS-47 */
#define XK_braille_dots_147           0x1002849  /* U+2849 BRAILLE PATTERN DOTS-147 */
#define XK_braille_dots_247           0x100284a  /* U+284a BRAILLE PATTERN DOTS-247 */
#define XK_braille_dots_1247          0x100284b  /* U+284b BRAILLE PATTERN DOTS-1247 */
#define XK_braille_dots_347           0x100284c  /* U+284c BRAILLE PATTERN DOTS-347 */
#define XK_braille_dots_1347          0x100284d  /* U+284d BRAILLE PATTERN DOTS-1347 */
#define XK_braille_dots_2347          0x100284e  /* U+284e BRAILLE PATTERN DOTS-2347 */
#define XK_braille_dots_12347         0x100284f  /* U+284f BRAILLE PATTERN DOTS-12347 */
#define XK_braille_dots_57            0x1002850  /* U+2850 BRAILLE PATTERN DOTS-57 */
#define XK_braille_dots_157           0x1002851  /* U+2851 BRAILLE PATTERN DOTS-157 */
#define XK_braille_dots_257           0x1002852  /* U+2852 BRAILLE PATTERN DOTS-257 */
#define XK_braille_dots_1257          0x1002853  /* U+2853 BRAILLE PATTERN DOTS-1257 */
#define XK_braille_dots_357           0x1002854  /* U+2854 BRAILLE PATTERN DOTS-357 */
#define XK_braille_dots_1357          0x1002855  /* U+2855 BRAILLE PATTERN DOTS-1357 */
#define XK_braille_dots_2357          0x1002856  /* U+2856 BRAILLE PATTERN DOTS-2357 */
#define XK_braille_dots_12357         0x1002857  /* U+2857 BRAILLE PATTERN DOTS-12357 */
#define XK_braille_dots_457           0x1002858  /* U+2858 BRAILLE PATTERN DOTS-457 */
#define XK_braille_dots_1457          0x1002859  /* U+2859 BRAILLE PATTERN DOTS-1457 */
#define XK_braille_dots_2457          0x100285a  /* U+285a BRAILLE PATTERN DOTS-2457 */
#define XK_braille_dots_12457         0x100285b  /* U+285b BRAILLE PATTERN DOTS-12457 */
#define XK_braille_dots_3457          0x100285c  /* U+285c BRAILLE PATTERN DOTS-3457 */
#define XK_braille_dots_13457         0x100285d  /* U+285d BRAILLE PATTERN DOTS-13457 */
#define XK_braille_dots_23457         0x100285e  /* U+285e BRAILLE PATTERN DOTS-23457 */
#define XK_braille_dots_123457        0x100285f  /* U+285f BRAILLE PATTERN DOTS-123457 */
#define XK_braille_dots_67            0x1002860  /* U+2860 BRAILLE PATTERN DOTS-67 */
#define XK_braille_dots_167           0x1002861  /* U+2861 BRAILLE PATTERN DOTS-167 */
#define XK_braille_dots_267           0x1002862  /* U+2862 BRAILLE PATTERN DOTS-267 */
#define XK_braille_dots_1267          0x1002863  /* U+2863 BRAILLE PATTERN DOTS-1267 */
#define XK_braille_dots_367           0x1002864  /* U+2864 BRAILLE PATTERN DOTS-367 */
#define XK_braille_dots_1367          0x1002865  /* U+2865 BRAILLE PATTERN DOTS-1367 */
#define XK_braille_dots_2367          0x1002866  /* U+2866 BRAILLE PATTERN DOTS-2367 */
#define XK_braille_dots_12367         0x1002867  /* U+2867 BRAILLE PATTERN DOTS-12367 */
#define XK_braille_dots_467           0x1002868  /* U+2868 BRAILLE PATTERN DOTS-467 */
#define XK_braille_dots_1467          0x1002869  /* U+2869 BRAILLE PATTERN DOTS-1467 */
#define XK_braille_dots_2467          0x100286a  /* U+286a BRAILLE PATTERN DOTS-2467 */
#define XK_braille_dots_12467         0x100286b  /* U+286b BRAILLE PATTERN DOTS-12467 */
#define XK_braille_dots_3467          0x100286c  /* U+286c BRAILLE PATTERN DOTS-3467 */
#define XK_braille_dots_13467         0x100286d  /* U+286d BRAILLE PATTERN DOTS-13467 */
#define XK_braille_dots_23467         0x100286e  /* U+286e BRAILLE PATTERN DOTS-23467 */
#define XK_braille_dots_123467        0x100286f  /* U+286f BRAILLE PATTERN DOTS-123467 */
#define XK_braille_dots_567           0x1002870  /* U+2870 BRAILLE PATTERN DOTS-567 */
#define XK_braille_dots_1567          0x1002871  /* U+2871 BRAILLE PATTERN DOTS-1567 */
#define XK_braille_dots_2567          0x1002872  /* U+2872 BRAILLE PATTERN DOTS-2567 */
#define XK_braille_dots_12567         0x1002873  /* U+2873 BRAILLE PATTERN DOTS-12567 */
#define XK_braille_dots_3567          0x1002874  /* U+2874 BRAILLE PATTERN DOTS-3567 */
#define XK_braille_dots_13567         0x1002875  /* U+2875 BRAILLE PATTERN DOTS-13567 */
#define XK_braille_dots_23567         0x1002876  /* U+2876 BRAILLE PATTERN DOTS-23567 */
#define XK_braille_dots_123567        0x1002877  /* U+2877 BRAILLE PATTERN DOTS-123567 */
#define XK_braille_dots_4567          0x1002878  /* U+2878 BRAILLE PATTERN DOTS-4567 */
#define XK_braille_dots_14567         0x1002879  /* U+2879 BRAILLE PATTERN DOTS-14567 */
#define XK_braille_dots_24567         0x100287a  /* U+287a BRAILLE PATTERN DOTS-24567 */
#define XK_braille_dots_124567        0x100287b  /* U+287b BRAILLE PATTERN DOTS-124567 */
#define XK_braille_dots_34567         0x100287c  /* U+287c BRAILLE PATTERN DOTS-34567 */
#define XK_braille_dots_134567        0x100287d  /* U+287d BRAILLE PATTERN DOTS-134567 */
#define XK_braille_dots_234567        0x100287e  /* U+287e BRAILLE PATTERN DOTS-234567 */
#define XK_braille_dots_1234567       0x100287f  /* U+287f BRAILLE PATTERN DOTS-1234567 */
#define XK_braille_dots_8             0x1002880  /* U+2880 BRAILLE PATTERN DOTS-8 */
#define XK_braille_dots_18            0x1002881  /* U+2881 BRAILLE PATTERN DOTS-18 */
#define XK_braille_dots_28            0x1002882  /* U+2882 BRAILLE PATTERN DOTS-28 */
#define XK_braille_dots_128           0x1002883  /* U+2883 BRAILLE PATTERN DOTS-128 */
#define XK_braille_dots_38            0x1002884  /* U+2884 BRAILLE PATTERN DOTS-38 */
#define XK_braille_dots_138           0x1002885  /* U+2885 BRAILLE PATTERN DOTS-138 */
#define XK_braille_dots_238           0x1002886  /* U+2886 BRAILLE PATTERN DOTS-238 */
#define XK_braille_dots_1238          0x1002887  /* U+2887 BRAILLE PATTERN DOTS-1238 */
#define XK_braille_dots_48            0x1002888  /* U+2888 BRAILLE PATTERN DOTS-48 */
#define XK_braille_dots_148           0x1002889  /* U+2889 BRAILLE PATTERN DOTS-148 */
#define XK_braille_dots_248           0x100288a  /* U+288a BRAILLE PATTERN DOTS-248 */
#define XK_braille_dots_1248          0x100288b  /* U+288b BRAILLE PATTERN DOTS-1248 */
#define XK_braille_dots_348           0x100288c  /* U+288c BRAILLE PATTERN DOTS-348 */
#define XK_braille_dots_1348          0x100288d  /* U+288d BRAILLE PATTERN DOTS-1348 */
#define XK_braille_dots_2348          0x100288e  /* U+288e BRAILLE PATTERN DOTS-2348 */
#define XK_braille_dots_12348         0x100288f  /* U+288f BRAILLE PATTERN DOTS-12348 */
#define XK_braille_dots_58            0x1002890  /* U+2890 BRAILLE PATTERN DOTS-58 */
#define XK_braille_dots_158           0x1002891  /* U+2891 BRAILLE PATTERN DOTS-158 */
#define XK_braille_dots_258           0x1002892  /* U+2892 BRAILLE PATTERN DOTS-258 */
#define XK_braille_dots_1258          0x1002893  /* U+2893 BRAILLE PATTERN DOTS-1258 */
#define XK_braille_dots_358           0x1002894  /* U+2894 BRAILLE PATTERN DOTS-358 */
#define XK_braille_dots_1358          0x1002895  /* U+2895 BRAILLE PATTERN DOTS-1358 */
#define XK_braille_dots_2358          0x1002896  /* U+2896 BRAILLE PATTERN DOTS-2358 */
#define XK_braille_dots_12358         0x1002897  /* U+2897 BRAILLE PATTERN DOTS-12358 */
#define XK_braille_dots_458           0x1002898  /* U+2898 BRAILLE PATTERN DOTS-458 */
#define XK_braille_dots_1458          0x1002899  /* U+2899 BRAILLE PATTERN DOTS-1458 */
#define XK_braille_dots_2458          0x100289a  /* U+289a BRAILLE PATTERN DOTS-2458 */
#define XK_braille_dots_12458         0x100289b  /* U+289b BRAILLE PATTERN DOTS-12458 */
#define XK_braille_dots_3458          0x100289c  /* U+289c BRAILLE PATTERN DOTS-3458 */
#define XK_braille_dots_13458         0x100289d  /* U+289d BRAILLE PATTERN DOTS-13458 */
#define XK_braille_dots_23458         0x100289e  /* U+289e BRAILLE PATTERN DOTS-23458 */
#define XK_braille_dots_123458        0x100289f  /* U+289f BRAILLE PATTERN DOTS-123458 */
#define XK_braille_dots_68            0x10028a0  /* U+28a0 BRAILLE PATTERN DOTS-68 */
#define XK_braille_dots_168           0x10028a1  /* U+28a1 BRAILLE PATTERN DOTS-168 */
#define XK_braille_dots_268           0x10028a2  /* U+28a2 BRAILLE PATTERN DOTS-268 */
#define XK_braille_dots_1268          0x10028a3  /* U+28a3 BRAILLE PATTERN DOTS-1268 */
#define XK_braille_dots_368           0x10028a4  /* U+28a4 BRAILLE PATTERN DOTS-368 */
#define XK_braille_dots_1368          0x10028a5  /* U+28a5 BRAILLE PATTERN DOTS-1368 */
#define XK_braille_dots_2368          0x10028a6  /* U+28a6 BRAILLE PATTERN DOTS-2368 */
#define XK_braille_dots_12368         0x10028a7  /* U+28a7 BRAILLE PATTERN DOTS-12368 */
#define XK_braille_dots_468           0x10028a8  /* U+28a8 BRAILLE PATTERN DOTS-468 */
#define XK_braille_dots_1468          0x10028a9  /* U+28a9 BRAILLE PATTERN DOTS-1468 */
#define XK_braille_dots_2468          0x10028aa  /* U+28aa BRAILLE PATTERN DOTS-2468 */
#define XK_braille_dots_12468         0x10028ab  /* U+28ab BRAILLE PATTERN DOTS-12468 */
#define XK_braille_dots_3468          0x10028ac  /* U+28ac BRAILLE PATTERN DOTS-3468 */
#define XK_braille_dots_13468         0x10028ad  /* U+28ad BRAILLE PATTERN DOTS-13468 */
#define XK_braille_dots_23468         0x10028ae  /* U+28ae BRAILLE PATTERN DOTS-23468 */
#define XK_braille_dots_123468        0x10028af  /* U+28af BRAILLE PATTERN DOTS-123468 */
#define XK_braille_dots_568           0x10028b0  /* U+28b0 BRAILLE PATTERN DOTS-568 */
#define XK_braille_dots_1568          0x10028b1  /* U+28b1 BRAILLE PATTERN DOTS-1568 */
#define XK_braille_dots_2568          0x10028b2  /* U+28b2 BRAILLE PATTERN DOTS-2568 */
#define XK_braille_dots_12568         0x10028b3  /* U+28b3 BRAILLE PATTERN DOTS-12568 */
#define XK_braille_dots_3568          0x10028b4  /* U+28b4 BRAILLE PATTERN DOTS-3568 */
#define XK_braille_dots_13568         0x10028b5  /* U+28b5 BRAILLE PATTERN DOTS-13568 */
#define XK_braille_dots_23568         0x10028b6  /* U+28b6 BRAILLE PATTERN DOTS-23568 */
#define XK_braille_dots_123568        0x10028b7  /* U+28b7 BRAILLE PATTERN DOTS-123568 */
#define XK_braille_dots_4568          0x10028b8  /* U+28b8 BRAILLE PATTERN DOTS-4568 */
#define XK_braille_dots_14568         0x10028b9  /* U+28b9 BRAILLE PATTERN DOTS-14568 */
#define XK_braille_dots_24568         0x10028ba  /* U+28ba BRAILLE PATTERN DOTS-24568 */
#define XK_braille_dots_124568        0x10028bb  /* U+28bb BRAILLE PATTERN DOTS-124568 */
#define XK_braille_dots_34568         0x10028bc  /* U+28bc BRAILLE PATTERN DOTS-34568 */
#define XK_braille_dots_134568        0x10028bd  /* U+28bd BRAILLE PATTERN DOTS-134568 */
#define XK_braille_dots_234568        0x10028be  /* U+28be BRAILLE PATTERN DOTS-234568 */
#define XK_braille_dots_1234568       0x10028bf  /* U+28bf BRAILLE PATTERN DOTS-1234568 */
#define XK_braille_dots_78            0x10028c0  /* U+28c0 BRAILLE PATTERN DOTS-78 */
#define XK_braille_dots_178           0x10028c1  /* U+28c1 BRAILLE PATTERN DOTS-178 */
#define XK_braille_dots_278           0x10028c2  /* U+28c2 BRAILLE PATTERN DOTS-278 */
#define XK_braille_dots_1278          0x10028c3  /* U+28c3 BRAILLE PATTERN DOTS-1278 */
#define XK_braille_dots_378           0x10028c4  /* U+28c4 BRAILLE PATTERN DOTS-378 */
#define XK_braille_dots_1378          0x10028c5  /* U+28c5 BRAILLE PATTERN DOTS-1378 */
#define XK_braille_dots_2378          0x10028c6  /* U+28c6 BRAILLE PATTERN DOTS-2378 */
#define XK_braille_dots_12378         0x10028c7  /* U+28c7 BRAILLE PATTERN DOTS-12378 */
#define XK_braille_dots_478           0x10028c8  /* U+28c8 BRAILLE PATTERN DOTS-478 */
#define XK_braille_dots_1478          0x10028c9  /* U+28c9 BRAILLE PATTERN DOTS-1478 */
#define XK_braille_dots_2478          0x10028ca  /* U+28ca BRAILLE PATTERN DOTS-2478 */
#define XK_braille_dots_12478         0x10028cb  /* U+28cb BRAILLE PATTERN DOTS-12478 */
#define XK_braille_dots_3478          0x10028cc  /* U+28cc BRAILLE PATTERN DOTS-3478 */
#define XK_braille_dots_13478         0x10028cd  /* U+28cd BRAILLE PATTERN DOTS-13478 */
#define XK_braille_dots_23478         0x10028ce  /* U+28ce BRAILLE PATTERN DOTS-23478 */
#define XK_braille_dots_123478        0x10028cf  /* U+28cf BRAILLE PATTERN DOTS-123478 */
#define XK_braille_dots_578           0x10028d0  /* U+28d0 BRAILLE PATTERN DOTS-578 */
#define XK_braille_dots_1578          0x10028d1  /* U+28d1 BRAILLE PATTERN DOTS-1578 */
#define XK_braille_dots_2578          0x10028d2  /* U+28d2 BRAILLE PATTERN DOTS-2578 */
#define XK_braille_dots_12578         0x10028d3  /* U+28d3 BRAILLE PATTERN DOTS-12578 */
#define XK_braille_dots_3578          0x10028d4  /* U+28d4 BRAILLE PATTERN DOTS-3578 */
#define XK_braille_dots_13578         0x10028d5  /* U+28d5 BRAILLE PATTERN DOTS-13578 */
#define XK_braille_dots_23578         0x10028d6  /* U+28d6 BRAILLE PATTERN DOTS-23578 */
#define XK_braille_dots_123578        0x10028d7  /* U+28d7 BRAILLE PATTERN DOTS-123578 */
#define XK_braille_dots_4578          0x10028d8  /* U+28d8 BRAILLE PATTERN DOTS-4578 */
#define XK_braille_dots_14578         0x10028d9  /* U+28d9 BRAILLE PATTERN DOTS-14578 */
#define XK_braille_dots_24578         0x10028da  /* U+28da BRAILLE PATTERN DOTS-24578 */
#define XK_braille_dots_124578        0x10028db  /* U+28db BRAILLE PATTERN DOTS-124578 */
#define XK_braille_dots_34578         0x10028dc  /* U+28dc BRAILLE PATTERN DOTS-34578 */
#define XK_braille_dots_134578        0x10028dd  /* U+28dd BRAILLE PATTERN DOTS-134578 */
#define XK_braille_dots_234578        0x10028de  /* U+28de BRAILLE PATTERN DOTS-234578 */
#define XK_braille_dots_1234578       0x10028df  /* U+28df BRAILLE PATTERN DOTS-1234578 */
#define XK_braille_dots_678           0x10028e0  /* U+28e0 BRAILLE PATTERN DOTS-678 */
#define XK_braille_dots_1678          0x10028e1  /* U+28e1 BRAILLE PATTERN DOTS-1678 */
#define XK_braille_dots_2678          0x10028e2  /* U+28e2 BRAILLE PATTERN DOTS-2678 */
#define XK_braille_dots_12678         0x10028e3  /* U+28e3 BRAILLE PATTERN DOTS-12678 */
#define XK_braille_dots_3678          0x10028e4  /* U+28e4 BRAILLE PATTERN DOTS-3678 */
#define XK_braille_dots_13678         0x10028e5  /* U+28e5 BRAILLE PATTERN DOTS-13678 */
#define XK_braille_dots_23678         0x10028e6  /* U+28e6 BRAILLE PATTERN DOTS-23678 */
#define XK_braille_dots_123678        0x10028e7  /* U+28e7 BRAILLE PATTERN DOTS-123678 */
#define XK_braille_dots_4678          0x10028e8  /* U+28e8 BRAILLE PATTERN DOTS-4678 */
#define XK_braille_dots_14678         0x10028e9  /* U+28e9 BRAILLE PATTERN DOTS-14678 */
#define XK_braille_dots_24678         0x10028ea  /* U+28ea BRAILLE PATTERN DOTS-24678 */
#define XK_braille_dots_124678        0x10028eb  /* U+28eb BRAILLE PATTERN DOTS-124678 */
#define XK_braille_dots_34678         0x10028ec  /* U+28ec BRAILLE PATTERN DOTS-34678 */
#define XK_braille_dots_134678        0x10028ed  /* U+28ed BRAILLE PATTERN DOTS-134678 */
#define XK_braille_dots_234678        0x10028ee  /* U+28ee BRAILLE PATTERN DOTS-234678 */
#define XK_braille_dots_1234678       0x10028ef  /* U+28ef BRAILLE PATTERN DOTS-1234678 */
#define XK_braille_dots_5678          0x10028f0  /* U+28f0 BRAILLE PATTERN DOTS-5678 */
#define XK_braille_dots_15678         0x10028f1  /* U+28f1 BRAILLE PATTERN DOTS-15678 */
#define XK_braille_dots_25678         0x10028f2  /* U+28f2 BRAILLE PATTERN DOTS-25678 */
#define XK_braille_dots_125678        0x10028f3  /* U+28f3 BRAILLE PATTERN DOTS-125678 */
#define XK_braille_dots_35678         0x10028f4  /* U+28f4 BRAILLE PATTERN DOTS-35678 */
#define XK_braille_dots_135678        0x10028f5  /* U+28f5 BRAILLE PATTERN DOTS-135678 */
#define XK_braille_dots_235678        0x10028f6  /* U+28f6 BRAILLE PATTERN DOTS-235678 */
#define XK_braille_dots_1235678       0x10028f7  /* U+28f7 BRAILLE PATTERN DOTS-1235678 */
#define XK_braille_dots_45678         0x10028f8  /* U+28f8 BRAILLE PATTERN DOTS-45678 */
#define XK_braille_dots_145678        0x10028f9  /* U+28f9 BRAILLE PATTERN DOTS-145678 */
#define XK_braille_dots_245678        0x10028fa  /* U+28fa BRAILLE PATTERN DOTS-245678 */
#define XK_braille_dots_1245678       0x10028fb  /* U+28fb BRAILLE PATTERN DOTS-1245678 */
#define XK_braille_dots_345678        0x10028fc  /* U+28fc BRAILLE PATTERN DOTS-345678 */
#define XK_braille_dots_1345678       0x10028fd  /* U+28fd BRAILLE PATTERN DOTS-1345678 */
#define XK_braille_dots_2345678       0x10028fe  /* U+28fe BRAILLE PATTERN DOTS-2345678 */
#define XK_braille_dots_12345678      0x10028ff  /* U+28ff BRAILLE PATTERN DOTS-12345678 */
/* XK_BRAILLE */

/*
 * Sinhala (http://unicode.org/charts/PDF/U0D80.pdf)
 * http://www.nongnu.org/sinhala/doc/transliteration/sinhala-transliteration_6.html
 */


#define XK_Sinh_ng            0x1000d82  /* U+0D82 SINHALA ANUSVARAYA */
#define XK_Sinh_h2            0x1000d83  /* U+0D83 SINHALA VISARGAYA */
#define XK_Sinh_a             0x1000d85  /* U+0D85 SINHALA AYANNA */
#define XK_Sinh_aa            0x1000d86  /* U+0D86 SINHALA AAYANNA */
#define XK_Sinh_ae            0x1000d87  /* U+0D87 SINHALA AEYANNA */
#define XK_Sinh_aee           0x1000d88  /* U+0D88 SINHALA AEEYANNA */
#define XK_Sinh_i             0x1000d89  /* U+0D89 SINHALA IYANNA */
#define XK_Sinh_ii            0x1000d8a  /* U+0D8A SINHALA IIYANNA */
#define XK_Sinh_u             0x1000d8b  /* U+0D8B SINHALA UYANNA */
#define XK_Sinh_uu            0x1000d8c  /* U+0D8C SINHALA UUYANNA */
#define XK_Sinh_ri            0x1000d8d  /* U+0D8D SINHALA IRUYANNA */
#define XK_Sinh_rii           0x1000d8e  /* U+0D8E SINHALA IRUUYANNA */
#define XK_Sinh_lu            0x1000d8f  /* U+0D8F SINHALA ILUYANNA */
#define XK_Sinh_luu           0x1000d90  /* U+0D90 SINHALA ILUUYANNA */
#define XK_Sinh_e             0x1000d91  /* U+0D91 SINHALA EYANNA */
#define XK_Sinh_ee            0x1000d92  /* U+0D92 SINHALA EEYANNA */
#define XK_Sinh_ai            0x1000d93  /* U+0D93 SINHALA AIYANNA */
#define XK_Sinh_o             0x1000d94  /* U+0D94 SINHALA OYANNA */
#define XK_Sinh_oo            0x1000d95  /* U+0D95 SINHALA OOYANNA */
#define XK_Sinh_au            0x1000d96  /* U+0D96 SINHALA AUYANNA */
#define XK_Sinh_ka            0x1000d9a  /* U+0D9A SINHALA KAYANNA */
#define XK_Sinh_kha           0x1000d9b  /* U+0D9B SINHALA MAHA. KAYANNA */
#define XK_Sinh_ga            0x1000d9c  /* U+0D9C SINHALA GAYANNA */
#define XK_Sinh_gha           0x1000d9d  /* U+0D9D SINHALA MAHA. GAYANNA */
#define XK_Sinh_ng2           0x1000d9e  /* U+0D9E SINHALA KANTAJA NAASIKYAYA */
#define XK_Sinh_nga           0x1000d9f  /* U+0D9F SINHALA SANYAKA GAYANNA */
#define XK_Sinh_ca            0x1000da0  /* U+0DA0 SINHALA CAYANNA */
#define XK_Sinh_cha           0x1000da1  /* U+0DA1 SINHALA MAHA. CAYANNA */
#define XK_Sinh_ja            0x1000da2  /* U+0DA2 SINHALA JAYANNA */
#define XK_Sinh_jha           0x1000da3  /* U+0DA3 SINHALA MAHA. JAYANNA */
#define XK_Sinh_nya           0x1000da4  /* U+0DA4 SINHALA TAALUJA NAASIKYAYA */
#define XK_Sinh_jnya          0x1000da5  /* U+0DA5 SINHALA TAALUJA SANYOOGA NAASIKYAYA */
#define XK_Sinh_nja           0x1000da6  /* U+0DA6 SINHALA SANYAKA JAYANNA */
#define XK_Sinh_tta           0x1000da7  /* U+0DA7 SINHALA TTAYANNA */
#define XK_Sinh_ttha          0x1000da8  /* U+0DA8 SINHALA MAHA. TTAYANNA */
#define XK_Sinh_dda           0x1000da9  /* U+0DA9 SINHALA DDAYANNA */
#define XK_Sinh_ddha          0x1000daa  /* U+0DAA SINHALA MAHA. DDAYANNA */
#define XK_Sinh_nna           0x1000dab  /* U+0DAB SINHALA MUURDHAJA NAYANNA */
#define XK_Sinh_ndda          0x1000dac  /* U+0DAC SINHALA SANYAKA DDAYANNA */
#define XK_Sinh_tha           0x1000dad  /* U+0DAD SINHALA TAYANNA */
#define XK_Sinh_thha          0x1000dae  /* U+0DAE SINHALA MAHA. TAYANNA */
#define XK_Sinh_dha           0x1000daf  /* U+0DAF SINHALA DAYANNA */
#define XK_Sinh_dhha          0x1000db0  /* U+0DB0 SINHALA MAHA. DAYANNA */
#define XK_Sinh_na            0x1000db1  /* U+0DB1 SINHALA DANTAJA NAYANNA */
#define XK_Sinh_ndha          0x1000db3  /* U+0DB3 SINHALA SANYAKA DAYANNA */
#define XK_Sinh_pa            0x1000db4  /* U+0DB4 SINHALA PAYANNA */
#define XK_Sinh_pha           0x1000db5  /* U+0DB5 SINHALA MAHA. PAYANNA */
#define XK_Sinh_ba            0x1000db6  /* U+0DB6 SINHALA BAYANNA */
#define XK_Sinh_bha           0x1000db7  /* U+0DB7 SINHALA MAHA. BAYANNA */
#define XK_Sinh_ma            0x1000db8  /* U+0DB8 SINHALA MAYANNA */
#define XK_Sinh_mba           0x1000db9  /* U+0DB9 SINHALA AMBA BAYANNA */
#define XK_Sinh_ya            0x1000dba  /* U+0DBA SINHALA YAYANNA */
#define XK_Sinh_ra            0x1000dbb  /* U+0DBB SINHALA RAYANNA */
#define XK_Sinh_la            0x1000dbd  /* U+0DBD SINHALA DANTAJA LAYANNA */
#define XK_Sinh_va            0x1000dc0  /* U+0DC0 SINHALA VAYANNA */
#define XK_Sinh_sha           0x1000dc1  /* U+0DC1 SINHALA TAALUJA SAYANNA */
#define XK_Sinh_ssha          0x1000dc2  /* U+0DC2 SINHALA MUURDHAJA SAYANNA */
#define XK_Sinh_sa            0x1000dc3  /* U+0DC3 SINHALA DANTAJA SAYANNA */
#define XK_Sinh_ha            0x1000dc4  /* U+0DC4 SINHALA HAYANNA */
#define XK_Sinh_lla           0x1000dc5  /* U+0DC5 SINHALA MUURDHAJA LAYANNA */
#define XK_Sinh_fa            0x1000dc6  /* U+0DC6 SINHALA FAYANNA */
#define XK_Sinh_al            0x1000dca  /* U+0DCA SINHALA AL-LAKUNA */
#define XK_Sinh_aa2           0x1000dcf  /* U+0DCF SINHALA AELA-PILLA */
#define XK_Sinh_ae2           0x1000dd0  /* U+0DD0 SINHALA AEDA-PILLA */
#define XK_Sinh_aee2          0x1000dd1  /* U+0DD1 SINHALA DIGA AEDA-PILLA */
#define XK_Sinh_i2            0x1000dd2  /* U+0DD2 SINHALA IS-PILLA */
#define XK_Sinh_ii2           0x1000dd3  /* U+0DD3 SINHALA DIGA IS-PILLA */
#define XK_Sinh_u2            0x1000dd4  /* U+0DD4 SINHALA PAA-PILLA */
#define XK_Sinh_uu2           0x1000dd6  /* U+0DD6 SINHALA DIGA PAA-PILLA */
#define XK_Sinh_ru2           0x1000dd8  /* U+0DD8 SINHALA GAETTA-PILLA */
#define XK_Sinh_e2            0x1000dd9  /* U+0DD9 SINHALA KOMBUVA */
#define XK_Sinh_ee2           0x1000dda  /* U+0DDA SINHALA DIGA KOMBUVA */
#define XK_Sinh_ai2           0x1000ddb  /* U+0DDB SINHALA KOMBU DEKA */
#define XK_Sinh_o2            0x1000ddc  /* U+0DDC SINHALA KOMBUVA HAA AELA-PILLA*/
#define XK_Sinh_oo2           0x1000ddd  /* U+0DDD SINHALA KOMBUVA HAA DIGA AELA-PILLA*/
#define XK_Sinh_au2           0x1000dde  /* U+0DDE SINHALA KOMBUVA HAA GAYANUKITTA */
#define XK_Sinh_lu2           0x1000ddf  /* U+0DDF SINHALA GAYANUKITTA */
#define XK_Sinh_ruu2          0x1000df2  /* U+0DF2 SINHALA DIGA GAETTA-PILLA */
#define XK_Sinh_luu2          0x1000df3  /* U+0DF3 SINHALA DIGA GAYANUKITTA */
#define XK_Sinh_kunddaliya    0x1000df4  /* U+0DF4 SINHALA KUNDDALIYA */
/* XK_SINHALA */
# 73 "/usr/include/X11/keysym.h" 2 3


# 54 "/usr/include/X11/Xutil.h" 2 3


/*
 * Bitmask returned by XParseGeometry().  Each bit tells if the corresponding
 * value (x, y, width, height) was found in the parsed string.
 */
#define NoValue		0x0000
#define XValue  	0x0001
#define YValue		0x0002
#define WidthValue  	0x0004
#define HeightValue  	0x0008
#define AllValues 	0x000F
#define XNegative 	0x0010
#define YNegative 	0x0020

/*
 * new version containing base_width, base_height, and win_gravity fields;
 * used with WM_NORMAL_HINTS.
 */
typedef struct {
    	long flags;	/* marks which fields in this structure are defined */
	int x, y;		/* obsolete for new window mgrs, but clients */
	int width, height;	/* should set so old wm's don't mess up */
	int min_width, min_height;
	int max_width, max_height;
    	int width_inc, height_inc;
	struct {
		int x;	/* numerator */
		int y;	/* denominator */
	} min_aspect, max_aspect;
	int base_width, base_height;		/* added by ICCCM version 1 */
	int win_gravity;			/* added by ICCCM version 1 */
} XSizeHints;

/*
 * The next block of definitions are for window manager properties that
 * clients and applications use for communication.
 */

/* flags argument in size hints */
#define USPosition	(1L << 0) /* user specified x, y */
#define USSize		(1L << 1) /* user specified width, height */

#define PPosition	(1L << 2) /* program specified position */
#define PSize		(1L << 3) /* program specified size */
#define PMinSize	(1L << 4) /* program specified minimum size */
#define PMaxSize	(1L << 5) /* program specified maximum size */
#define PResizeInc	(1L << 6) /* program specified resize increments */
#define PAspect		(1L << 7) /* program specified min and max aspect ratios */
#define PBaseSize	(1L << 8) /* program specified base for incrementing */
#define PWinGravity	(1L << 9) /* program specified window gravity */

/* obsolete */
#define PAllHints (PPosition|PSize|PMinSize|PMaxSize|PResizeInc|PAspect)



typedef struct {
	long flags;	/* marks which fields in this structure are defined */
	int  input;	/* does this application rely on the window manager to
			get keyboard input? */
	int initial_state;	/* see below */
	Pixmap icon_pixmap;	/* pixmap to be used as icon */
	Window icon_window; 	/* window to be used as icon */
	int icon_x, icon_y; 	/* initial position of icon */
	Pixmap icon_mask;	/* icon mask bitmap */
	XID window_group;	/* id of related window group */
	/* this structure may be extended in the future */
} XWMHints;

/* definition for flags of XWMHints */

#define InputHint 		(1L << 0)
#define StateHint 		(1L << 1)
#define IconPixmapHint		(1L << 2)
#define IconWindowHint		(1L << 3)
#define IconPositionHint 	(1L << 4)
#define IconMaskHint		(1L << 5)
#define WindowGroupHint		(1L << 6)
#define AllHints (InputHint|StateHint|IconPixmapHint|IconWindowHint| \
IconPositionHint|IconMaskHint|WindowGroupHint)
#define XUrgencyHint		(1L << 8)

/* definitions for initial window state */
#define WithdrawnState 0	/* for windows that are not mapped */
#define NormalState 1	/* most applications want to start this way */
#define IconicState 3	/* application wants to start as an icon */

/*
 * Obsolete states no longer defined by ICCCM
 */
#define DontCareState 0	/* don't know or care */
#define ZoomState 2	/* application wants to start zoomed */
#define InactiveState 4	/* application believes it is seldom used; */
			/* some wm's may put it on inactive menu */


/*
 * new structure for manipulating TEXT properties; used with WM_NAME,
 * WM_ICON_NAME, WM_CLIENT_MACHINE, and WM_COMMAND.
 */
typedef struct {
    unsigned char *value;		/* same as Property routines */
    Atom encoding;			/* prop type */
    int format;				/* prop data format: 8, 16, or 32 */
    unsigned long nitems;		/* number of data items in value */
} XTextProperty;

#define XNoMemory -1
#define XLocaleNotSupported -2
#define XConverterNotFound -3

typedef enum {
    XStringStyle,		/* STRING */
    XCompoundTextStyle,		/* COMPOUND_TEXT */
    XTextStyle,			/* text in owner's encoding (current locale)*/
    XStdICCTextStyle,		/* STRING, else COMPOUND_TEXT */
    /* The following is an XFree86 extension, introduced in November 2000 */
    XUTF8StringStyle		/* UTF8_STRING */
} XICCEncodingStyle;

typedef struct {
	int min_width, min_height;
	int max_width, max_height;
	int width_inc, height_inc;
} XIconSize;

typedef struct {
	char *res_name;
	char *res_class;
} XClassHint;

# 203 "/usr/include/X11/Xutil.h" 3

/*
 * These macros are used to give some sugar to the image routines so that
 * naive people are more comfortable with them.
 */
#define XDestroyImage(ximage) \
	((*((ximage)->f.destroy_image))((ximage)))
#define XGetPixel(ximage, x, y) \
	((*((ximage)->f.get_pixel))((ximage), (x), (y)))
#define XPutPixel(ximage, x, y, pixel) \
	((*((ximage)->f.put_pixel))((ximage), (x), (y), (pixel)))
#define XSubImage(ximage, x, y, width, height)  \
	((*((ximage)->f.sub_image))((ximage), (x), (y), (width), (height)))
#define XAddPixel(ximage, value) \
	((*((ximage)->f.add_pixel))((ximage), (value)))


/*
 * Compose sequence status structure, used in calling XLookupString.
 */
typedef struct _XComposeStatus {
    XPointer compose_ptr;	/* state table pointer */
    int chars_matched;		/* match state */
} XComposeStatus;

/*
 * Keysym macros, used on Keysyms to test for classes of symbols
 */
#define IsKeypadKey(keysym) \
  (((KeySym)(keysym) >= XK_KP_Space) && ((KeySym)(keysym) <= XK_KP_Equal))

#define IsPrivateKeypadKey(keysym) \
  (((KeySym)(keysym) >= 0x11000000) && ((KeySym)(keysym) <= 0x1100FFFF))

#define IsCursorKey(keysym) \
  (((KeySym)(keysym) >= XK_Home)     && ((KeySym)(keysym) <  XK_Select))

#define IsPFKey(keysym) \
  (((KeySym)(keysym) >= XK_KP_F1)     && ((KeySym)(keysym) <= XK_KP_F4))

#define IsFunctionKey(keysym) \
  (((KeySym)(keysym) >= XK_F1)       && ((KeySym)(keysym) <= XK_F35))

#define IsMiscFunctionKey(keysym) \
  (((KeySym)(keysym) >= XK_Select)   && ((KeySym)(keysym) <= XK_Break))


#define IsModifierKey(keysym) \
  ((((KeySym)(keysym) >= XK_Shift_L) && ((KeySym)(keysym) <= XK_Hyper_R)) \
   || (((KeySym)(keysym) >= XK_ISO_Lock) && \
       ((KeySym)(keysym) <= XK_ISO_Level5_Lock)) \
   || ((KeySym)(keysym) == XK_Mode_switch) \
   || ((KeySym)(keysym) == XK_Num_Lock))






/*
 * opaque reference to Region data type
 */
typedef struct _XRegion *Region;

/* Return values from XRectInRegion() */

#define RectangleOut 0
#define RectangleIn  1
#define RectanglePart 2


/*
 * Information used by the visual utility routines to find desired visual
 * type from the many visuals a display may support.
 */

typedef struct {
  Visual *visual;
  VisualID visualid;
  int screen;
  int depth;



  int class;

  unsigned long red_mask;
  unsigned long green_mask;
  unsigned long blue_mask;
  int colormap_size;
  int bits_per_rgb;
} XVisualInfo;

#define VisualNoMask		0x0
#define VisualIDMask 		0x1
#define VisualScreenMask	0x2
#define VisualDepthMask		0x4
#define VisualClassMask		0x8
#define VisualRedMaskMask	0x10
#define VisualGreenMaskMask	0x20
#define VisualBlueMaskMask	0x40
#define VisualColormapSizeMask	0x80
#define VisualBitsPerRGBMask	0x100
#define VisualAllMask		0x1FF

/*
 * This defines a window manager property that clients may use to
 * share standard color maps of type RGB_COLOR_MAP:
 */
typedef struct {
	Colormap colormap;
	unsigned long red_max;
	unsigned long red_mult;
	unsigned long green_max;
	unsigned long green_mult;
	unsigned long blue_max;
	unsigned long blue_mult;
	unsigned long base_pixel;
	VisualID visualid;		/* added by ICCCM version 1 */
	XID killid;			/* added by ICCCM version 1 */
} XStandardColormap;

#define ReleaseByFreeingColormap ((XID) 1L)  /* for killid field above */


/*
 * return codes for XReadBitmapFile and XWriteBitmapFile
 */
#define BitmapSuccess		0
#define BitmapOpenFailed 	1
#define BitmapFileInvalid 	2
#define BitmapNoMemory		3

/****************************************************************
 *
 * Context Management
 *
 ****************************************************************/


/* Associative lookup table return codes */

#define XCSUCCESS 0	/* No error. */
#define XCNOMEM   1    /* Out of memory */
#define XCNOENT   2    /* No entry in table */

typedef int XContext;

#define XUniqueContext()       ((XContext) XrmUniqueQuark())
#define XStringToContext(string)   ((XContext) XrmStringToQuark(string))

 

/* The following declarations are alphabetized. */

extern XClassHint *XAllocClassHint (
    void
);

extern XIconSize *XAllocIconSize (
    void
);

extern XSizeHints *XAllocSizeHints (
    void
);

extern XStandardColormap *XAllocStandardColormap (
    void
);

extern XWMHints *XAllocWMHints (
    void
);

extern int XClipBox(
    Region		/* r */,
    XRectangle*		/* rect_return */
);

extern Region XCreateRegion(
    void
);

extern const char *XDefaultString (void);

extern int XDeleteContext(
    Display*		/* display */,
    XID			/* rid */,
    XContext		/* context */
);

extern int XDestroyRegion(
    Region		/* r */
);

extern int XEmptyRegion(
    Region		/* r */
);

extern int XEqualRegion(
    Region		/* r1 */,
    Region		/* r2 */
);

extern int XFindContext(
    Display*		/* display */,
    XID			/* rid */,
    XContext		/* context */,
    XPointer*		/* data_return */
);

extern int  XGetClassHint(
    Display*		/* display */,
    Window		/* w */,
    XClassHint*		/* class_hints_return */
);

extern int  XGetIconSizes(
    Display*		/* display */,
    Window		/* w */,
    XIconSize**		/* size_list_return */,
    int*		/* count_return */
);

extern int  XGetNormalHints(
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* hints_return */
);

extern int  XGetRGBColormaps(
    Display*		/* display */,
    Window		/* w */,
    XStandardColormap** /* stdcmap_return */,
    int*		/* count_return */,
    Atom		/* property */
);

extern int  XGetSizeHints(
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* hints_return */,
    Atom		/* property */
);

extern int  XGetStandardColormap(
    Display*		/* display */,
    Window		/* w */,
    XStandardColormap*	/* colormap_return */,
    Atom		/* property */
);

extern int  XGetTextProperty(
    Display*		/* display */,
    Window		/* window */,
    XTextProperty*	/* text_prop_return */,
    Atom		/* property */
);

extern XVisualInfo *XGetVisualInfo(
    Display*		/* display */,
    long		/* vinfo_mask */,
    XVisualInfo*	/* vinfo_template */,
    int*		/* nitems_return */
);

extern int  XGetWMClientMachine(
    Display*		/* display */,
    Window		/* w */,
    XTextProperty*	/* text_prop_return */
);

extern XWMHints *XGetWMHints(
    Display*		/* display */,
    Window		/* w */
);

extern int  XGetWMIconName(
    Display*		/* display */,
    Window		/* w */,
    XTextProperty*	/* text_prop_return */
);

extern int  XGetWMName(
    Display*		/* display */,
    Window		/* w */,
    XTextProperty*	/* text_prop_return */
);

extern int  XGetWMNormalHints(
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* hints_return */,
    long*		/* supplied_return */
);

extern int  XGetWMSizeHints(
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* hints_return */,
    long*		/* supplied_return */,
    Atom		/* property */
);

extern int  XGetZoomHints(
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* zhints_return */
);

extern int XIntersectRegion(
    Region		/* sra */,
    Region		/* srb */,
    Region		/* dr_return */
);

extern void XConvertCase(
    KeySym		/* sym */,
    KeySym*		/* lower */,
    KeySym*		/* upper */
);

extern int XLookupString(
    XKeyEvent*		/* event_struct */,
    char*		/* buffer_return */,
    int			/* bytes_buffer */,
    KeySym*		/* keysym_return */,
    XComposeStatus*	/* status_in_out */
);

extern int  XMatchVisualInfo(
    Display*		/* display */,
    int			/* screen */,
    int			/* depth */,
    int			/* class */,
    XVisualInfo*	/* vinfo_return */
);

extern int XOffsetRegion(
    Region		/* r */,
    int			/* dx */,
    int			/* dy */
);

extern int  XPointInRegion(
    Region		/* r */,
    int			/* x */,
    int			/* y */
);

extern Region XPolygonRegion(
    XPoint*		/* points */,
    int			/* n */,
    int			/* fill_rule */
);

extern int XRectInRegion(
    Region		/* r */,
    int			/* x */,
    int			/* y */,
    unsigned int	/* width */,
    unsigned int	/* height */
);

extern int XSaveContext(
    Display*		/* display */,
    XID			/* rid */,
    XContext		/* context */,
    const  char*	/* data */
);

extern int XSetClassHint(
    Display*		/* display */,
    Window		/* w */,
    XClassHint*		/* class_hints */
);

extern int XSetIconSizes(
    Display*		/* display */,
    Window		/* w */,
    XIconSize*		/* size_list */,
    int			/* count */
);

extern int XSetNormalHints(
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* hints */
);

extern void XSetRGBColormaps(
    Display*		/* display */,
    Window		/* w */,
    XStandardColormap*	/* stdcmaps */,
    int			/* count */,
    Atom		/* property */
);

extern int XSetSizeHints(
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* hints */,
    Atom		/* property */
);

extern int XSetStandardProperties(
    Display*		/* display */,
    Window		/* w */,
    const  char*	/* window_name */,
    const  char*	/* icon_name */,
    Pixmap		/* icon_pixmap */,
    char**		/* argv */,
    int			/* argc */,
    XSizeHints*		/* hints */
);

extern void XSetTextProperty(
    Display*		/* display */,
    Window		/* w */,
    XTextProperty*	/* text_prop */,
    Atom		/* property */
);

extern void XSetWMClientMachine(
    Display*		/* display */,
    Window		/* w */,
    XTextProperty*	/* text_prop */
);

extern int XSetWMHints(
    Display*		/* display */,
    Window		/* w */,
    XWMHints*		/* wm_hints */
);

extern void XSetWMIconName(
    Display*		/* display */,
    Window		/* w */,
    XTextProperty*	/* text_prop */
);

extern void XSetWMName(
    Display*		/* display */,
    Window		/* w */,
    XTextProperty*	/* text_prop */
);

extern void XSetWMNormalHints(
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* hints */
);

extern void XSetWMProperties(
    Display*		/* display */,
    Window		/* w */,
    XTextProperty*	/* window_name */,
    XTextProperty*	/* icon_name */,
    char**		/* argv */,
    int			/* argc */,
    XSizeHints*		/* normal_hints */,
    XWMHints*		/* wm_hints */,
    XClassHint*		/* class_hints */
);

extern void XmbSetWMProperties(
    Display*		/* display */,
    Window		/* w */,
    const  char*	/* window_name */,
    const  char*	/* icon_name */,
    char**		/* argv */,
    int			/* argc */,
    XSizeHints*		/* normal_hints */,
    XWMHints*		/* wm_hints */,
    XClassHint*		/* class_hints */
);

extern void Xutf8SetWMProperties(
    Display*		/* display */,
    Window		/* w */,
    const  char*	/* window_name */,
    const  char*	/* icon_name */,
    char**		/* argv */,
    int			/* argc */,
    XSizeHints*		/* normal_hints */,
    XWMHints*		/* wm_hints */,
    XClassHint*		/* class_hints */
);

extern void XSetWMSizeHints(
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* hints */,
    Atom		/* property */
);

extern int XSetRegion(
    Display*		/* display */,
    GC			/* gc */,
    Region		/* r */
);

extern void XSetStandardColormap(
    Display*		/* display */,
    Window		/* w */,
    XStandardColormap*	/* colormap */,
    Atom		/* property */
);

extern int XSetZoomHints(
    Display*		/* display */,
    Window		/* w */,
    XSizeHints*		/* zhints */
);

extern int XShrinkRegion(
    Region		/* r */,
    int			/* dx */,
    int			/* dy */
);

extern int  XStringListToTextProperty(
    char**		/* list */,
    int			/* count */,
    XTextProperty*	/* text_prop_return */
);

extern int XSubtractRegion(
    Region		/* sra */,
    Region		/* srb */,
    Region		/* dr_return */
);

extern int XmbTextListToTextProperty(
    Display*		display,
    char**		list,
    int			count,
    XICCEncodingStyle	style,
    XTextProperty*	text_prop_return
);

extern int XwcTextListToTextProperty(
    Display*		display,
    wchar_t**		list,
    int			count,
    XICCEncodingStyle	style,
    XTextProperty*	text_prop_return
);

extern int Xutf8TextListToTextProperty(
    Display*		display,
    char**		list,
    int			count,
    XICCEncodingStyle	style,
    XTextProperty*	text_prop_return
);

extern void XwcFreeStringList(
    wchar_t**		list
);

extern int  XTextPropertyToStringList(
    XTextProperty*	/* text_prop */,
    char***		/* list_return */,
    int*		/* count_return */
);

extern int XmbTextPropertyToTextList(
    Display*		display,
    const XTextProperty* text_prop,
    char***		list_return,
    int*		count_return
);

extern int XwcTextPropertyToTextList(
    Display*		display,
    const XTextProperty* text_prop,
    wchar_t***		list_return,
    int*		count_return
);

extern int Xutf8TextPropertyToTextList(
    Display*		display,
    const XTextProperty* text_prop,
    char***		list_return,
    int*		count_return
);

extern int XUnionRectWithRegion(
    XRectangle*		/* rectangle */,
    Region		/* src_region */,
    Region		/* dest_region_return */
);

extern int XUnionRegion(
    Region		/* sra */,
    Region		/* srb */,
    Region		/* dr_return */
);

extern int XWMGeometry(
    Display*		/* display */,
    int			/* screen_number */,
    const  char*	/* user_geometry */,
    const  char*	/* default_geometry */,
    unsigned int	/* border_width */,
    XSizeHints*		/* hints */,
    int*		/* x_return */,
    int*		/* y_return */,
    int*		/* width_return */,
    int*		/* height_return */,
    int*		/* gravity_return */
);

extern int XXorRegion(
    Region		/* sra */,
    Region		/* srb */,
    Region		/* dr_return */
);

 

/* _X11_XUTIL_H_ */
# 100 "include/forms.h" 2

#include <X11/Xatom.h>
# 1 "/usr/include/X11/Xatom.h" 1 3

#define XATOM_H 1

/* THIS IS A GENERATED FILE
 *
 * Do not change!  Changing this file implies a protocol change!
 */

#define XA_PRIMARY ((Atom) 1)
#define XA_SECONDARY ((Atom) 2)
#define XA_ARC ((Atom) 3)
#define XA_ATOM ((Atom) 4)
#define XA_BITMAP ((Atom) 5)
#define XA_CARDINAL ((Atom) 6)
#define XA_COLORMAP ((Atom) 7)
#define XA_CURSOR ((Atom) 8)
#define XA_CUT_BUFFER0 ((Atom) 9)
#define XA_CUT_BUFFER1 ((Atom) 10)
#define XA_CUT_BUFFER2 ((Atom) 11)
#define XA_CUT_BUFFER3 ((Atom) 12)
#define XA_CUT_BUFFER4 ((Atom) 13)
#define XA_CUT_BUFFER5 ((Atom) 14)
#define XA_CUT_BUFFER6 ((Atom) 15)
#define XA_CUT_BUFFER7 ((Atom) 16)
#define XA_DRAWABLE ((Atom) 17)
#define XA_FONT ((Atom) 18)
#define XA_INTEGER ((Atom) 19)
#define XA_PIXMAP ((Atom) 20)
#define XA_POINT ((Atom) 21)
#define XA_RECTANGLE ((Atom) 22)
#define XA_RESOURCE_MANAGER ((Atom) 23)
#define XA_RGB_COLOR_MAP ((Atom) 24)
#define XA_RGB_BEST_MAP ((Atom) 25)
#define XA_RGB_BLUE_MAP ((Atom) 26)
#define XA_RGB_DEFAULT_MAP ((Atom) 27)
#define XA_RGB_GRAY_MAP ((Atom) 28)
#define XA_RGB_GREEN_MAP ((Atom) 29)
#define XA_RGB_RED_MAP ((Atom) 30)
#define XA_STRING ((Atom) 31)
#define XA_VISUALID ((Atom) 32)
#define XA_WINDOW ((Atom) 33)
#define XA_WM_COMMAND ((Atom) 34)
#define XA_WM_HINTS ((Atom) 35)
#define XA_WM_CLIENT_MACHINE ((Atom) 36)
#define XA_WM_ICON_NAME ((Atom) 37)
#define XA_WM_ICON_SIZE ((Atom) 38)
#define XA_WM_NAME ((Atom) 39)
#define XA_WM_NORMAL_HINTS ((Atom) 40)
#define XA_WM_SIZE_HINTS ((Atom) 41)
#define XA_WM_ZOOM_HINTS ((Atom) 42)
#define XA_MIN_SPACE ((Atom) 43)
#define XA_NORM_SPACE ((Atom) 44)
#define XA_MAX_SPACE ((Atom) 45)
#define XA_END_SPACE ((Atom) 46)
#define XA_SUPERSCRIPT_X ((Atom) 47)
#define XA_SUPERSCRIPT_Y ((Atom) 48)
#define XA_SUBSCRIPT_X ((Atom) 49)
#define XA_SUBSCRIPT_Y ((Atom) 50)
#define XA_UNDERLINE_POSITION ((Atom) 51)
#define XA_UNDERLINE_THICKNESS ((Atom) 52)
#define XA_STRIKEOUT_ASCENT ((Atom) 53)
#define XA_STRIKEOUT_DESCENT ((Atom) 54)
#define XA_ITALIC_ANGLE ((Atom) 55)
#define XA_X_HEIGHT ((Atom) 56)
#define XA_QUAD_WIDTH ((Atom) 57)
#define XA_WEIGHT ((Atom) 58)
#define XA_POINT_SIZE ((Atom) 59)
#define XA_RESOLUTION ((Atom) 60)
#define XA_COPYRIGHT ((Atom) 61)
#define XA_NOTICE ((Atom) 62)
#define XA_FONT_NAME ((Atom) 63)
#define XA_FAMILY_NAME ((Atom) 64)
#define XA_FULL_NAME ((Atom) 65)
#define XA_CAP_HEIGHT ((Atom) 66)
#define XA_WM_CLASS ((Atom) 67)
#define XA_WM_TRANSIENT_FOR ((Atom) 68)

#define XA_LAST_PREDEFINED ((Atom) 68)
/* XATOM_H */
# 101 "include/forms.h" 2

#include <X11/keysym.h>
# 1 "/usr/include/X11/keysym.h" 1 3
/***********************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.


Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/* default keysyms */
#define XK_MISCELLANY
#define XK_XKB_KEYS
#define XK_LATIN1
#define XK_LATIN2
#define XK_LATIN3
#define XK_LATIN4
#define XK_LATIN8
#define XK_LATIN9
#define XK_CAUCASUS
#define XK_GREEK
#define XK_KATAKANA
#define XK_ARABIC
#define XK_CYRILLIC
#define XK_HEBREW
#define XK_THAI
#define XK_KOREAN
#define XK_ARMENIAN
#define XK_GEORGIAN
#define XK_VIETNAMESE
#define XK_CURRENCY
#define XK_MATHEMATICAL
#define XK_BRAILLE
#define XK_SINHALA

#include <X11/keysymdef.h>
# 1 "/usr/include/X11/keysymdef.h" 1 3
/***********************************************************
Copyright 1987, 1994, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.


Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/*
 * The "X11 Window System Protocol" standard defines in Appendix A the
 * keysym codes. These 29-bit integer values identify characters or
 * functions associated with each key (e.g., via the visible
 * engraving) of a keyboard layout. This file assigns mnemonic macro
 * names for these keysyms.
 *
 * This file is also compiled (by src/util/makekeys.c in libX11) into
 * hash tables that can be accessed with X11 library functions such as
 * XStringToKeysym() and XKeysymToString().
 *
 * Where a keysym corresponds one-to-one to an ISO 10646 / Unicode
 * character, this is noted in a comment that provides both the U+xxxx
 * Unicode position, as well as the official Unicode name of the
 * character.
 *
 * Where the correspondence is either not one-to-one or semantically
 * unclear, the Unicode position and name are enclosed in
 * parentheses. Such legacy keysyms should be considered deprecated
 * and are not recommended for use in future keyboard mappings.
 *
 * For any future extension of the keysyms with characters already
 * found in ISO 10646 / Unicode, the following algorithm shall be
 * used. The new keysym code position will simply be the character's
 * Unicode number plus 0x01000000. The keysym values in the range
 * 0x01000100 to 0x0110ffff are reserved to represent Unicode
 * characters in the range U+0100 to U+10FFFF.
 * 
 * While most newer Unicode-based X11 clients do already accept
 * Unicode-mapped keysyms in the range 0x01000100 to 0x0110ffff, it
 * will remain necessary for clients -- in the interest of
 * compatibility with existing servers -- to also understand the
 * existing legacy keysym values in the range 0x0100 to 0x20ff.
 *
 * Where several mnemonic names are defined for the same keysym in this
 * file, all but the first one listed should be considered deprecated.
 *
 * Mnemonic names for keysyms are defined in this file with lines
 * that match one of these Perl regular expressions:
 *
 *    /^\#define XK_([a-zA-Z_0-9]+)\s+0x([0-9a-f]+)\s*\/\* U+([0-9A-F]{4,6}) (.*) \*\/\s*$/
 *    /^\#define XK_([a-zA-Z_0-9]+)\s+0x([0-9a-f]+)\s*\/\*\(U+([0-9A-F]{4,6}) (.*)\)\*\/\s*$/
 *    /^\#define XK_([a-zA-Z_0-9]+)\s+0x([0-9a-f]+)\s*(\/\*\s*(.*)\s*\*\/)?\s*$/
 *
 * Before adding new keysyms, please do consider the following: In
 * addition to the keysym names defined in this file, the
 * XStringToKeysym() and XKeysymToString() functions will also handle
 * any keysym string of the form "U0020" to "U007E" and "U00A0" to
 * "U10FFFF" for all possible Unicode characters. In other words,
 * every possible Unicode character has already a keysym string
 * defined algorithmically, even if it is not listed here. Therefore,
 * defining an additional keysym macro is only necessary where a
 * non-hexadecimal mnemonic name is needed, or where the new keysym
 * does not represent any existing Unicode character.
 *
 * When adding new keysyms to this file, do not forget to also update the
 * following:
 *
 *   - the mappings in src/KeyBind.c in the repo
 *     git://anongit.freedesktop.org/xorg/lib/libX11
 *
 *   - the protocol specification in specs/XProtocol/X11.keysyms
 *     in the repo git://anongit.freedesktop.org/xorg/doc/xorg-docs
 *
 */

#define XK_VoidSymbol                  0xffffff  /* Void symbol */


/*
 * TTY function keys, cleverly chosen to map to ASCII, for convenience of
 * programming, but could have been arbitrary (at the cost of lookup
 * tables in client code).
 */

#define XK_BackSpace                     0xff08  /* Back space, back char */
#define XK_Tab                           0xff09
#define XK_Linefeed                      0xff0a  /* Linefeed, LF */
#define XK_Clear                         0xff0b
#define XK_Return                        0xff0d  /* Return, enter */
#define XK_Pause                         0xff13  /* Pause, hold */
#define XK_Scroll_Lock                   0xff14
#define XK_Sys_Req                       0xff15
#define XK_Escape                        0xff1b
#define XK_Delete                        0xffff  /* Delete, rubout */



/* International & multi-key character composition */

#define XK_Multi_key                     0xff20  /* Multi-key character compose */
#define XK_Codeinput                     0xff37
#define XK_SingleCandidate               0xff3c
#define XK_MultipleCandidate             0xff3d
#define XK_PreviousCandidate             0xff3e

/* Japanese keyboard support */

#define XK_Kanji                         0xff21  /* Kanji, Kanji convert */
#define XK_Muhenkan                      0xff22  /* Cancel Conversion */
#define XK_Henkan_Mode                   0xff23  /* Start/Stop Conversion */
#define XK_Henkan                        0xff23  /* Alias for Henkan_Mode */
#define XK_Romaji                        0xff24  /* to Romaji */
#define XK_Hiragana                      0xff25  /* to Hiragana */
#define XK_Katakana                      0xff26  /* to Katakana */
#define XK_Hiragana_Katakana             0xff27  /* Hiragana/Katakana toggle */
#define XK_Zenkaku                       0xff28  /* to Zenkaku */
#define XK_Hankaku                       0xff29  /* to Hankaku */
#define XK_Zenkaku_Hankaku               0xff2a  /* Zenkaku/Hankaku toggle */
#define XK_Touroku                       0xff2b  /* Add to Dictionary */
#define XK_Massyo                        0xff2c  /* Delete from Dictionary */
#define XK_Kana_Lock                     0xff2d  /* Kana Lock */
#define XK_Kana_Shift                    0xff2e  /* Kana Shift */
#define XK_Eisu_Shift                    0xff2f  /* Alphanumeric Shift */
#define XK_Eisu_toggle                   0xff30  /* Alphanumeric toggle */
#define XK_Kanji_Bangou                  0xff37  /* Codeinput */
#define XK_Zen_Koho                      0xff3d  /* Multiple/All Candidate(s) */
#define XK_Mae_Koho                      0xff3e  /* Previous Candidate */

/* 0xff31 thru 0xff3f are under XK_KOREAN */

/* Cursor control & motion */

#define XK_Home                          0xff50
#define XK_Left                          0xff51  /* Move left, left arrow */
#define XK_Up                            0xff52  /* Move up, up arrow */
#define XK_Right                         0xff53  /* Move right, right arrow */
#define XK_Down                          0xff54  /* Move down, down arrow */
#define XK_Prior                         0xff55  /* Prior, previous */
#define XK_Page_Up                       0xff55
#define XK_Next                          0xff56  /* Next */
#define XK_Page_Down                     0xff56
#define XK_End                           0xff57  /* EOL */
#define XK_Begin                         0xff58  /* BOL */


/* Misc functions */

#define XK_Select                        0xff60  /* Select, mark */
#define XK_Print                         0xff61
#define XK_Execute                       0xff62  /* Execute, run, do */
#define XK_Insert                        0xff63  /* Insert, insert here */
#define XK_Undo                          0xff65
#define XK_Redo                          0xff66  /* Redo, again */
#define XK_Menu                          0xff67
#define XK_Find                          0xff68  /* Find, search */
#define XK_Cancel                        0xff69  /* Cancel, stop, abort, exit */
#define XK_Help                          0xff6a  /* Help */
#define XK_Break                         0xff6b
#define XK_Mode_switch                   0xff7e  /* Character set switch */
#define XK_script_switch                 0xff7e  /* Alias for mode_switch */
#define XK_Num_Lock                      0xff7f

/* Keypad functions, keypad numbers cleverly chosen to map to ASCII */

#define XK_KP_Space                      0xff80  /* Space */
#define XK_KP_Tab                        0xff89
#define XK_KP_Enter                      0xff8d  /* Enter */
#define XK_KP_F1                         0xff91  /* PF1, KP_A, ... */
#define XK_KP_F2                         0xff92
#define XK_KP_F3                         0xff93
#define XK_KP_F4                         0xff94
#define XK_KP_Home                       0xff95
#define XK_KP_Left                       0xff96
#define XK_KP_Up                         0xff97
#define XK_KP_Right                      0xff98
#define XK_KP_Down                       0xff99
#define XK_KP_Prior                      0xff9a
#define XK_KP_Page_Up                    0xff9a
#define XK_KP_Next                       0xff9b
#define XK_KP_Page_Down                  0xff9b
#define XK_KP_End                        0xff9c
#define XK_KP_Begin                      0xff9d
#define XK_KP_Insert                     0xff9e
#define XK_KP_Delete                     0xff9f
#define XK_KP_Equal                      0xffbd  /* Equals */
#define XK_KP_Multiply                   0xffaa
#define XK_KP_Add                        0xffab
#define XK_KP_Separator                  0xffac  /* Separator, often comma */
#define XK_KP_Subtract                   0xffad
#define XK_KP_Decimal                    0xffae
#define XK_KP_Divide                     0xffaf

#define XK_KP_0                          0xffb0
#define XK_KP_1                          0xffb1
#define XK_KP_2                          0xffb2
#define XK_KP_3                          0xffb3
#define XK_KP_4                          0xffb4
#define XK_KP_5                          0xffb5
#define XK_KP_6                          0xffb6
#define XK_KP_7                          0xffb7
#define XK_KP_8                          0xffb8
#define XK_KP_9                          0xffb9



/*
 * Auxiliary functions; note the duplicate definitions for left and right
 * function keys;  Sun keyboards and a few other manufacturers have such
 * function key groups on the left and/or right sides of the keyboard.
 * We've not found a keyboard with more than 35 function keys total.
 */

#define XK_F1                            0xffbe
#define XK_F2                            0xffbf
#define XK_F3                            0xffc0
#define XK_F4                            0xffc1
#define XK_F5                            0xffc2
#define XK_F6                            0xffc3
#define XK_F7                            0xffc4
#define XK_F8                            0xffc5
#define XK_F9                            0xffc6
#define XK_F10                           0xffc7
#define XK_F11                           0xffc8
#define XK_L1                            0xffc8
#define XK_F12                           0xffc9
#define XK_L2                            0xffc9
#define XK_F13                           0xffca
#define XK_L3                            0xffca
#define XK_F14                           0xffcb
#define XK_L4                            0xffcb
#define XK_F15                           0xffcc
#define XK_L5                            0xffcc
#define XK_F16                           0xffcd
#define XK_L6                            0xffcd
#define XK_F17                           0xffce
#define XK_L7                            0xffce
#define XK_F18                           0xffcf
#define XK_L8                            0xffcf
#define XK_F19                           0xffd0
#define XK_L9                            0xffd0
#define XK_F20                           0xffd1
#define XK_L10                           0xffd1
#define XK_F21                           0xffd2
#define XK_R1                            0xffd2
#define XK_F22                           0xffd3
#define XK_R2                            0xffd3
#define XK_F23                           0xffd4
#define XK_R3                            0xffd4
#define XK_F24                           0xffd5
#define XK_R4                            0xffd5
#define XK_F25                           0xffd6
#define XK_R5                            0xffd6
#define XK_F26                           0xffd7
#define XK_R6                            0xffd7
#define XK_F27                           0xffd8
#define XK_R7                            0xffd8
#define XK_F28                           0xffd9
#define XK_R8                            0xffd9
#define XK_F29                           0xffda
#define XK_R9                            0xffda
#define XK_F30                           0xffdb
#define XK_R10                           0xffdb
#define XK_F31                           0xffdc
#define XK_R11                           0xffdc
#define XK_F32                           0xffdd
#define XK_R12                           0xffdd
#define XK_F33                           0xffde
#define XK_R13                           0xffde
#define XK_F34                           0xffdf
#define XK_R14                           0xffdf
#define XK_F35                           0xffe0
#define XK_R15                           0xffe0

/* Modifiers */

#define XK_Shift_L                       0xffe1  /* Left shift */
#define XK_Shift_R                       0xffe2  /* Right shift */
#define XK_Control_L                     0xffe3  /* Left control */
#define XK_Control_R                     0xffe4  /* Right control */
#define XK_Caps_Lock                     0xffe5  /* Caps lock */
#define XK_Shift_Lock                    0xffe6  /* Shift lock */

#define XK_Meta_L                        0xffe7  /* Left meta */
#define XK_Meta_R                        0xffe8  /* Right meta */
#define XK_Alt_L                         0xffe9  /* Left alt */
#define XK_Alt_R                         0xffea  /* Right alt */
#define XK_Super_L                       0xffeb  /* Left super */
#define XK_Super_R                       0xffec  /* Right super */
#define XK_Hyper_L                       0xffed  /* Left hyper */
#define XK_Hyper_R                       0xffee  /* Right hyper */
/* XK_MISCELLANY */

/*
 * Keyboard (XKB) Extension function and modifier keys
 * (from Appendix C of "The X Keyboard Extension: Protocol Specification")
 * Byte 3 = 0xfe
 */


#define XK_ISO_Lock                      0xfe01
#define XK_ISO_Level2_Latch              0xfe02
#define XK_ISO_Level3_Shift              0xfe03
#define XK_ISO_Level3_Latch              0xfe04
#define XK_ISO_Level3_Lock               0xfe05
#define XK_ISO_Level5_Shift              0xfe11
#define XK_ISO_Level5_Latch              0xfe12
#define XK_ISO_Level5_Lock               0xfe13
#define XK_ISO_Group_Shift               0xff7e  /* Alias for mode_switch */
#define XK_ISO_Group_Latch               0xfe06
#define XK_ISO_Group_Lock                0xfe07
#define XK_ISO_Next_Group                0xfe08
#define XK_ISO_Next_Group_Lock           0xfe09
#define XK_ISO_Prev_Group                0xfe0a
#define XK_ISO_Prev_Group_Lock           0xfe0b
#define XK_ISO_First_Group               0xfe0c
#define XK_ISO_First_Group_Lock          0xfe0d
#define XK_ISO_Last_Group                0xfe0e
#define XK_ISO_Last_Group_Lock           0xfe0f

#define XK_ISO_Left_Tab                  0xfe20
#define XK_ISO_Move_Line_Up              0xfe21
#define XK_ISO_Move_Line_Down            0xfe22
#define XK_ISO_Partial_Line_Up           0xfe23
#define XK_ISO_Partial_Line_Down         0xfe24
#define XK_ISO_Partial_Space_Left        0xfe25
#define XK_ISO_Partial_Space_Right       0xfe26
#define XK_ISO_Set_Margin_Left           0xfe27
#define XK_ISO_Set_Margin_Right          0xfe28
#define XK_ISO_Release_Margin_Left       0xfe29
#define XK_ISO_Release_Margin_Right      0xfe2a
#define XK_ISO_Release_Both_Margins      0xfe2b
#define XK_ISO_Fast_Cursor_Left          0xfe2c
#define XK_ISO_Fast_Cursor_Right         0xfe2d
#define XK_ISO_Fast_Cursor_Up            0xfe2e
#define XK_ISO_Fast_Cursor_Down          0xfe2f
#define XK_ISO_Continuous_Underline      0xfe30
#define XK_ISO_Discontinuous_Underline   0xfe31
#define XK_ISO_Emphasize                 0xfe32
#define XK_ISO_Center_Object             0xfe33
#define XK_ISO_Enter                     0xfe34

#define XK_dead_grave                    0xfe50
#define XK_dead_acute                    0xfe51
#define XK_dead_circumflex               0xfe52
#define XK_dead_tilde                    0xfe53
#define XK_dead_perispomeni              0xfe53  /* alias for dead_tilde */
#define XK_dead_macron                   0xfe54
#define XK_dead_breve                    0xfe55
#define XK_dead_abovedot                 0xfe56
#define XK_dead_diaeresis                0xfe57
#define XK_dead_abovering                0xfe58
#define XK_dead_doubleacute              0xfe59
#define XK_dead_caron                    0xfe5a
#define XK_dead_cedilla                  0xfe5b
#define XK_dead_ogonek                   0xfe5c
#define XK_dead_iota                     0xfe5d
#define XK_dead_voiced_sound             0xfe5e
#define XK_dead_semivoiced_sound         0xfe5f
#define XK_dead_belowdot                 0xfe60
#define XK_dead_hook                     0xfe61
#define XK_dead_horn                     0xfe62
#define XK_dead_stroke                   0xfe63
#define XK_dead_abovecomma               0xfe64
#define XK_dead_psili                    0xfe64  /* alias for dead_abovecomma */
#define XK_dead_abovereversedcomma       0xfe65
#define XK_dead_dasia                    0xfe65  /* alias for dead_abovereversedcomma */
#define XK_dead_doublegrave              0xfe66
#define XK_dead_belowring                0xfe67
#define XK_dead_belowmacron              0xfe68
#define XK_dead_belowcircumflex          0xfe69
#define XK_dead_belowtilde               0xfe6a
#define XK_dead_belowbreve               0xfe6b
#define XK_dead_belowdiaeresis           0xfe6c
#define XK_dead_invertedbreve            0xfe6d
#define XK_dead_belowcomma               0xfe6e
#define XK_dead_currency                 0xfe6f

/* dead vowels for universal syllable entry */
#define XK_dead_a                        0xfe80
#define XK_dead_A                        0xfe81
#define XK_dead_e                        0xfe82
#define XK_dead_E                        0xfe83
#define XK_dead_i                        0xfe84
#define XK_dead_I                        0xfe85
#define XK_dead_o                        0xfe86
#define XK_dead_O                        0xfe87
#define XK_dead_u                        0xfe88
#define XK_dead_U                        0xfe89
#define XK_dead_small_schwa              0xfe8a
#define XK_dead_capital_schwa            0xfe8b

#define XK_First_Virtual_Screen          0xfed0
#define XK_Prev_Virtual_Screen           0xfed1
#define XK_Next_Virtual_Screen           0xfed2
#define XK_Last_Virtual_Screen           0xfed4
#define XK_Terminate_Server              0xfed5

#define XK_AccessX_Enable                0xfe70
#define XK_AccessX_Feedback_Enable       0xfe71
#define XK_RepeatKeys_Enable             0xfe72
#define XK_SlowKeys_Enable               0xfe73
#define XK_BounceKeys_Enable             0xfe74
#define XK_StickyKeys_Enable             0xfe75
#define XK_MouseKeys_Enable              0xfe76
#define XK_MouseKeys_Accel_Enable        0xfe77
#define XK_Overlay1_Enable               0xfe78
#define XK_Overlay2_Enable               0xfe79
#define XK_AudibleBell_Enable            0xfe7a

#define XK_Pointer_Left                  0xfee0
#define XK_Pointer_Right                 0xfee1
#define XK_Pointer_Up                    0xfee2
#define XK_Pointer_Down                  0xfee3
#define XK_Pointer_UpLeft                0xfee4
#define XK_Pointer_UpRight               0xfee5
#define XK_Pointer_DownLeft              0xfee6
#define XK_Pointer_DownRight             0xfee7
#define XK_Pointer_Button_Dflt           0xfee8
#define XK_Pointer_Button1               0xfee9
#define XK_Pointer_Button2               0xfeea
#define XK_Pointer_Button3               0xfeeb
#define XK_Pointer_Button4               0xfeec
#define XK_Pointer_Button5               0xfeed
#define XK_Pointer_DblClick_Dflt         0xfeee
#define XK_Pointer_DblClick1             0xfeef
#define XK_Pointer_DblClick2             0xfef0
#define XK_Pointer_DblClick3             0xfef1
#define XK_Pointer_DblClick4             0xfef2
#define XK_Pointer_DblClick5             0xfef3
#define XK_Pointer_Drag_Dflt             0xfef4
#define XK_Pointer_Drag1                 0xfef5
#define XK_Pointer_Drag2                 0xfef6
#define XK_Pointer_Drag3                 0xfef7
#define XK_Pointer_Drag4                 0xfef8
#define XK_Pointer_Drag5                 0xfefd

#define XK_Pointer_EnableKeys            0xfef9
#define XK_Pointer_Accelerate            0xfefa
#define XK_Pointer_DfltBtnNext           0xfefb
#define XK_Pointer_DfltBtnPrev           0xfefc

/* XK_XKB_KEYS */

/*
 * 3270 Terminal Keys
 * Byte 3 = 0xfd
 */

/* XK_3270 */
# 519 "/usr/include/X11/keysymdef.h" 3


/*
 * Latin 1
 * (ISO/IEC 8859-1 = Unicode U+0020..U+00FF)
 * Byte 3 = 0
 */

#define XK_space                         0x0020  /* U+0020 SPACE */
#define XK_exclam                        0x0021  /* U+0021 EXCLAMATION MARK */
#define XK_quotedbl                      0x0022  /* U+0022 QUOTATION MARK */
#define XK_numbersign                    0x0023  /* U+0023 NUMBER SIGN */
#define XK_dollar                        0x0024  /* U+0024 DOLLAR SIGN */
#define XK_percent                       0x0025  /* U+0025 PERCENT SIGN */
#define XK_ampersand                     0x0026  /* U+0026 AMPERSAND */
#define XK_apostrophe                    0x0027  /* U+0027 APOSTROPHE */
#define XK_quoteright                    0x0027  /* deprecated */
#define XK_parenleft                     0x0028  /* U+0028 LEFT PARENTHESIS */
#define XK_parenright                    0x0029  /* U+0029 RIGHT PARENTHESIS */
#define XK_asterisk                      0x002a  /* U+002A ASTERISK */
#define XK_plus                          0x002b  /* U+002B PLUS SIGN */
#define XK_comma                         0x002c  /* U+002C COMMA */
#define XK_minus                         0x002d  /* U+002D HYPHEN-MINUS */
#define XK_period                        0x002e  /* U+002E FULL STOP */
#define XK_slash                         0x002f  /* U+002F SOLIDUS */
#define XK_0                             0x0030  /* U+0030 DIGIT ZERO */
#define XK_1                             0x0031  /* U+0031 DIGIT ONE */
#define XK_2                             0x0032  /* U+0032 DIGIT TWO */
#define XK_3                             0x0033  /* U+0033 DIGIT THREE */
#define XK_4                             0x0034  /* U+0034 DIGIT FOUR */
#define XK_5                             0x0035  /* U+0035 DIGIT FIVE */
#define XK_6                             0x0036  /* U+0036 DIGIT SIX */
#define XK_7                             0x0037  /* U+0037 DIGIT SEVEN */
#define XK_8                             0x0038  /* U+0038 DIGIT EIGHT */
#define XK_9                             0x0039  /* U+0039 DIGIT NINE */
#define XK_colon                         0x003a  /* U+003A COLON */
#define XK_semicolon                     0x003b  /* U+003B SEMICOLON */
#define XK_less                          0x003c  /* U+003C LESS-THAN SIGN */
#define XK_equal                         0x003d  /* U+003D EQUALS SIGN */
#define XK_greater                       0x003e  /* U+003E GREATER-THAN SIGN */
#define XK_question                      0x003f  /* U+003F QUESTION MARK */
#define XK_at                            0x0040  /* U+0040 COMMERCIAL AT */
#define XK_A                             0x0041  /* U+0041 LATIN CAPITAL LETTER A */
#define XK_B                             0x0042  /* U+0042 LATIN CAPITAL LETTER B */
#define XK_C                             0x0043  /* U+0043 LATIN CAPITAL LETTER C */
#define XK_D                             0x0044  /* U+0044 LATIN CAPITAL LETTER D */
#define XK_E                             0x0045  /* U+0045 LATIN CAPITAL LETTER E */
#define XK_F                             0x0046  /* U+0046 LATIN CAPITAL LETTER F */
#define XK_G                             0x0047  /* U+0047 LATIN CAPITAL LETTER G */
#define XK_H                             0x0048  /* U+0048 LATIN CAPITAL LETTER H */
#define XK_I                             0x0049  /* U+0049 LATIN CAPITAL LETTER I */
#define XK_J                             0x004a  /* U+004A LATIN CAPITAL LETTER J */
#define XK_K                             0x004b  /* U+004B LATIN CAPITAL LETTER K */
#define XK_L                             0x004c  /* U+004C LATIN CAPITAL LETTER L */
#define XK_M                             0x004d  /* U+004D LATIN CAPITAL LETTER M */
#define XK_N                             0x004e  /* U+004E LATIN CAPITAL LETTER N */
#define XK_O                             0x004f  /* U+004F LATIN CAPITAL LETTER O */
#define XK_P                             0x0050  /* U+0050 LATIN CAPITAL LETTER P */
#define XK_Q                             0x0051  /* U+0051 LATIN CAPITAL LETTER Q */
#define XK_R                             0x0052  /* U+0052 LATIN CAPITAL LETTER R */
#define XK_S                             0x0053  /* U+0053 LATIN CAPITAL LETTER S */
#define XK_T                             0x0054  /* U+0054 LATIN CAPITAL LETTER T */
#define XK_U                             0x0055  /* U+0055 LATIN CAPITAL LETTER U */
#define XK_V                             0x0056  /* U+0056 LATIN CAPITAL LETTER V */
#define XK_W                             0x0057  /* U+0057 LATIN CAPITAL LETTER W */
#define XK_X                             0x0058  /* U+0058 LATIN CAPITAL LETTER X */
#define XK_Y                             0x0059  /* U+0059 LATIN CAPITAL LETTER Y */
#define XK_Z                             0x005a  /* U+005A LATIN CAPITAL LETTER Z */
#define XK_bracketleft                   0x005b  /* U+005B LEFT SQUARE BRACKET */
#define XK_backslash                     0x005c  /* U+005C REVERSE SOLIDUS */
#define XK_bracketright                  0x005d  /* U+005D RIGHT SQUARE BRACKET */
#define XK_asciicircum                   0x005e  /* U+005E CIRCUMFLEX ACCENT */
#define XK_underscore                    0x005f  /* U+005F LOW LINE */
#define XK_grave                         0x0060  /* U+0060 GRAVE ACCENT */
#define XK_quoteleft                     0x0060  /* deprecated */
#define XK_a                             0x0061  /* U+0061 LATIN SMALL LETTER A */
#define XK_b                             0x0062  /* U+0062 LATIN SMALL LETTER B */
#define XK_c                             0x0063  /* U+0063 LATIN SMALL LETTER C */
#define XK_d                             0x0064  /* U+0064 LATIN SMALL LETTER D */
#define XK_e                             0x0065  /* U+0065 LATIN SMALL LETTER E */
#define XK_f                             0x0066  /* U+0066 LATIN SMALL LETTER F */
#define XK_g                             0x0067  /* U+0067 LATIN SMALL LETTER G */
#define XK_h                             0x0068  /* U+0068 LATIN SMALL LETTER H */
#define XK_i                             0x0069  /* U+0069 LATIN SMALL LETTER I */
#define XK_j                             0x006a  /* U+006A LATIN SMALL LETTER J */
#define XK_k                             0x006b  /* U+006B LATIN SMALL LETTER K */
#define XK_l                             0x006c  /* U+006C LATIN SMALL LETTER L */
#define XK_m                             0x006d  /* U+006D LATIN SMALL LETTER M */
#define XK_n                             0x006e  /* U+006E LATIN SMALL LETTER N */
#define XK_o                             0x006f  /* U+006F LATIN SMALL LETTER O */
#define XK_p                             0x0070  /* U+0070 LATIN SMALL LETTER P */
#define XK_q                             0x0071  /* U+0071 LATIN SMALL LETTER Q */
#define XK_r                             0x0072  /* U+0072 LATIN SMALL LETTER R */
#define XK_s                             0x0073  /* U+0073 LATIN SMALL LETTER S */
#define XK_t                             0x0074  /* U+0074 LATIN SMALL LETTER T */
#define XK_u                             0x0075  /* U+0075 LATIN SMALL LETTER U */
#define XK_v                             0x0076  /* U+0076 LATIN SMALL LETTER V */
#define XK_w                             0x0077  /* U+0077 LATIN SMALL LETTER W */
#define XK_x                             0x0078  /* U+0078 LATIN SMALL LETTER X */
#define XK_y                             0x0079  /* U+0079 LATIN SMALL LETTER Y */
#define XK_z                             0x007a  /* U+007A LATIN SMALL LETTER Z */
#define XK_braceleft                     0x007b  /* U+007B LEFT CURLY BRACKET */
#define XK_bar                           0x007c  /* U+007C VERTICAL LINE */
#define XK_braceright                    0x007d  /* U+007D RIGHT CURLY BRACKET */
#define XK_asciitilde                    0x007e  /* U+007E TILDE */

#define XK_nobreakspace                  0x00a0  /* U+00A0 NO-BREAK SPACE */
#define XK_exclamdown                    0x00a1  /* U+00A1 INVERTED EXCLAMATION MARK */
#define XK_cent                          0x00a2  /* U+00A2 CENT SIGN */
#define XK_sterling                      0x00a3  /* U+00A3 POUND SIGN */
#define XK_currency                      0x00a4  /* U+00A4 CURRENCY SIGN */
#define XK_yen                           0x00a5  /* U+00A5 YEN SIGN */
#define XK_brokenbar                     0x00a6  /* U+00A6 BROKEN BAR */
#define XK_section                       0x00a7  /* U+00A7 SECTION SIGN */
#define XK_diaeresis                     0x00a8  /* U+00A8 DIAERESIS */
#define XK_copyright                     0x00a9  /* U+00A9 COPYRIGHT SIGN */
#define XK_ordfeminine                   0x00aa  /* U+00AA FEMININE ORDINAL INDICATOR */
#define XK_guillemotleft                 0x00ab  /* U+00AB LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */
#define XK_notsign                       0x00ac  /* U+00AC NOT SIGN */
#define XK_hyphen                        0x00ad  /* U+00AD SOFT HYPHEN */
#define XK_registered                    0x00ae  /* U+00AE REGISTERED SIGN */
#define XK_macron                        0x00af  /* U+00AF MACRON */
#define XK_degree                        0x00b0  /* U+00B0 DEGREE SIGN */
#define XK_plusminus                     0x00b1  /* U+00B1 PLUS-MINUS SIGN */
#define XK_twosuperior                   0x00b2  /* U+00B2 SUPERSCRIPT TWO */
#define XK_threesuperior                 0x00b3  /* U+00B3 SUPERSCRIPT THREE */
#define XK_acute                         0x00b4  /* U+00B4 ACUTE ACCENT */
#define XK_mu                            0x00b5  /* U+00B5 MICRO SIGN */
#define XK_paragraph                     0x00b6  /* U+00B6 PILCROW SIGN */
#define XK_periodcentered                0x00b7  /* U+00B7 MIDDLE DOT */
#define XK_cedilla                       0x00b8  /* U+00B8 CEDILLA */
#define XK_onesuperior                   0x00b9  /* U+00B9 SUPERSCRIPT ONE */
#define XK_masculine                     0x00ba  /* U+00BA MASCULINE ORDINAL INDICATOR */
#define XK_guillemotright                0x00bb  /* U+00BB RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */
#define XK_onequarter                    0x00bc  /* U+00BC VULGAR FRACTION ONE QUARTER */
#define XK_onehalf                       0x00bd  /* U+00BD VULGAR FRACTION ONE HALF */
#define XK_threequarters                 0x00be  /* U+00BE VULGAR FRACTION THREE QUARTERS */
#define XK_questiondown                  0x00bf  /* U+00BF INVERTED QUESTION MARK */
#define XK_Agrave                        0x00c0  /* U+00C0 LATIN CAPITAL LETTER A WITH GRAVE */
#define XK_Aacute                        0x00c1  /* U+00C1 LATIN CAPITAL LETTER A WITH ACUTE */
#define XK_Acircumflex                   0x00c2  /* U+00C2 LATIN CAPITAL LETTER A WITH CIRCUMFLEX */
#define XK_Atilde                        0x00c3  /* U+00C3 LATIN CAPITAL LETTER A WITH TILDE */
#define XK_Adiaeresis                    0x00c4  /* U+00C4 LATIN CAPITAL LETTER A WITH DIAERESIS */
#define XK_Aring                         0x00c5  /* U+00C5 LATIN CAPITAL LETTER A WITH RING ABOVE */
#define XK_AE                            0x00c6  /* U+00C6 LATIN CAPITAL LETTER AE */
#define XK_Ccedilla                      0x00c7  /* U+00C7 LATIN CAPITAL LETTER C WITH CEDILLA */
#define XK_Egrave                        0x00c8  /* U+00C8 LATIN CAPITAL LETTER E WITH GRAVE */
#define XK_Eacute                        0x00c9  /* U+00C9 LATIN CAPITAL LETTER E WITH ACUTE */
#define XK_Ecircumflex                   0x00ca  /* U+00CA LATIN CAPITAL LETTER E WITH CIRCUMFLEX */
#define XK_Ediaeresis                    0x00cb  /* U+00CB LATIN CAPITAL LETTER E WITH DIAERESIS */
#define XK_Igrave                        0x00cc  /* U+00CC LATIN CAPITAL LETTER I WITH GRAVE */
#define XK_Iacute                        0x00cd  /* U+00CD LATIN CAPITAL LETTER I WITH ACUTE */
#define XK_Icircumflex                   0x00ce  /* U+00CE LATIN CAPITAL LETTER I WITH CIRCUMFLEX */
#define XK_Idiaeresis                    0x00cf  /* U+00CF LATIN CAPITAL LETTER I WITH DIAERESIS */
#define XK_ETH                           0x00d0  /* U+00D0 LATIN CAPITAL LETTER ETH */
#define XK_Eth                           0x00d0  /* deprecated */
#define XK_Ntilde                        0x00d1  /* U+00D1 LATIN CAPITAL LETTER N WITH TILDE */
#define XK_Ograve                        0x00d2  /* U+00D2 LATIN CAPITAL LETTER O WITH GRAVE */
#define XK_Oacute                        0x00d3  /* U+00D3 LATIN CAPITAL LETTER O WITH ACUTE */
#define XK_Ocircumflex                   0x00d4  /* U+00D4 LATIN CAPITAL LETTER O WITH CIRCUMFLEX */
#define XK_Otilde                        0x00d5  /* U+00D5 LATIN CAPITAL LETTER O WITH TILDE */
#define XK_Odiaeresis                    0x00d6  /* U+00D6 LATIN CAPITAL LETTER O WITH DIAERESIS */
#define XK_multiply                      0x00d7  /* U+00D7 MULTIPLICATION SIGN */
#define XK_Oslash                        0x00d8  /* U+00D8 LATIN CAPITAL LETTER O WITH STROKE */
#define XK_Ooblique                      0x00d8  /* U+00D8 LATIN CAPITAL LETTER O WITH STROKE */
#define XK_Ugrave                        0x00d9  /* U+00D9 LATIN CAPITAL LETTER U WITH GRAVE */
#define XK_Uacute                        0x00da  /* U+00DA LATIN CAPITAL LETTER U WITH ACUTE */
#define XK_Ucircumflex                   0x00db  /* U+00DB LATIN CAPITAL LETTER U WITH CIRCUMFLEX */
#define XK_Udiaeresis                    0x00dc  /* U+00DC LATIN CAPITAL LETTER U WITH DIAERESIS */
#define XK_Yacute                        0x00dd  /* U+00DD LATIN CAPITAL LETTER Y WITH ACUTE */
#define XK_THORN                         0x00de  /* U+00DE LATIN CAPITAL LETTER THORN */
#define XK_Thorn                         0x00de  /* deprecated */
#define XK_ssharp                        0x00df  /* U+00DF LATIN SMALL LETTER SHARP S */
#define XK_agrave                        0x00e0  /* U+00E0 LATIN SMALL LETTER A WITH GRAVE */
#define XK_aacute                        0x00e1  /* U+00E1 LATIN SMALL LETTER A WITH ACUTE */
#define XK_acircumflex                   0x00e2  /* U+00E2 LATIN SMALL LETTER A WITH CIRCUMFLEX */
#define XK_atilde                        0x00e3  /* U+00E3 LATIN SMALL LETTER A WITH TILDE */
#define XK_adiaeresis                    0x00e4  /* U+00E4 LATIN SMALL LETTER A WITH DIAERESIS */
#define XK_aring                         0x00e5  /* U+00E5 LATIN SMALL LETTER A WITH RING ABOVE */
#define XK_ae                            0x00e6  /* U+00E6 LATIN SMALL LETTER AE */
#define XK_ccedilla                      0x00e7  /* U+00E7 LATIN SMALL LETTER C WITH CEDILLA */
#define XK_egrave                        0x00e8  /* U+00E8 LATIN SMALL LETTER E WITH GRAVE */
#define XK_eacute                        0x00e9  /* U+00E9 LATIN SMALL LETTER E WITH ACUTE */
#define XK_ecircumflex                   0x00ea  /* U+00EA LATIN SMALL LETTER E WITH CIRCUMFLEX */
#define XK_ediaeresis                    0x00eb  /* U+00EB LATIN SMALL LETTER E WITH DIAERESIS */
#define XK_igrave                        0x00ec  /* U+00EC LATIN SMALL LETTER I WITH GRAVE */
#define XK_iacute                        0x00ed  /* U+00ED LATIN SMALL LETTER I WITH ACUTE */
#define XK_icircumflex                   0x00ee  /* U+00EE LATIN SMALL LETTER I WITH CIRCUMFLEX */
#define XK_idiaeresis                    0x00ef  /* U+00EF LATIN SMALL LETTER I WITH DIAERESIS */
#define XK_eth                           0x00f0  /* U+00F0 LATIN SMALL LETTER ETH */
#define XK_ntilde                        0x00f1  /* U+00F1 LATIN SMALL LETTER N WITH TILDE */
#define XK_ograve                        0x00f2  /* U+00F2 LATIN SMALL LETTER O WITH GRAVE */
#define XK_oacute                        0x00f3  /* U+00F3 LATIN SMALL LETTER O WITH ACUTE */
#define XK_ocircumflex                   0x00f4  /* U+00F4 LATIN SMALL LETTER O WITH CIRCUMFLEX */
#define XK_otilde                        0x00f5  /* U+00F5 LATIN SMALL LETTER O WITH TILDE */
#define XK_odiaeresis                    0x00f6  /* U+00F6 LATIN SMALL LETTER O WITH DIAERESIS */
#define XK_division                      0x00f7  /* U+00F7 DIVISION SIGN */
#define XK_oslash                        0x00f8  /* U+00F8 LATIN SMALL LETTER O WITH STROKE */
#define XK_ooblique                      0x00f8  /* U+00F8 LATIN SMALL LETTER O WITH STROKE */
#define XK_ugrave                        0x00f9  /* U+00F9 LATIN SMALL LETTER U WITH GRAVE */
#define XK_uacute                        0x00fa  /* U+00FA LATIN SMALL LETTER U WITH ACUTE */
#define XK_ucircumflex                   0x00fb  /* U+00FB LATIN SMALL LETTER U WITH CIRCUMFLEX */
#define XK_udiaeresis                    0x00fc  /* U+00FC LATIN SMALL LETTER U WITH DIAERESIS */
#define XK_yacute                        0x00fd  /* U+00FD LATIN SMALL LETTER Y WITH ACUTE */
#define XK_thorn                         0x00fe  /* U+00FE LATIN SMALL LETTER THORN */
#define XK_ydiaeresis                    0x00ff  /* U+00FF LATIN SMALL LETTER Y WITH DIAERESIS */
/* XK_LATIN1 */

/*
 * Latin 2
 * Byte 3 = 1
 */


#define XK_Aogonek                       0x01a1  /* U+0104 LATIN CAPITAL LETTER A WITH OGONEK */
#define XK_breve                         0x01a2  /* U+02D8 BREVE */
#define XK_Lstroke                       0x01a3  /* U+0141 LATIN CAPITAL LETTER L WITH STROKE */
#define XK_Lcaron                        0x01a5  /* U+013D LATIN CAPITAL LETTER L WITH CARON */
#define XK_Sacute                        0x01a6  /* U+015A LATIN CAPITAL LETTER S WITH ACUTE */
#define XK_Scaron                        0x01a9  /* U+0160 LATIN CAPITAL LETTER S WITH CARON */
#define XK_Scedilla                      0x01aa  /* U+015E LATIN CAPITAL LETTER S WITH CEDILLA */
#define XK_Tcaron                        0x01ab  /* U+0164 LATIN CAPITAL LETTER T WITH CARON */
#define XK_Zacute                        0x01ac  /* U+0179 LATIN CAPITAL LETTER Z WITH ACUTE */
#define XK_Zcaron                        0x01ae  /* U+017D LATIN CAPITAL LETTER Z WITH CARON */
#define XK_Zabovedot                     0x01af  /* U+017B LATIN CAPITAL LETTER Z WITH DOT ABOVE */
#define XK_aogonek                       0x01b1  /* U+0105 LATIN SMALL LETTER A WITH OGONEK */
#define XK_ogonek                        0x01b2  /* U+02DB OGONEK */
#define XK_lstroke                       0x01b3  /* U+0142 LATIN SMALL LETTER L WITH STROKE */
#define XK_lcaron                        0x01b5  /* U+013E LATIN SMALL LETTER L WITH CARON */
#define XK_sacute                        0x01b6  /* U+015B LATIN SMALL LETTER S WITH ACUTE */
#define XK_caron                         0x01b7  /* U+02C7 CARON */
#define XK_scaron                        0x01b9  /* U+0161 LATIN SMALL LETTER S WITH CARON */
#define XK_scedilla                      0x01ba  /* U+015F LATIN SMALL LETTER S WITH CEDILLA */
#define XK_tcaron                        0x01bb  /* U+0165 LATIN SMALL LETTER T WITH CARON */
#define XK_zacute                        0x01bc  /* U+017A LATIN SMALL LETTER Z WITH ACUTE */
#define XK_doubleacute                   0x01bd  /* U+02DD DOUBLE ACUTE ACCENT */
#define XK_zcaron                        0x01be  /* U+017E LATIN SMALL LETTER Z WITH CARON */
#define XK_zabovedot                     0x01bf  /* U+017C LATIN SMALL LETTER Z WITH DOT ABOVE */
#define XK_Racute                        0x01c0  /* U+0154 LATIN CAPITAL LETTER R WITH ACUTE */
#define XK_Abreve                        0x01c3  /* U+0102 LATIN CAPITAL LETTER A WITH BREVE */
#define XK_Lacute                        0x01c5  /* U+0139 LATIN CAPITAL LETTER L WITH ACUTE */
#define XK_Cacute                        0x01c6  /* U+0106 LATIN CAPITAL LETTER C WITH ACUTE */
#define XK_Ccaron                        0x01c8  /* U+010C LATIN CAPITAL LETTER C WITH CARON */
#define XK_Eogonek                       0x01ca  /* U+0118 LATIN CAPITAL LETTER E WITH OGONEK */
#define XK_Ecaron                        0x01cc  /* U+011A LATIN CAPITAL LETTER E WITH CARON */
#define XK_Dcaron                        0x01cf  /* U+010E LATIN CAPITAL LETTER D WITH CARON */
#define XK_Dstroke                       0x01d0  /* U+0110 LATIN CAPITAL LETTER D WITH STROKE */
#define XK_Nacute                        0x01d1  /* U+0143 LATIN CAPITAL LETTER N WITH ACUTE */
#define XK_Ncaron                        0x01d2  /* U+0147 LATIN CAPITAL LETTER N WITH CARON */
#define XK_Odoubleacute                  0x01d5  /* U+0150 LATIN CAPITAL LETTER O WITH DOUBLE ACUTE */
#define XK_Rcaron                        0x01d8  /* U+0158 LATIN CAPITAL LETTER R WITH CARON */
#define XK_Uring                         0x01d9  /* U+016E LATIN CAPITAL LETTER U WITH RING ABOVE */
#define XK_Udoubleacute                  0x01db  /* U+0170 LATIN CAPITAL LETTER U WITH DOUBLE ACUTE */
#define XK_Tcedilla                      0x01de  /* U+0162 LATIN CAPITAL LETTER T WITH CEDILLA */
#define XK_racute                        0x01e0  /* U+0155 LATIN SMALL LETTER R WITH ACUTE */
#define XK_abreve                        0x01e3  /* U+0103 LATIN SMALL LETTER A WITH BREVE */
#define XK_lacute                        0x01e5  /* U+013A LATIN SMALL LETTER L WITH ACUTE */
#define XK_cacute                        0x01e6  /* U+0107 LATIN SMALL LETTER C WITH ACUTE */
#define XK_ccaron                        0x01e8  /* U+010D LATIN SMALL LETTER C WITH CARON */
#define XK_eogonek                       0x01ea  /* U+0119 LATIN SMALL LETTER E WITH OGONEK */
#define XK_ecaron                        0x01ec  /* U+011B LATIN SMALL LETTER E WITH CARON */
#define XK_dcaron                        0x01ef  /* U+010F LATIN SMALL LETTER D WITH CARON */
#define XK_dstroke                       0x01f0  /* U+0111 LATIN SMALL LETTER D WITH STROKE */
#define XK_nacute                        0x01f1  /* U+0144 LATIN SMALL LETTER N WITH ACUTE */
#define XK_ncaron                        0x01f2  /* U+0148 LATIN SMALL LETTER N WITH CARON */
#define XK_odoubleacute                  0x01f5  /* U+0151 LATIN SMALL LETTER O WITH DOUBLE ACUTE */
#define XK_rcaron                        0x01f8  /* U+0159 LATIN SMALL LETTER R WITH CARON */
#define XK_uring                         0x01f9  /* U+016F LATIN SMALL LETTER U WITH RING ABOVE */
#define XK_udoubleacute                  0x01fb  /* U+0171 LATIN SMALL LETTER U WITH DOUBLE ACUTE */
#define XK_tcedilla                      0x01fe  /* U+0163 LATIN SMALL LETTER T WITH CEDILLA */
#define XK_abovedot                      0x01ff  /* U+02D9 DOT ABOVE */
/* XK_LATIN2 */

/*
 * Latin 3
 * Byte 3 = 2
 */


#define XK_Hstroke                       0x02a1  /* U+0126 LATIN CAPITAL LETTER H WITH STROKE */
#define XK_Hcircumflex                   0x02a6  /* U+0124 LATIN CAPITAL LETTER H WITH CIRCUMFLEX */
#define XK_Iabovedot                     0x02a9  /* U+0130 LATIN CAPITAL LETTER I WITH DOT ABOVE */
#define XK_Gbreve                        0x02ab  /* U+011E LATIN CAPITAL LETTER G WITH BREVE */
#define XK_Jcircumflex                   0x02ac  /* U+0134 LATIN CAPITAL LETTER J WITH CIRCUMFLEX */
#define XK_hstroke                       0x02b1  /* U+0127 LATIN SMALL LETTER H WITH STROKE */
#define XK_hcircumflex                   0x02b6  /* U+0125 LATIN SMALL LETTER H WITH CIRCUMFLEX */
#define XK_idotless                      0x02b9  /* U+0131 LATIN SMALL LETTER DOTLESS I */
#define XK_gbreve                        0x02bb  /* U+011F LATIN SMALL LETTER G WITH BREVE */
#define XK_jcircumflex                   0x02bc  /* U+0135 LATIN SMALL LETTER J WITH CIRCUMFLEX */
#define XK_Cabovedot                     0x02c5  /* U+010A LATIN CAPITAL LETTER C WITH DOT ABOVE */
#define XK_Ccircumflex                   0x02c6  /* U+0108 LATIN CAPITAL LETTER C WITH CIRCUMFLEX */
#define XK_Gabovedot                     0x02d5  /* U+0120 LATIN CAPITAL LETTER G WITH DOT ABOVE */
#define XK_Gcircumflex                   0x02d8  /* U+011C LATIN CAPITAL LETTER G WITH CIRCUMFLEX */
#define XK_Ubreve                        0x02dd  /* U+016C LATIN CAPITAL LETTER U WITH BREVE */
#define XK_Scircumflex                   0x02de  /* U+015C LATIN CAPITAL LETTER S WITH CIRCUMFLEX */
#define XK_cabovedot                     0x02e5  /* U+010B LATIN SMALL LETTER C WITH DOT ABOVE */
#define XK_ccircumflex                   0x02e6  /* U+0109 LATIN SMALL LETTER C WITH CIRCUMFLEX */
#define XK_gabovedot                     0x02f5  /* U+0121 LATIN SMALL LETTER G WITH DOT ABOVE */
#define XK_gcircumflex                   0x02f8  /* U+011D LATIN SMALL LETTER G WITH CIRCUMFLEX */
#define XK_ubreve                        0x02fd  /* U+016D LATIN SMALL LETTER U WITH BREVE */
#define XK_scircumflex                   0x02fe  /* U+015D LATIN SMALL LETTER S WITH CIRCUMFLEX */
/* XK_LATIN3 */


/*
 * Latin 4
 * Byte 3 = 3
 */


#define XK_kra                           0x03a2  /* U+0138 LATIN SMALL LETTER KRA */
#define XK_kappa                         0x03a2  /* deprecated */
#define XK_Rcedilla                      0x03a3  /* U+0156 LATIN CAPITAL LETTER R WITH CEDILLA */
#define XK_Itilde                        0x03a5  /* U+0128 LATIN CAPITAL LETTER I WITH TILDE */
#define XK_Lcedilla                      0x03a6  /* U+013B LATIN CAPITAL LETTER L WITH CEDILLA */
#define XK_Emacron                       0x03aa  /* U+0112 LATIN CAPITAL LETTER E WITH MACRON */
#define XK_Gcedilla                      0x03ab  /* U+0122 LATIN CAPITAL LETTER G WITH CEDILLA */
#define XK_Tslash                        0x03ac  /* U+0166 LATIN CAPITAL LETTER T WITH STROKE */
#define XK_rcedilla                      0x03b3  /* U+0157 LATIN SMALL LETTER R WITH CEDILLA */
#define XK_itilde                        0x03b5  /* U+0129 LATIN SMALL LETTER I WITH TILDE */
#define XK_lcedilla                      0x03b6  /* U+013C LATIN SMALL LETTER L WITH CEDILLA */
#define XK_emacron                       0x03ba  /* U+0113 LATIN SMALL LETTER E WITH MACRON */
#define XK_gcedilla                      0x03bb  /* U+0123 LATIN SMALL LETTER G WITH CEDILLA */
#define XK_tslash                        0x03bc  /* U+0167 LATIN SMALL LETTER T WITH STROKE */
#define XK_ENG                           0x03bd  /* U+014A LATIN CAPITAL LETTER ENG */
#define XK_eng                           0x03bf  /* U+014B LATIN SMALL LETTER ENG */
#define XK_Amacron                       0x03c0  /* U+0100 LATIN CAPITAL LETTER A WITH MACRON */
#define XK_Iogonek                       0x03c7  /* U+012E LATIN CAPITAL LETTER I WITH OGONEK */
#define XK_Eabovedot                     0x03cc  /* U+0116 LATIN CAPITAL LETTER E WITH DOT ABOVE */
#define XK_Imacron                       0x03cf  /* U+012A LATIN CAPITAL LETTER I WITH MACRON */
#define XK_Ncedilla                      0x03d1  /* U+0145 LATIN CAPITAL LETTER N WITH CEDILLA */
#define XK_Omacron                       0x03d2  /* U+014C LATIN CAPITAL LETTER O WITH MACRON */
#define XK_Kcedilla                      0x03d3  /* U+0136 LATIN CAPITAL LETTER K WITH CEDILLA */
#define XK_Uogonek                       0x03d9  /* U+0172 LATIN CAPITAL LETTER U WITH OGONEK */
#define XK_Utilde                        0x03dd  /* U+0168 LATIN CAPITAL LETTER U WITH TILDE */
#define XK_Umacron                       0x03de  /* U+016A LATIN CAPITAL LETTER U WITH MACRON */
#define XK_amacron                       0x03e0  /* U+0101 LATIN SMALL LETTER A WITH MACRON */
#define XK_iogonek                       0x03e7  /* U+012F LATIN SMALL LETTER I WITH OGONEK */
#define XK_eabovedot                     0x03ec  /* U+0117 LATIN SMALL LETTER E WITH DOT ABOVE */
#define XK_imacron                       0x03ef  /* U+012B LATIN SMALL LETTER I WITH MACRON */
#define XK_ncedilla                      0x03f1  /* U+0146 LATIN SMALL LETTER N WITH CEDILLA */
#define XK_omacron                       0x03f2  /* U+014D LATIN SMALL LETTER O WITH MACRON */
#define XK_kcedilla                      0x03f3  /* U+0137 LATIN SMALL LETTER K WITH CEDILLA */
#define XK_uogonek                       0x03f9  /* U+0173 LATIN SMALL LETTER U WITH OGONEK */
#define XK_utilde                        0x03fd  /* U+0169 LATIN SMALL LETTER U WITH TILDE */
#define XK_umacron                       0x03fe  /* U+016B LATIN SMALL LETTER U WITH MACRON */
/* XK_LATIN4 */

/*
 * Latin 8
 */

#define XK_Wcircumflex                0x1000174  /* U+0174 LATIN CAPITAL LETTER W WITH CIRCUMFLEX */
#define XK_wcircumflex                0x1000175  /* U+0175 LATIN SMALL LETTER W WITH CIRCUMFLEX */
#define XK_Ycircumflex                0x1000176  /* U+0176 LATIN CAPITAL LETTER Y WITH CIRCUMFLEX */
#define XK_ycircumflex                0x1000177  /* U+0177 LATIN SMALL LETTER Y WITH CIRCUMFLEX */
#define XK_Babovedot                  0x1001e02  /* U+1E02 LATIN CAPITAL LETTER B WITH DOT ABOVE */
#define XK_babovedot                  0x1001e03  /* U+1E03 LATIN SMALL LETTER B WITH DOT ABOVE */
#define XK_Dabovedot                  0x1001e0a  /* U+1E0A LATIN CAPITAL LETTER D WITH DOT ABOVE */
#define XK_dabovedot                  0x1001e0b  /* U+1E0B LATIN SMALL LETTER D WITH DOT ABOVE */
#define XK_Fabovedot                  0x1001e1e  /* U+1E1E LATIN CAPITAL LETTER F WITH DOT ABOVE */
#define XK_fabovedot                  0x1001e1f  /* U+1E1F LATIN SMALL LETTER F WITH DOT ABOVE */
#define XK_Mabovedot                  0x1001e40  /* U+1E40 LATIN CAPITAL LETTER M WITH DOT ABOVE */
#define XK_mabovedot                  0x1001e41  /* U+1E41 LATIN SMALL LETTER M WITH DOT ABOVE */
#define XK_Pabovedot                  0x1001e56  /* U+1E56 LATIN CAPITAL LETTER P WITH DOT ABOVE */
#define XK_pabovedot                  0x1001e57  /* U+1E57 LATIN SMALL LETTER P WITH DOT ABOVE */
#define XK_Sabovedot                  0x1001e60  /* U+1E60 LATIN CAPITAL LETTER S WITH DOT ABOVE */
#define XK_sabovedot                  0x1001e61  /* U+1E61 LATIN SMALL LETTER S WITH DOT ABOVE */
#define XK_Tabovedot                  0x1001e6a  /* U+1E6A LATIN CAPITAL LETTER T WITH DOT ABOVE */
#define XK_tabovedot                  0x1001e6b  /* U+1E6B LATIN SMALL LETTER T WITH DOT ABOVE */
#define XK_Wgrave                     0x1001e80  /* U+1E80 LATIN CAPITAL LETTER W WITH GRAVE */
#define XK_wgrave                     0x1001e81  /* U+1E81 LATIN SMALL LETTER W WITH GRAVE */
#define XK_Wacute                     0x1001e82  /* U+1E82 LATIN CAPITAL LETTER W WITH ACUTE */
#define XK_wacute                     0x1001e83  /* U+1E83 LATIN SMALL LETTER W WITH ACUTE */
#define XK_Wdiaeresis                 0x1001e84  /* U+1E84 LATIN CAPITAL LETTER W WITH DIAERESIS */
#define XK_wdiaeresis                 0x1001e85  /* U+1E85 LATIN SMALL LETTER W WITH DIAERESIS */
#define XK_Ygrave                     0x1001ef2  /* U+1EF2 LATIN CAPITAL LETTER Y WITH GRAVE */
#define XK_ygrave                     0x1001ef3  /* U+1EF3 LATIN SMALL LETTER Y WITH GRAVE */
/* XK_LATIN8 */

/*
 * Latin 9
 * Byte 3 = 0x13
 */


#define XK_OE                            0x13bc  /* U+0152 LATIN CAPITAL LIGATURE OE */
#define XK_oe                            0x13bd  /* U+0153 LATIN SMALL LIGATURE OE */
#define XK_Ydiaeresis                    0x13be  /* U+0178 LATIN CAPITAL LETTER Y WITH DIAERESIS */
/* XK_LATIN9 */

/*
 * Katakana
 * Byte 3 = 4
 */


#define XK_overline                      0x047e  /* U+203E OVERLINE */
#define XK_kana_fullstop                 0x04a1  /* U+3002 IDEOGRAPHIC FULL STOP */
#define XK_kana_openingbracket           0x04a2  /* U+300C LEFT CORNER BRACKET */
#define XK_kana_closingbracket           0x04a3  /* U+300D RIGHT CORNER BRACKET */
#define XK_kana_comma                    0x04a4  /* U+3001 IDEOGRAPHIC COMMA */
#define XK_kana_conjunctive              0x04a5  /* U+30FB KATAKANA MIDDLE DOT */
#define XK_kana_middledot                0x04a5  /* deprecated */
#define XK_kana_WO                       0x04a6  /* U+30F2 KATAKANA LETTER WO */
#define XK_kana_a                        0x04a7  /* U+30A1 KATAKANA LETTER SMALL A */
#define XK_kana_i                        0x04a8  /* U+30A3 KATAKANA LETTER SMALL I */
#define XK_kana_u                        0x04a9  /* U+30A5 KATAKANA LETTER SMALL U */
#define XK_kana_e                        0x04aa  /* U+30A7 KATAKANA LETTER SMALL E */
#define XK_kana_o                        0x04ab  /* U+30A9 KATAKANA LETTER SMALL O */
#define XK_kana_ya                       0x04ac  /* U+30E3 KATAKANA LETTER SMALL YA */
#define XK_kana_yu                       0x04ad  /* U+30E5 KATAKANA LETTER SMALL YU */
#define XK_kana_yo                       0x04ae  /* U+30E7 KATAKANA LETTER SMALL YO */
#define XK_kana_tsu                      0x04af  /* U+30C3 KATAKANA LETTER SMALL TU */
#define XK_kana_tu                       0x04af  /* deprecated */
#define XK_prolongedsound                0x04b0  /* U+30FC KATAKANA-HIRAGANA PROLONGED SOUND MARK */
#define XK_kana_A                        0x04b1  /* U+30A2 KATAKANA LETTER A */
#define XK_kana_I                        0x04b2  /* U+30A4 KATAKANA LETTER I */
#define XK_kana_U                        0x04b3  /* U+30A6 KATAKANA LETTER U */
#define XK_kana_E                        0x04b4  /* U+30A8 KATAKANA LETTER E */
#define XK_kana_O                        0x04b5  /* U+30AA KATAKANA LETTER O */
#define XK_kana_KA                       0x04b6  /* U+30AB KATAKANA LETTER KA */
#define XK_kana_KI                       0x04b7  /* U+30AD KATAKANA LETTER KI */
#define XK_kana_KU                       0x04b8  /* U+30AF KATAKANA LETTER KU */
#define XK_kana_KE                       0x04b9  /* U+30B1 KATAKANA LETTER KE */
#define XK_kana_KO                       0x04ba  /* U+30B3 KATAKANA LETTER KO */
#define XK_kana_SA                       0x04bb  /* U+30B5 KATAKANA LETTER SA */
#define XK_kana_SHI                      0x04bc  /* U+30B7 KATAKANA LETTER SI */
#define XK_kana_SU                       0x04bd  /* U+30B9 KATAKANA LETTER SU */
#define XK_kana_SE                       0x04be  /* U+30BB KATAKANA LETTER SE */
#define XK_kana_SO                       0x04bf  /* U+30BD KATAKANA LETTER SO */
#define XK_kana_TA                       0x04c0  /* U+30BF KATAKANA LETTER TA */
#define XK_kana_CHI                      0x04c1  /* U+30C1 KATAKANA LETTER TI */
#define XK_kana_TI                       0x04c1  /* deprecated */
#define XK_kana_TSU                      0x04c2  /* U+30C4 KATAKANA LETTER TU */
#define XK_kana_TU                       0x04c2  /* deprecated */
#define XK_kana_TE                       0x04c3  /* U+30C6 KATAKANA LETTER TE */
#define XK_kana_TO                       0x04c4  /* U+30C8 KATAKANA LETTER TO */
#define XK_kana_NA                       0x04c5  /* U+30CA KATAKANA LETTER NA */
#define XK_kana_NI                       0x04c6  /* U+30CB KATAKANA LETTER NI */
#define XK_kana_NU                       0x04c7  /* U+30CC KATAKANA LETTER NU */
#define XK_kana_NE                       0x04c8  /* U+30CD KATAKANA LETTER NE */
#define XK_kana_NO                       0x04c9  /* U+30CE KATAKANA LETTER NO */
#define XK_kana_HA                       0x04ca  /* U+30CF KATAKANA LETTER HA */
#define XK_kana_HI                       0x04cb  /* U+30D2 KATAKANA LETTER HI */
#define XK_kana_FU                       0x04cc  /* U+30D5 KATAKANA LETTER HU */
#define XK_kana_HU                       0x04cc  /* deprecated */
#define XK_kana_HE                       0x04cd  /* U+30D8 KATAKANA LETTER HE */
#define XK_kana_HO                       0x04ce  /* U+30DB KATAKANA LETTER HO */
#define XK_kana_MA                       0x04cf  /* U+30DE KATAKANA LETTER MA */
#define XK_kana_MI                       0x04d0  /* U+30DF KATAKANA LETTER MI */
#define XK_kana_MU                       0x04d1  /* U+30E0 KATAKANA LETTER MU */
#define XK_kana_ME                       0x04d2  /* U+30E1 KATAKANA LETTER ME */
#define XK_kana_MO                       0x04d3  /* U+30E2 KATAKANA LETTER MO */
#define XK_kana_YA                       0x04d4  /* U+30E4 KATAKANA LETTER YA */
#define XK_kana_YU                       0x04d5  /* U+30E6 KATAKANA LETTER YU */
#define XK_kana_YO                       0x04d6  /* U+30E8 KATAKANA LETTER YO */
#define XK_kana_RA                       0x04d7  /* U+30E9 KATAKANA LETTER RA */
#define XK_kana_RI                       0x04d8  /* U+30EA KATAKANA LETTER RI */
#define XK_kana_RU                       0x04d9  /* U+30EB KATAKANA LETTER RU */
#define XK_kana_RE                       0x04da  /* U+30EC KATAKANA LETTER RE */
#define XK_kana_RO                       0x04db  /* U+30ED KATAKANA LETTER RO */
#define XK_kana_WA                       0x04dc  /* U+30EF KATAKANA LETTER WA */
#define XK_kana_N                        0x04dd  /* U+30F3 KATAKANA LETTER N */
#define XK_voicedsound                   0x04de  /* U+309B KATAKANA-HIRAGANA VOICED SOUND MARK */
#define XK_semivoicedsound               0x04df  /* U+309C KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK */
#define XK_kana_switch                   0xff7e  /* Alias for mode_switch */
/* XK_KATAKANA */

/*
 * Arabic
 * Byte 3 = 5
 */


#define XK_Farsi_0                    0x10006f0  /* U+06F0 EXTENDED ARABIC-INDIC DIGIT ZERO */
#define XK_Farsi_1                    0x10006f1  /* U+06F1 EXTENDED ARABIC-INDIC DIGIT ONE */
#define XK_Farsi_2                    0x10006f2  /* U+06F2 EXTENDED ARABIC-INDIC DIGIT TWO */
#define XK_Farsi_3                    0x10006f3  /* U+06F3 EXTENDED ARABIC-INDIC DIGIT THREE */
#define XK_Farsi_4                    0x10006f4  /* U+06F4 EXTENDED ARABIC-INDIC DIGIT FOUR */
#define XK_Farsi_5                    0x10006f5  /* U+06F5 EXTENDED ARABIC-INDIC DIGIT FIVE */
#define XK_Farsi_6                    0x10006f6  /* U+06F6 EXTENDED ARABIC-INDIC DIGIT SIX */
#define XK_Farsi_7                    0x10006f7  /* U+06F7 EXTENDED ARABIC-INDIC DIGIT SEVEN */
#define XK_Farsi_8                    0x10006f8  /* U+06F8 EXTENDED ARABIC-INDIC DIGIT EIGHT */
#define XK_Farsi_9                    0x10006f9  /* U+06F9 EXTENDED ARABIC-INDIC DIGIT NINE */
#define XK_Arabic_percent             0x100066a  /* U+066A ARABIC PERCENT SIGN */
#define XK_Arabic_superscript_alef    0x1000670  /* U+0670 ARABIC LETTER SUPERSCRIPT ALEF */
#define XK_Arabic_tteh                0x1000679  /* U+0679 ARABIC LETTER TTEH */
#define XK_Arabic_peh                 0x100067e  /* U+067E ARABIC LETTER PEH */
#define XK_Arabic_tcheh               0x1000686  /* U+0686 ARABIC LETTER TCHEH */
#define XK_Arabic_ddal                0x1000688  /* U+0688 ARABIC LETTER DDAL */
#define XK_Arabic_rreh                0x1000691  /* U+0691 ARABIC LETTER RREH */
#define XK_Arabic_comma                  0x05ac  /* U+060C ARABIC COMMA */
#define XK_Arabic_fullstop            0x10006d4  /* U+06D4 ARABIC FULL STOP */
#define XK_Arabic_0                   0x1000660  /* U+0660 ARABIC-INDIC DIGIT ZERO */
#define XK_Arabic_1                   0x1000661  /* U+0661 ARABIC-INDIC DIGIT ONE */
#define XK_Arabic_2                   0x1000662  /* U+0662 ARABIC-INDIC DIGIT TWO */
#define XK_Arabic_3                   0x1000663  /* U+0663 ARABIC-INDIC DIGIT THREE */
#define XK_Arabic_4                   0x1000664  /* U+0664 ARABIC-INDIC DIGIT FOUR */
#define XK_Arabic_5                   0x1000665  /* U+0665 ARABIC-INDIC DIGIT FIVE */
#define XK_Arabic_6                   0x1000666  /* U+0666 ARABIC-INDIC DIGIT SIX */
#define XK_Arabic_7                   0x1000667  /* U+0667 ARABIC-INDIC DIGIT SEVEN */
#define XK_Arabic_8                   0x1000668  /* U+0668 ARABIC-INDIC DIGIT EIGHT */
#define XK_Arabic_9                   0x1000669  /* U+0669 ARABIC-INDIC DIGIT NINE */
#define XK_Arabic_semicolon              0x05bb  /* U+061B ARABIC SEMICOLON */
#define XK_Arabic_question_mark          0x05bf  /* U+061F ARABIC QUESTION MARK */
#define XK_Arabic_hamza                  0x05c1  /* U+0621 ARABIC LETTER HAMZA */
#define XK_Arabic_maddaonalef            0x05c2  /* U+0622 ARABIC LETTER ALEF WITH MADDA ABOVE */
#define XK_Arabic_hamzaonalef            0x05c3  /* U+0623 ARABIC LETTER ALEF WITH HAMZA ABOVE */
#define XK_Arabic_hamzaonwaw             0x05c4  /* U+0624 ARABIC LETTER WAW WITH HAMZA ABOVE */
#define XK_Arabic_hamzaunderalef         0x05c5  /* U+0625 ARABIC LETTER ALEF WITH HAMZA BELOW */
#define XK_Arabic_hamzaonyeh             0x05c6  /* U+0626 ARABIC LETTER YEH WITH HAMZA ABOVE */
#define XK_Arabic_alef                   0x05c7  /* U+0627 ARABIC LETTER ALEF */
#define XK_Arabic_beh                    0x05c8  /* U+0628 ARABIC LETTER BEH */
#define XK_Arabic_tehmarbuta             0x05c9  /* U+0629 ARABIC LETTER TEH MARBUTA */
#define XK_Arabic_teh                    0x05ca  /* U+062A ARABIC LETTER TEH */
#define XK_Arabic_theh                   0x05cb  /* U+062B ARABIC LETTER THEH */
#define XK_Arabic_jeem                   0x05cc  /* U+062C ARABIC LETTER JEEM */
#define XK_Arabic_hah                    0x05cd  /* U+062D ARABIC LETTER HAH */
#define XK_Arabic_khah                   0x05ce  /* U+062E ARABIC LETTER KHAH */
#define XK_Arabic_dal                    0x05cf  /* U+062F ARABIC LETTER DAL */
#define XK_Arabic_thal                   0x05d0  /* U+0630 ARABIC LETTER THAL */
#define XK_Arabic_ra                     0x05d1  /* U+0631 ARABIC LETTER REH */
#define XK_Arabic_zain                   0x05d2  /* U+0632 ARABIC LETTER ZAIN */
#define XK_Arabic_seen                   0x05d3  /* U+0633 ARABIC LETTER SEEN */
#define XK_Arabic_sheen                  0x05d4  /* U+0634 ARABIC LETTER SHEEN */
#define XK_Arabic_sad                    0x05d5  /* U+0635 ARABIC LETTER SAD */
#define XK_Arabic_dad                    0x05d6  /* U+0636 ARABIC LETTER DAD */
#define XK_Arabic_tah                    0x05d7  /* U+0637 ARABIC LETTER TAH */
#define XK_Arabic_zah                    0x05d8  /* U+0638 ARABIC LETTER ZAH */
#define XK_Arabic_ain                    0x05d9  /* U+0639 ARABIC LETTER AIN */
#define XK_Arabic_ghain                  0x05da  /* U+063A ARABIC LETTER GHAIN */
#define XK_Arabic_tatweel                0x05e0  /* U+0640 ARABIC TATWEEL */
#define XK_Arabic_feh                    0x05e1  /* U+0641 ARABIC LETTER FEH */
#define XK_Arabic_qaf                    0x05e2  /* U+0642 ARABIC LETTER QAF */
#define XK_Arabic_kaf                    0x05e3  /* U+0643 ARABIC LETTER KAF */
#define XK_Arabic_lam                    0x05e4  /* U+0644 ARABIC LETTER LAM */
#define XK_Arabic_meem                   0x05e5  /* U+0645 ARABIC LETTER MEEM */
#define XK_Arabic_noon                   0x05e6  /* U+0646 ARABIC LETTER NOON */
#define XK_Arabic_ha                     0x05e7  /* U+0647 ARABIC LETTER HEH */
#define XK_Arabic_heh                    0x05e7  /* deprecated */
#define XK_Arabic_waw                    0x05e8  /* U+0648 ARABIC LETTER WAW */
#define XK_Arabic_alefmaksura            0x05e9  /* U+0649 ARABIC LETTER ALEF MAKSURA */
#define XK_Arabic_yeh                    0x05ea  /* U+064A ARABIC LETTER YEH */
#define XK_Arabic_fathatan               0x05eb  /* U+064B ARABIC FATHATAN */
#define XK_Arabic_dammatan               0x05ec  /* U+064C ARABIC DAMMATAN */
#define XK_Arabic_kasratan               0x05ed  /* U+064D ARABIC KASRATAN */
#define XK_Arabic_fatha                  0x05ee  /* U+064E ARABIC FATHA */
#define XK_Arabic_damma                  0x05ef  /* U+064F ARABIC DAMMA */
#define XK_Arabic_kasra                  0x05f0  /* U+0650 ARABIC KASRA */
#define XK_Arabic_shadda                 0x05f1  /* U+0651 ARABIC SHADDA */
#define XK_Arabic_sukun                  0x05f2  /* U+0652 ARABIC SUKUN */
#define XK_Arabic_madda_above         0x1000653  /* U+0653 ARABIC MADDAH ABOVE */
#define XK_Arabic_hamza_above         0x1000654  /* U+0654 ARABIC HAMZA ABOVE */
#define XK_Arabic_hamza_below         0x1000655  /* U+0655 ARABIC HAMZA BELOW */
#define XK_Arabic_jeh                 0x1000698  /* U+0698 ARABIC LETTER JEH */
#define XK_Arabic_veh                 0x10006a4  /* U+06A4 ARABIC LETTER VEH */
#define XK_Arabic_keheh               0x10006a9  /* U+06A9 ARABIC LETTER KEHEH */
#define XK_Arabic_gaf                 0x10006af  /* U+06AF ARABIC LETTER GAF */
#define XK_Arabic_noon_ghunna         0x10006ba  /* U+06BA ARABIC LETTER NOON GHUNNA */
#define XK_Arabic_heh_doachashmee     0x10006be  /* U+06BE ARABIC LETTER HEH DOACHASHMEE */
#define XK_Farsi_yeh                  0x10006cc  /* U+06CC ARABIC LETTER FARSI YEH */
#define XK_Arabic_farsi_yeh           0x10006cc  /* U+06CC ARABIC LETTER FARSI YEH */
#define XK_Arabic_yeh_baree           0x10006d2  /* U+06D2 ARABIC LETTER YEH BARREE */
#define XK_Arabic_heh_goal            0x10006c1  /* U+06C1 ARABIC LETTER HEH GOAL */
#define XK_Arabic_switch                 0xff7e  /* Alias for mode_switch */
/* XK_ARABIC */

/*
 * Cyrillic
 * Byte 3 = 6
 */

#define XK_Cyrillic_GHE_bar           0x1000492  /* U+0492 CYRILLIC CAPITAL LETTER GHE WITH STROKE */
#define XK_Cyrillic_ghe_bar           0x1000493  /* U+0493 CYRILLIC SMALL LETTER GHE WITH STROKE */
#define XK_Cyrillic_ZHE_descender     0x1000496  /* U+0496 CYRILLIC CAPITAL LETTER ZHE WITH DESCENDER */
#define XK_Cyrillic_zhe_descender     0x1000497  /* U+0497 CYRILLIC SMALL LETTER ZHE WITH DESCENDER */
#define XK_Cyrillic_KA_descender      0x100049a  /* U+049A CYRILLIC CAPITAL LETTER KA WITH DESCENDER */
#define XK_Cyrillic_ka_descender      0x100049b  /* U+049B CYRILLIC SMALL LETTER KA WITH DESCENDER */
#define XK_Cyrillic_KA_vertstroke     0x100049c  /* U+049C CYRILLIC CAPITAL LETTER KA WITH VERTICAL STROKE */
#define XK_Cyrillic_ka_vertstroke     0x100049d  /* U+049D CYRILLIC SMALL LETTER KA WITH VERTICAL STROKE */
#define XK_Cyrillic_EN_descender      0x10004a2  /* U+04A2 CYRILLIC CAPITAL LETTER EN WITH DESCENDER */
#define XK_Cyrillic_en_descender      0x10004a3  /* U+04A3 CYRILLIC SMALL LETTER EN WITH DESCENDER */
#define XK_Cyrillic_U_straight        0x10004ae  /* U+04AE CYRILLIC CAPITAL LETTER STRAIGHT U */
#define XK_Cyrillic_u_straight        0x10004af  /* U+04AF CYRILLIC SMALL LETTER STRAIGHT U */
#define XK_Cyrillic_U_straight_bar    0x10004b0  /* U+04B0 CYRILLIC CAPITAL LETTER STRAIGHT U WITH STROKE */
#define XK_Cyrillic_u_straight_bar    0x10004b1  /* U+04B1 CYRILLIC SMALL LETTER STRAIGHT U WITH STROKE */
#define XK_Cyrillic_HA_descender      0x10004b2  /* U+04B2 CYRILLIC CAPITAL LETTER HA WITH DESCENDER */
#define XK_Cyrillic_ha_descender      0x10004b3  /* U+04B3 CYRILLIC SMALL LETTER HA WITH DESCENDER */
#define XK_Cyrillic_CHE_descender     0x10004b6  /* U+04B6 CYRILLIC CAPITAL LETTER CHE WITH DESCENDER */
#define XK_Cyrillic_che_descender     0x10004b7  /* U+04B7 CYRILLIC SMALL LETTER CHE WITH DESCENDER */
#define XK_Cyrillic_CHE_vertstroke    0x10004b8  /* U+04B8 CYRILLIC CAPITAL LETTER CHE WITH VERTICAL STROKE */
#define XK_Cyrillic_che_vertstroke    0x10004b9  /* U+04B9 CYRILLIC SMALL LETTER CHE WITH VERTICAL STROKE */
#define XK_Cyrillic_SHHA              0x10004ba  /* U+04BA CYRILLIC CAPITAL LETTER SHHA */
#define XK_Cyrillic_shha              0x10004bb  /* U+04BB CYRILLIC SMALL LETTER SHHA */

#define XK_Cyrillic_SCHWA             0x10004d8  /* U+04D8 CYRILLIC CAPITAL LETTER SCHWA */
#define XK_Cyrillic_schwa             0x10004d9  /* U+04D9 CYRILLIC SMALL LETTER SCHWA */
#define XK_Cyrillic_I_macron          0x10004e2  /* U+04E2 CYRILLIC CAPITAL LETTER I WITH MACRON */
#define XK_Cyrillic_i_macron          0x10004e3  /* U+04E3 CYRILLIC SMALL LETTER I WITH MACRON */
#define XK_Cyrillic_O_bar             0x10004e8  /* U+04E8 CYRILLIC CAPITAL LETTER BARRED O */
#define XK_Cyrillic_o_bar             0x10004e9  /* U+04E9 CYRILLIC SMALL LETTER BARRED O */
#define XK_Cyrillic_U_macron          0x10004ee  /* U+04EE CYRILLIC CAPITAL LETTER U WITH MACRON */
#define XK_Cyrillic_u_macron          0x10004ef  /* U+04EF CYRILLIC SMALL LETTER U WITH MACRON */

#define XK_Serbian_dje                   0x06a1  /* U+0452 CYRILLIC SMALL LETTER DJE */
#define XK_Macedonia_gje                 0x06a2  /* U+0453 CYRILLIC SMALL LETTER GJE */
#define XK_Cyrillic_io                   0x06a3  /* U+0451 CYRILLIC SMALL LETTER IO */
#define XK_Ukrainian_ie                  0x06a4  /* U+0454 CYRILLIC SMALL LETTER UKRAINIAN IE */
#define XK_Ukranian_je                   0x06a4  /* deprecated */
#define XK_Macedonia_dse                 0x06a5  /* U+0455 CYRILLIC SMALL LETTER DZE */
#define XK_Ukrainian_i                   0x06a6  /* U+0456 CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I */
#define XK_Ukranian_i                    0x06a6  /* deprecated */
#define XK_Ukrainian_yi                  0x06a7  /* U+0457 CYRILLIC SMALL LETTER YI */
#define XK_Ukranian_yi                   0x06a7  /* deprecated */
#define XK_Cyrillic_je                   0x06a8  /* U+0458 CYRILLIC SMALL LETTER JE */
#define XK_Serbian_je                    0x06a8  /* deprecated */
#define XK_Cyrillic_lje                  0x06a9  /* U+0459 CYRILLIC SMALL LETTER LJE */
#define XK_Serbian_lje                   0x06a9  /* deprecated */
#define XK_Cyrillic_nje                  0x06aa  /* U+045A CYRILLIC SMALL LETTER NJE */
#define XK_Serbian_nje                   0x06aa  /* deprecated */
#define XK_Serbian_tshe                  0x06ab  /* U+045B CYRILLIC SMALL LETTER TSHE */
#define XK_Macedonia_kje                 0x06ac  /* U+045C CYRILLIC SMALL LETTER KJE */
#define XK_Ukrainian_ghe_with_upturn     0x06ad  /* U+0491 CYRILLIC SMALL LETTER GHE WITH UPTURN */
#define XK_Byelorussian_shortu           0x06ae  /* U+045E CYRILLIC SMALL LETTER SHORT U */
#define XK_Cyrillic_dzhe                 0x06af  /* U+045F CYRILLIC SMALL LETTER DZHE */
#define XK_Serbian_dze                   0x06af  /* deprecated */
#define XK_numerosign                    0x06b0  /* U+2116 NUMERO SIGN */
#define XK_Serbian_DJE                   0x06b1  /* U+0402 CYRILLIC CAPITAL LETTER DJE */
#define XK_Macedonia_GJE                 0x06b2  /* U+0403 CYRILLIC CAPITAL LETTER GJE */
#define XK_Cyrillic_IO                   0x06b3  /* U+0401 CYRILLIC CAPITAL LETTER IO */
#define XK_Ukrainian_IE                  0x06b4  /* U+0404 CYRILLIC CAPITAL LETTER UKRAINIAN IE */
#define XK_Ukranian_JE                   0x06b4  /* deprecated */
#define XK_Macedonia_DSE                 0x06b5  /* U+0405 CYRILLIC CAPITAL LETTER DZE */
#define XK_Ukrainian_I                   0x06b6  /* U+0406 CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I */
#define XK_Ukranian_I                    0x06b6  /* deprecated */
#define XK_Ukrainian_YI                  0x06b7  /* U+0407 CYRILLIC CAPITAL LETTER YI */
#define XK_Ukranian_YI                   0x06b7  /* deprecated */
#define XK_Cyrillic_JE                   0x06b8  /* U+0408 CYRILLIC CAPITAL LETTER JE */
#define XK_Serbian_JE                    0x06b8  /* deprecated */
#define XK_Cyrillic_LJE                  0x06b9  /* U+0409 CYRILLIC CAPITAL LETTER LJE */
#define XK_Serbian_LJE                   0x06b9  /* deprecated */
#define XK_Cyrillic_NJE                  0x06ba  /* U+040A CYRILLIC CAPITAL LETTER NJE */
#define XK_Serbian_NJE                   0x06ba  /* deprecated */
#define XK_Serbian_TSHE                  0x06bb  /* U+040B CYRILLIC CAPITAL LETTER TSHE */
#define XK_Macedonia_KJE                 0x06bc  /* U+040C CYRILLIC CAPITAL LETTER KJE */
#define XK_Ukrainian_GHE_WITH_UPTURN     0x06bd  /* U+0490 CYRILLIC CAPITAL LETTER GHE WITH UPTURN */
#define XK_Byelorussian_SHORTU           0x06be  /* U+040E CYRILLIC CAPITAL LETTER SHORT U */
#define XK_Cyrillic_DZHE                 0x06bf  /* U+040F CYRILLIC CAPITAL LETTER DZHE */
#define XK_Serbian_DZE                   0x06bf  /* deprecated */
#define XK_Cyrillic_yu                   0x06c0  /* U+044E CYRILLIC SMALL LETTER YU */
#define XK_Cyrillic_a                    0x06c1  /* U+0430 CYRILLIC SMALL LETTER A */
#define XK_Cyrillic_be                   0x06c2  /* U+0431 CYRILLIC SMALL LETTER BE */
#define XK_Cyrillic_tse                  0x06c3  /* U+0446 CYRILLIC SMALL LETTER TSE */
#define XK_Cyrillic_de                   0x06c4  /* U+0434 CYRILLIC SMALL LETTER DE */
#define XK_Cyrillic_ie                   0x06c5  /* U+0435 CYRILLIC SMALL LETTER IE */
#define XK_Cyrillic_ef                   0x06c6  /* U+0444 CYRILLIC SMALL LETTER EF */
#define XK_Cyrillic_ghe                  0x06c7  /* U+0433 CYRILLIC SMALL LETTER GHE */
#define XK_Cyrillic_ha                   0x06c8  /* U+0445 CYRILLIC SMALL LETTER HA */
#define XK_Cyrillic_i                    0x06c9  /* U+0438 CYRILLIC SMALL LETTER I */
#define XK_Cyrillic_shorti               0x06ca  /* U+0439 CYRILLIC SMALL LETTER SHORT I */
#define XK_Cyrillic_ka                   0x06cb  /* U+043A CYRILLIC SMALL LETTER KA */
#define XK_Cyrillic_el                   0x06cc  /* U+043B CYRILLIC SMALL LETTER EL */
#define XK_Cyrillic_em                   0x06cd  /* U+043C CYRILLIC SMALL LETTER EM */
#define XK_Cyrillic_en                   0x06ce  /* U+043D CYRILLIC SMALL LETTER EN */
#define XK_Cyrillic_o                    0x06cf  /* U+043E CYRILLIC SMALL LETTER O */
#define XK_Cyrillic_pe                   0x06d0  /* U+043F CYRILLIC SMALL LETTER PE */
#define XK_Cyrillic_ya                   0x06d1  /* U+044F CYRILLIC SMALL LETTER YA */
#define XK_Cyrillic_er                   0x06d2  /* U+0440 CYRILLIC SMALL LETTER ER */
#define XK_Cyrillic_es                   0x06d3  /* U+0441 CYRILLIC SMALL LETTER ES */
#define XK_Cyrillic_te                   0x06d4  /* U+0442 CYRILLIC SMALL LETTER TE */
#define XK_Cyrillic_u                    0x06d5  /* U+0443 CYRILLIC SMALL LETTER U */
#define XK_Cyrillic_zhe                  0x06d6  /* U+0436 CYRILLIC SMALL LETTER ZHE */
#define XK_Cyrillic_ve                   0x06d7  /* U+0432 CYRILLIC SMALL LETTER VE */
#define XK_Cyrillic_softsign             0x06d8  /* U+044C CYRILLIC SMALL LETTER SOFT SIGN */
#define XK_Cyrillic_yeru                 0x06d9  /* U+044B CYRILLIC SMALL LETTER YERU */
#define XK_Cyrillic_ze                   0x06da  /* U+0437 CYRILLIC SMALL LETTER ZE */
#define XK_Cyrillic_sha                  0x06db  /* U+0448 CYRILLIC SMALL LETTER SHA */
#define XK_Cyrillic_e                    0x06dc  /* U+044D CYRILLIC SMALL LETTER E */
#define XK_Cyrillic_shcha                0x06dd  /* U+0449 CYRILLIC SMALL LETTER SHCHA */
#define XK_Cyrillic_che                  0x06de  /* U+0447 CYRILLIC SMALL LETTER CHE */
#define XK_Cyrillic_hardsign             0x06df  /* U+044A CYRILLIC SMALL LETTER HARD SIGN */
#define XK_Cyrillic_YU                   0x06e0  /* U+042E CYRILLIC CAPITAL LETTER YU */
#define XK_Cyrillic_A                    0x06e1  /* U+0410 CYRILLIC CAPITAL LETTER A */
#define XK_Cyrillic_BE                   0x06e2  /* U+0411 CYRILLIC CAPITAL LETTER BE */
#define XK_Cyrillic_TSE                  0x06e3  /* U+0426 CYRILLIC CAPITAL LETTER TSE */
#define XK_Cyrillic_DE                   0x06e4  /* U+0414 CYRILLIC CAPITAL LETTER DE */
#define XK_Cyrillic_IE                   0x06e5  /* U+0415 CYRILLIC CAPITAL LETTER IE */
#define XK_Cyrillic_EF                   0x06e6  /* U+0424 CYRILLIC CAPITAL LETTER EF */
#define XK_Cyrillic_GHE                  0x06e7  /* U+0413 CYRILLIC CAPITAL LETTER GHE */
#define XK_Cyrillic_HA                   0x06e8  /* U+0425 CYRILLIC CAPITAL LETTER HA */
#define XK_Cyrillic_I                    0x06e9  /* U+0418 CYRILLIC CAPITAL LETTER I */
#define XK_Cyrillic_SHORTI               0x06ea  /* U+0419 CYRILLIC CAPITAL LETTER SHORT I */
#define XK_Cyrillic_KA                   0x06eb  /* U+041A CYRILLIC CAPITAL LETTER KA */
#define XK_Cyrillic_EL                   0x06ec  /* U+041B CYRILLIC CAPITAL LETTER EL */
#define XK_Cyrillic_EM                   0x06ed  /* U+041C CYRILLIC CAPITAL LETTER EM */
#define XK_Cyrillic_EN                   0x06ee  /* U+041D CYRILLIC CAPITAL LETTER EN */
#define XK_Cyrillic_O                    0x06ef  /* U+041E CYRILLIC CAPITAL LETTER O */
#define XK_Cyrillic_PE                   0x06f0  /* U+041F CYRILLIC CAPITAL LETTER PE */
#define XK_Cyrillic_YA                   0x06f1  /* U+042F CYRILLIC CAPITAL LETTER YA */
#define XK_Cyrillic_ER                   0x06f2  /* U+0420 CYRILLIC CAPITAL LETTER ER */
#define XK_Cyrillic_ES                   0x06f3  /* U+0421 CYRILLIC CAPITAL LETTER ES */
#define XK_Cyrillic_TE                   0x06f4  /* U+0422 CYRILLIC CAPITAL LETTER TE */
#define XK_Cyrillic_U                    0x06f5  /* U+0423 CYRILLIC CAPITAL LETTER U */
#define XK_Cyrillic_ZHE                  0x06f6  /* U+0416 CYRILLIC CAPITAL LETTER ZHE */
#define XK_Cyrillic_VE                   0x06f7  /* U+0412 CYRILLIC CAPITAL LETTER VE */
#define XK_Cyrillic_SOFTSIGN             0x06f8  /* U+042C CYRILLIC CAPITAL LETTER SOFT SIGN */
#define XK_Cyrillic_YERU                 0x06f9  /* U+042B CYRILLIC CAPITAL LETTER YERU */
#define XK_Cyrillic_ZE                   0x06fa  /* U+0417 CYRILLIC CAPITAL LETTER ZE */
#define XK_Cyrillic_SHA                  0x06fb  /* U+0428 CYRILLIC CAPITAL LETTER SHA */
#define XK_Cyrillic_E                    0x06fc  /* U+042D CYRILLIC CAPITAL LETTER E */
#define XK_Cyrillic_SHCHA                0x06fd  /* U+0429 CYRILLIC CAPITAL LETTER SHCHA */
#define XK_Cyrillic_CHE                  0x06fe  /* U+0427 CYRILLIC CAPITAL LETTER CHE */
#define XK_Cyrillic_HARDSIGN             0x06ff  /* U+042A CYRILLIC CAPITAL LETTER HARD SIGN */
/* XK_CYRILLIC */

/*
 * Greek
 * (based on an early draft of, and not quite identical to, ISO/IEC 8859-7)
 * Byte 3 = 7
 */


#define XK_Greek_ALPHAaccent             0x07a1  /* U+0386 GREEK CAPITAL LETTER ALPHA WITH TONOS */
#define XK_Greek_EPSILONaccent           0x07a2  /* U+0388 GREEK CAPITAL LETTER EPSILON WITH TONOS */
#define XK_Greek_ETAaccent               0x07a3  /* U+0389 GREEK CAPITAL LETTER ETA WITH TONOS */
#define XK_Greek_IOTAaccent              0x07a4  /* U+038A GREEK CAPITAL LETTER IOTA WITH TONOS */
#define XK_Greek_IOTAdieresis            0x07a5  /* U+03AA GREEK CAPITAL LETTER IOTA WITH DIALYTIKA */
#define XK_Greek_IOTAdiaeresis           0x07a5  /* old typo */
#define XK_Greek_OMICRONaccent           0x07a7  /* U+038C GREEK CAPITAL LETTER OMICRON WITH TONOS */
#define XK_Greek_UPSILONaccent           0x07a8  /* U+038E GREEK CAPITAL LETTER UPSILON WITH TONOS */
#define XK_Greek_UPSILONdieresis         0x07a9  /* U+03AB GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA */
#define XK_Greek_OMEGAaccent             0x07ab  /* U+038F GREEK CAPITAL LETTER OMEGA WITH TONOS */
#define XK_Greek_accentdieresis          0x07ae  /* U+0385 GREEK DIALYTIKA TONOS */
#define XK_Greek_horizbar                0x07af  /* U+2015 HORIZONTAL BAR */
#define XK_Greek_alphaaccent             0x07b1  /* U+03AC GREEK SMALL LETTER ALPHA WITH TONOS */
#define XK_Greek_epsilonaccent           0x07b2  /* U+03AD GREEK SMALL LETTER EPSILON WITH TONOS */
#define XK_Greek_etaaccent               0x07b3  /* U+03AE GREEK SMALL LETTER ETA WITH TONOS */
#define XK_Greek_iotaaccent              0x07b4  /* U+03AF GREEK SMALL LETTER IOTA WITH TONOS */
#define XK_Greek_iotadieresis            0x07b5  /* U+03CA GREEK SMALL LETTER IOTA WITH DIALYTIKA */
#define XK_Greek_iotaaccentdieresis      0x07b6  /* U+0390 GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */
#define XK_Greek_omicronaccent           0x07b7  /* U+03CC GREEK SMALL LETTER OMICRON WITH TONOS */
#define XK_Greek_upsilonaccent           0x07b8  /* U+03CD GREEK SMALL LETTER UPSILON WITH TONOS */
#define XK_Greek_upsilondieresis         0x07b9  /* U+03CB GREEK SMALL LETTER UPSILON WITH DIALYTIKA */
#define XK_Greek_upsilonaccentdieresis   0x07ba  /* U+03B0 GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS */
#define XK_Greek_omegaaccent             0x07bb  /* U+03CE GREEK SMALL LETTER OMEGA WITH TONOS */
#define XK_Greek_ALPHA                   0x07c1  /* U+0391 GREEK CAPITAL LETTER ALPHA */
#define XK_Greek_BETA                    0x07c2  /* U+0392 GREEK CAPITAL LETTER BETA */
#define XK_Greek_GAMMA                   0x07c3  /* U+0393 GREEK CAPITAL LETTER GAMMA */
#define XK_Greek_DELTA                   0x07c4  /* U+0394 GREEK CAPITAL LETTER DELTA */
#define XK_Greek_EPSILON                 0x07c5  /* U+0395 GREEK CAPITAL LETTER EPSILON */
#define XK_Greek_ZETA                    0x07c6  /* U+0396 GREEK CAPITAL LETTER ZETA */
#define XK_Greek_ETA                     0x07c7  /* U+0397 GREEK CAPITAL LETTER ETA */
#define XK_Greek_THETA                   0x07c8  /* U+0398 GREEK CAPITAL LETTER THETA */
#define XK_Greek_IOTA                    0x07c9  /* U+0399 GREEK CAPITAL LETTER IOTA */
#define XK_Greek_KAPPA                   0x07ca  /* U+039A GREEK CAPITAL LETTER KAPPA */
#define XK_Greek_LAMDA                   0x07cb  /* U+039B GREEK CAPITAL LETTER LAMDA */
#define XK_Greek_LAMBDA                  0x07cb  /* U+039B GREEK CAPITAL LETTER LAMDA */
#define XK_Greek_MU                      0x07cc  /* U+039C GREEK CAPITAL LETTER MU */
#define XK_Greek_NU                      0x07cd  /* U+039D GREEK CAPITAL LETTER NU */
#define XK_Greek_XI                      0x07ce  /* U+039E GREEK CAPITAL LETTER XI */
#define XK_Greek_OMICRON                 0x07cf  /* U+039F GREEK CAPITAL LETTER OMICRON */
#define XK_Greek_PI                      0x07d0  /* U+03A0 GREEK CAPITAL LETTER PI */
#define XK_Greek_RHO                     0x07d1  /* U+03A1 GREEK CAPITAL LETTER RHO */
#define XK_Greek_SIGMA                   0x07d2  /* U+03A3 GREEK CAPITAL LETTER SIGMA */
#define XK_Greek_TAU                     0x07d4  /* U+03A4 GREEK CAPITAL LETTER TAU */
#define XK_Greek_UPSILON                 0x07d5  /* U+03A5 GREEK CAPITAL LETTER UPSILON */
#define XK_Greek_PHI                     0x07d6  /* U+03A6 GREEK CAPITAL LETTER PHI */
#define XK_Greek_CHI                     0x07d7  /* U+03A7 GREEK CAPITAL LETTER CHI */
#define XK_Greek_PSI                     0x07d8  /* U+03A8 GREEK CAPITAL LETTER PSI */
#define XK_Greek_OMEGA                   0x07d9  /* U+03A9 GREEK CAPITAL LETTER OMEGA */
#define XK_Greek_alpha                   0x07e1  /* U+03B1 GREEK SMALL LETTER ALPHA */
#define XK_Greek_beta                    0x07e2  /* U+03B2 GREEK SMALL LETTER BETA */
#define XK_Greek_gamma                   0x07e3  /* U+03B3 GREEK SMALL LETTER GAMMA */
#define XK_Greek_delta                   0x07e4  /* U+03B4 GREEK SMALL LETTER DELTA */
#define XK_Greek_epsilon                 0x07e5  /* U+03B5 GREEK SMALL LETTER EPSILON */
#define XK_Greek_zeta                    0x07e6  /* U+03B6 GREEK SMALL LETTER ZETA */
#define XK_Greek_eta                     0x07e7  /* U+03B7 GREEK SMALL LETTER ETA */
#define XK_Greek_theta                   0x07e8  /* U+03B8 GREEK SMALL LETTER THETA */
#define XK_Greek_iota                    0x07e9  /* U+03B9 GREEK SMALL LETTER IOTA */
#define XK_Greek_kappa                   0x07ea  /* U+03BA GREEK SMALL LETTER KAPPA */
#define XK_Greek_lamda                   0x07eb  /* U+03BB GREEK SMALL LETTER LAMDA */
#define XK_Greek_lambda                  0x07eb  /* U+03BB GREEK SMALL LETTER LAMDA */
#define XK_Greek_mu                      0x07ec  /* U+03BC GREEK SMALL LETTER MU */
#define XK_Greek_nu                      0x07ed  /* U+03BD GREEK SMALL LETTER NU */
#define XK_Greek_xi                      0x07ee  /* U+03BE GREEK SMALL LETTER XI */
#define XK_Greek_omicron                 0x07ef  /* U+03BF GREEK SMALL LETTER OMICRON */
#define XK_Greek_pi                      0x07f0  /* U+03C0 GREEK SMALL LETTER PI */
#define XK_Greek_rho                     0x07f1  /* U+03C1 GREEK SMALL LETTER RHO */
#define XK_Greek_sigma                   0x07f2  /* U+03C3 GREEK SMALL LETTER SIGMA */
#define XK_Greek_finalsmallsigma         0x07f3  /* U+03C2 GREEK SMALL LETTER FINAL SIGMA */
#define XK_Greek_tau                     0x07f4  /* U+03C4 GREEK SMALL LETTER TAU */
#define XK_Greek_upsilon                 0x07f5  /* U+03C5 GREEK SMALL LETTER UPSILON */
#define XK_Greek_phi                     0x07f6  /* U+03C6 GREEK SMALL LETTER PHI */
#define XK_Greek_chi                     0x07f7  /* U+03C7 GREEK SMALL LETTER CHI */
#define XK_Greek_psi                     0x07f8  /* U+03C8 GREEK SMALL LETTER PSI */
#define XK_Greek_omega                   0x07f9  /* U+03C9 GREEK SMALL LETTER OMEGA */
#define XK_Greek_switch                  0xff7e  /* Alias for mode_switch */
/* XK_GREEK */

/*
 * Technical
 * (from the DEC VT330/VT420 Technical Character Set, http://vt100.net/charsets/technical.html)
 * Byte 3 = 8
 */

/* XK_TECHNICAL */
# 1375 "/usr/include/X11/keysymdef.h" 3


/*
 * Special
 * (from the DEC VT100 Special Graphics Character Set)
 * Byte 3 = 9
 */

/* XK_SPECIAL */
# 1408 "/usr/include/X11/keysymdef.h" 3


/*
 * Publishing
 * (these are probably from a long forgotten DEC Publishing
 * font that once shipped with DECwrite)
 * Byte 3 = 0x0a
 */

/* XK_PUBLISHING */
# 1501 "/usr/include/X11/keysymdef.h" 3


/*
 * APL
 * Byte 3 = 0x0b
 */

/* XK_APL */
# 1528 "/usr/include/X11/keysymdef.h" 3


/*
 * Hebrew
 * Byte 3 = 0x0c
 */


#define XK_hebrew_doublelowline          0x0cdf  /* U+2017 DOUBLE LOW LINE */
#define XK_hebrew_aleph                  0x0ce0  /* U+05D0 HEBREW LETTER ALEF */
#define XK_hebrew_bet                    0x0ce1  /* U+05D1 HEBREW LETTER BET */
#define XK_hebrew_beth                   0x0ce1  /* deprecated */
#define XK_hebrew_gimel                  0x0ce2  /* U+05D2 HEBREW LETTER GIMEL */
#define XK_hebrew_gimmel                 0x0ce2  /* deprecated */
#define XK_hebrew_dalet                  0x0ce3  /* U+05D3 HEBREW LETTER DALET */
#define XK_hebrew_daleth                 0x0ce3  /* deprecated */
#define XK_hebrew_he                     0x0ce4  /* U+05D4 HEBREW LETTER HE */
#define XK_hebrew_waw                    0x0ce5  /* U+05D5 HEBREW LETTER VAV */
#define XK_hebrew_zain                   0x0ce6  /* U+05D6 HEBREW LETTER ZAYIN */
#define XK_hebrew_zayin                  0x0ce6  /* deprecated */
#define XK_hebrew_chet                   0x0ce7  /* U+05D7 HEBREW LETTER HET */
#define XK_hebrew_het                    0x0ce7  /* deprecated */
#define XK_hebrew_tet                    0x0ce8  /* U+05D8 HEBREW LETTER TET */
#define XK_hebrew_teth                   0x0ce8  /* deprecated */
#define XK_hebrew_yod                    0x0ce9  /* U+05D9 HEBREW LETTER YOD */
#define XK_hebrew_finalkaph              0x0cea  /* U+05DA HEBREW LETTER FINAL KAF */
#define XK_hebrew_kaph                   0x0ceb  /* U+05DB HEBREW LETTER KAF */
#define XK_hebrew_lamed                  0x0cec  /* U+05DC HEBREW LETTER LAMED */
#define XK_hebrew_finalmem               0x0ced  /* U+05DD HEBREW LETTER FINAL MEM */
#define XK_hebrew_mem                    0x0cee  /* U+05DE HEBREW LETTER MEM */
#define XK_hebrew_finalnun               0x0cef  /* U+05DF HEBREW LETTER FINAL NUN */
#define XK_hebrew_nun                    0x0cf0  /* U+05E0 HEBREW LETTER NUN */
#define XK_hebrew_samech                 0x0cf1  /* U+05E1 HEBREW LETTER SAMEKH */
#define XK_hebrew_samekh                 0x0cf1  /* deprecated */
#define XK_hebrew_ayin                   0x0cf2  /* U+05E2 HEBREW LETTER AYIN */
#define XK_hebrew_finalpe                0x0cf3  /* U+05E3 HEBREW LETTER FINAL PE */
#define XK_hebrew_pe                     0x0cf4  /* U+05E4 HEBREW LETTER PE */
#define XK_hebrew_finalzade              0x0cf5  /* U+05E5 HEBREW LETTER FINAL TSADI */
#define XK_hebrew_finalzadi              0x0cf5  /* deprecated */
#define XK_hebrew_zade                   0x0cf6  /* U+05E6 HEBREW LETTER TSADI */
#define XK_hebrew_zadi                   0x0cf6  /* deprecated */
#define XK_hebrew_qoph                   0x0cf7  /* U+05E7 HEBREW LETTER QOF */
#define XK_hebrew_kuf                    0x0cf7  /* deprecated */
#define XK_hebrew_resh                   0x0cf8  /* U+05E8 HEBREW LETTER RESH */
#define XK_hebrew_shin                   0x0cf9  /* U+05E9 HEBREW LETTER SHIN */
#define XK_hebrew_taw                    0x0cfa  /* U+05EA HEBREW LETTER TAV */
#define XK_hebrew_taf                    0x0cfa  /* deprecated */
#define XK_Hebrew_switch                 0xff7e  /* Alias for mode_switch */
/* XK_HEBREW */

/*
 * Thai
 * Byte 3 = 0x0d
 */


#define XK_Thai_kokai                    0x0da1  /* U+0E01 THAI CHARACTER KO KAI */
#define XK_Thai_khokhai                  0x0da2  /* U+0E02 THAI CHARACTER KHO KHAI */
#define XK_Thai_khokhuat                 0x0da3  /* U+0E03 THAI CHARACTER KHO KHUAT */
#define XK_Thai_khokhwai                 0x0da4  /* U+0E04 THAI CHARACTER KHO KHWAI */
#define XK_Thai_khokhon                  0x0da5  /* U+0E05 THAI CHARACTER KHO KHON */
#define XK_Thai_khorakhang               0x0da6  /* U+0E06 THAI CHARACTER KHO RAKHANG */
#define XK_Thai_ngongu                   0x0da7  /* U+0E07 THAI CHARACTER NGO NGU */
#define XK_Thai_chochan                  0x0da8  /* U+0E08 THAI CHARACTER CHO CHAN */
#define XK_Thai_choching                 0x0da9  /* U+0E09 THAI CHARACTER CHO CHING */
#define XK_Thai_chochang                 0x0daa  /* U+0E0A THAI CHARACTER CHO CHANG */
#define XK_Thai_soso                     0x0dab  /* U+0E0B THAI CHARACTER SO SO */
#define XK_Thai_chochoe                  0x0dac  /* U+0E0C THAI CHARACTER CHO CHOE */
#define XK_Thai_yoying                   0x0dad  /* U+0E0D THAI CHARACTER YO YING */
#define XK_Thai_dochada                  0x0dae  /* U+0E0E THAI CHARACTER DO CHADA */
#define XK_Thai_topatak                  0x0daf  /* U+0E0F THAI CHARACTER TO PATAK */
#define XK_Thai_thothan                  0x0db0  /* U+0E10 THAI CHARACTER THO THAN */
#define XK_Thai_thonangmontho            0x0db1  /* U+0E11 THAI CHARACTER THO NANGMONTHO */
#define XK_Thai_thophuthao               0x0db2  /* U+0E12 THAI CHARACTER THO PHUTHAO */
#define XK_Thai_nonen                    0x0db3  /* U+0E13 THAI CHARACTER NO NEN */
#define XK_Thai_dodek                    0x0db4  /* U+0E14 THAI CHARACTER DO DEK */
#define XK_Thai_totao                    0x0db5  /* U+0E15 THAI CHARACTER TO TAO */
#define XK_Thai_thothung                 0x0db6  /* U+0E16 THAI CHARACTER THO THUNG */
#define XK_Thai_thothahan                0x0db7  /* U+0E17 THAI CHARACTER THO THAHAN */
#define XK_Thai_thothong                 0x0db8  /* U+0E18 THAI CHARACTER THO THONG */
#define XK_Thai_nonu                     0x0db9  /* U+0E19 THAI CHARACTER NO NU */
#define XK_Thai_bobaimai                 0x0dba  /* U+0E1A THAI CHARACTER BO BAIMAI */
#define XK_Thai_popla                    0x0dbb  /* U+0E1B THAI CHARACTER PO PLA */
#define XK_Thai_phophung                 0x0dbc  /* U+0E1C THAI CHARACTER PHO PHUNG */
#define XK_Thai_fofa                     0x0dbd  /* U+0E1D THAI CHARACTER FO FA */
#define XK_Thai_phophan                  0x0dbe  /* U+0E1E THAI CHARACTER PHO PHAN */
#define XK_Thai_fofan                    0x0dbf  /* U+0E1F THAI CHARACTER FO FAN */
#define XK_Thai_phosamphao               0x0dc0  /* U+0E20 THAI CHARACTER PHO SAMPHAO */
#define XK_Thai_moma                     0x0dc1  /* U+0E21 THAI CHARACTER MO MA */
#define XK_Thai_yoyak                    0x0dc2  /* U+0E22 THAI CHARACTER YO YAK */
#define XK_Thai_rorua                    0x0dc3  /* U+0E23 THAI CHARACTER RO RUA */
#define XK_Thai_ru                       0x0dc4  /* U+0E24 THAI CHARACTER RU */
#define XK_Thai_loling                   0x0dc5  /* U+0E25 THAI CHARACTER LO LING */
#define XK_Thai_lu                       0x0dc6  /* U+0E26 THAI CHARACTER LU */
#define XK_Thai_wowaen                   0x0dc7  /* U+0E27 THAI CHARACTER WO WAEN */
#define XK_Thai_sosala                   0x0dc8  /* U+0E28 THAI CHARACTER SO SALA */
#define XK_Thai_sorusi                   0x0dc9  /* U+0E29 THAI CHARACTER SO RUSI */
#define XK_Thai_sosua                    0x0dca  /* U+0E2A THAI CHARACTER SO SUA */
#define XK_Thai_hohip                    0x0dcb  /* U+0E2B THAI CHARACTER HO HIP */
#define XK_Thai_lochula                  0x0dcc  /* U+0E2C THAI CHARACTER LO CHULA */
#define XK_Thai_oang                     0x0dcd  /* U+0E2D THAI CHARACTER O ANG */
#define XK_Thai_honokhuk                 0x0dce  /* U+0E2E THAI CHARACTER HO NOKHUK */
#define XK_Thai_paiyannoi                0x0dcf  /* U+0E2F THAI CHARACTER PAIYANNOI */
#define XK_Thai_saraa                    0x0dd0  /* U+0E30 THAI CHARACTER SARA A */
#define XK_Thai_maihanakat               0x0dd1  /* U+0E31 THAI CHARACTER MAI HAN-AKAT */
#define XK_Thai_saraaa                   0x0dd2  /* U+0E32 THAI CHARACTER SARA AA */
#define XK_Thai_saraam                   0x0dd3  /* U+0E33 THAI CHARACTER SARA AM */
#define XK_Thai_sarai                    0x0dd4  /* U+0E34 THAI CHARACTER SARA I */
#define XK_Thai_saraii                   0x0dd5  /* U+0E35 THAI CHARACTER SARA II */
#define XK_Thai_saraue                   0x0dd6  /* U+0E36 THAI CHARACTER SARA UE */
#define XK_Thai_sarauee                  0x0dd7  /* U+0E37 THAI CHARACTER SARA UEE */
#define XK_Thai_sarau                    0x0dd8  /* U+0E38 THAI CHARACTER SARA U */
#define XK_Thai_sarauu                   0x0dd9  /* U+0E39 THAI CHARACTER SARA UU */
#define XK_Thai_phinthu                  0x0dda  /* U+0E3A THAI CHARACTER PHINTHU */
#define XK_Thai_maihanakat_maitho        0x0dde
#define XK_Thai_baht                     0x0ddf  /* U+0E3F THAI CURRENCY SYMBOL BAHT */
#define XK_Thai_sarae                    0x0de0  /* U+0E40 THAI CHARACTER SARA E */
#define XK_Thai_saraae                   0x0de1  /* U+0E41 THAI CHARACTER SARA AE */
#define XK_Thai_sarao                    0x0de2  /* U+0E42 THAI CHARACTER SARA O */
#define XK_Thai_saraaimaimuan            0x0de3  /* U+0E43 THAI CHARACTER SARA AI MAIMUAN */
#define XK_Thai_saraaimaimalai           0x0de4  /* U+0E44 THAI CHARACTER SARA AI MAIMALAI */
#define XK_Thai_lakkhangyao              0x0de5  /* U+0E45 THAI CHARACTER LAKKHANGYAO */
#define XK_Thai_maiyamok                 0x0de6  /* U+0E46 THAI CHARACTER MAIYAMOK */
#define XK_Thai_maitaikhu                0x0de7  /* U+0E47 THAI CHARACTER MAITAIKHU */
#define XK_Thai_maiek                    0x0de8  /* U+0E48 THAI CHARACTER MAI EK */
#define XK_Thai_maitho                   0x0de9  /* U+0E49 THAI CHARACTER MAI THO */
#define XK_Thai_maitri                   0x0dea  /* U+0E4A THAI CHARACTER MAI TRI */
#define XK_Thai_maichattawa              0x0deb  /* U+0E4B THAI CHARACTER MAI CHATTAWA */
#define XK_Thai_thanthakhat              0x0dec  /* U+0E4C THAI CHARACTER THANTHAKHAT */
#define XK_Thai_nikhahit                 0x0ded  /* U+0E4D THAI CHARACTER NIKHAHIT */
#define XK_Thai_leksun                   0x0df0  /* U+0E50 THAI DIGIT ZERO */
#define XK_Thai_leknung                  0x0df1  /* U+0E51 THAI DIGIT ONE */
#define XK_Thai_leksong                  0x0df2  /* U+0E52 THAI DIGIT TWO */
#define XK_Thai_leksam                   0x0df3  /* U+0E53 THAI DIGIT THREE */
#define XK_Thai_leksi                    0x0df4  /* U+0E54 THAI DIGIT FOUR */
#define XK_Thai_lekha                    0x0df5  /* U+0E55 THAI DIGIT FIVE */
#define XK_Thai_lekhok                   0x0df6  /* U+0E56 THAI DIGIT SIX */
#define XK_Thai_lekchet                  0x0df7  /* U+0E57 THAI DIGIT SEVEN */
#define XK_Thai_lekpaet                  0x0df8  /* U+0E58 THAI DIGIT EIGHT */
#define XK_Thai_lekkao                   0x0df9  /* U+0E59 THAI DIGIT NINE */
/* XK_THAI */

/*
 * Korean
 * Byte 3 = 0x0e
 */



#define XK_Hangul                        0xff31  /* Hangul start/stop(toggle) */
#define XK_Hangul_Start                  0xff32  /* Hangul start */
#define XK_Hangul_End                    0xff33  /* Hangul end, English start */
#define XK_Hangul_Hanja                  0xff34  /* Start Hangul->Hanja Conversion */
#define XK_Hangul_Jamo                   0xff35  /* Hangul Jamo mode */
#define XK_Hangul_Romaja                 0xff36  /* Hangul Romaja mode */
#define XK_Hangul_Codeinput              0xff37  /* Hangul code input mode */
#define XK_Hangul_Jeonja                 0xff38  /* Jeonja mode */
#define XK_Hangul_Banja                  0xff39  /* Banja mode */
#define XK_Hangul_PreHanja               0xff3a  /* Pre Hanja conversion */
#define XK_Hangul_PostHanja              0xff3b  /* Post Hanja conversion */
#define XK_Hangul_SingleCandidate        0xff3c  /* Single candidate */
#define XK_Hangul_MultipleCandidate      0xff3d  /* Multiple candidate */
#define XK_Hangul_PreviousCandidate      0xff3e  /* Previous candidate */
#define XK_Hangul_Special                0xff3f  /* Special symbols */
#define XK_Hangul_switch                 0xff7e  /* Alias for mode_switch */

/* Hangul Consonant Characters */
#define XK_Hangul_Kiyeog                 0x0ea1
#define XK_Hangul_SsangKiyeog            0x0ea2
#define XK_Hangul_KiyeogSios             0x0ea3
#define XK_Hangul_Nieun                  0x0ea4
#define XK_Hangul_NieunJieuj             0x0ea5
#define XK_Hangul_NieunHieuh             0x0ea6
#define XK_Hangul_Dikeud                 0x0ea7
#define XK_Hangul_SsangDikeud            0x0ea8
#define XK_Hangul_Rieul                  0x0ea9
#define XK_Hangul_RieulKiyeog            0x0eaa
#define XK_Hangul_RieulMieum             0x0eab
#define XK_Hangul_RieulPieub             0x0eac
#define XK_Hangul_RieulSios              0x0ead
#define XK_Hangul_RieulTieut             0x0eae
#define XK_Hangul_RieulPhieuf            0x0eaf
#define XK_Hangul_RieulHieuh             0x0eb0
#define XK_Hangul_Mieum                  0x0eb1
#define XK_Hangul_Pieub                  0x0eb2
#define XK_Hangul_SsangPieub             0x0eb3
#define XK_Hangul_PieubSios              0x0eb4
#define XK_Hangul_Sios                   0x0eb5
#define XK_Hangul_SsangSios              0x0eb6
#define XK_Hangul_Ieung                  0x0eb7
#define XK_Hangul_Jieuj                  0x0eb8
#define XK_Hangul_SsangJieuj             0x0eb9
#define XK_Hangul_Cieuc                  0x0eba
#define XK_Hangul_Khieuq                 0x0ebb
#define XK_Hangul_Tieut                  0x0ebc
#define XK_Hangul_Phieuf                 0x0ebd
#define XK_Hangul_Hieuh                  0x0ebe

/* Hangul Vowel Characters */
#define XK_Hangul_A                      0x0ebf
#define XK_Hangul_AE                     0x0ec0
#define XK_Hangul_YA                     0x0ec1
#define XK_Hangul_YAE                    0x0ec2
#define XK_Hangul_EO                     0x0ec3
#define XK_Hangul_E                      0x0ec4
#define XK_Hangul_YEO                    0x0ec5
#define XK_Hangul_YE                     0x0ec6
#define XK_Hangul_O                      0x0ec7
#define XK_Hangul_WA                     0x0ec8
#define XK_Hangul_WAE                    0x0ec9
#define XK_Hangul_OE                     0x0eca
#define XK_Hangul_YO                     0x0ecb
#define XK_Hangul_U                      0x0ecc
#define XK_Hangul_WEO                    0x0ecd
#define XK_Hangul_WE                     0x0ece
#define XK_Hangul_WI                     0x0ecf
#define XK_Hangul_YU                     0x0ed0
#define XK_Hangul_EU                     0x0ed1
#define XK_Hangul_YI                     0x0ed2
#define XK_Hangul_I                      0x0ed3

/* Hangul syllable-final (JongSeong) Characters */
#define XK_Hangul_J_Kiyeog               0x0ed4
#define XK_Hangul_J_SsangKiyeog          0x0ed5
#define XK_Hangul_J_KiyeogSios           0x0ed6
#define XK_Hangul_J_Nieun                0x0ed7
#define XK_Hangul_J_NieunJieuj           0x0ed8
#define XK_Hangul_J_NieunHieuh           0x0ed9
#define XK_Hangul_J_Dikeud               0x0eda
#define XK_Hangul_J_Rieul                0x0edb
#define XK_Hangul_J_RieulKiyeog          0x0edc
#define XK_Hangul_J_RieulMieum           0x0edd
#define XK_Hangul_J_RieulPieub           0x0ede
#define XK_Hangul_J_RieulSios            0x0edf
#define XK_Hangul_J_RieulTieut           0x0ee0
#define XK_Hangul_J_RieulPhieuf          0x0ee1
#define XK_Hangul_J_RieulHieuh           0x0ee2
#define XK_Hangul_J_Mieum                0x0ee3
#define XK_Hangul_J_Pieub                0x0ee4
#define XK_Hangul_J_PieubSios            0x0ee5
#define XK_Hangul_J_Sios                 0x0ee6
#define XK_Hangul_J_SsangSios            0x0ee7
#define XK_Hangul_J_Ieung                0x0ee8
#define XK_Hangul_J_Jieuj                0x0ee9
#define XK_Hangul_J_Cieuc                0x0eea
#define XK_Hangul_J_Khieuq               0x0eeb
#define XK_Hangul_J_Tieut                0x0eec
#define XK_Hangul_J_Phieuf               0x0eed
#define XK_Hangul_J_Hieuh                0x0eee

/* Ancient Hangul Consonant Characters */
#define XK_Hangul_RieulYeorinHieuh       0x0eef
#define XK_Hangul_SunkyeongeumMieum      0x0ef0
#define XK_Hangul_SunkyeongeumPieub      0x0ef1
#define XK_Hangul_PanSios                0x0ef2
#define XK_Hangul_KkogjiDalrinIeung      0x0ef3
#define XK_Hangul_SunkyeongeumPhieuf     0x0ef4
#define XK_Hangul_YeorinHieuh            0x0ef5

/* Ancient Hangul Vowel Characters */
#define XK_Hangul_AraeA                  0x0ef6
#define XK_Hangul_AraeAE                 0x0ef7

/* Ancient Hangul syllable-final (JongSeong) Characters */
#define XK_Hangul_J_PanSios              0x0ef8
#define XK_Hangul_J_KkogjiDalrinIeung    0x0ef9
#define XK_Hangul_J_YeorinHieuh          0x0efa

/* Korean currency symbol */
#define XK_Korean_Won                    0x0eff  /*(U+20A9 WON SIGN)*/

/* XK_KOREAN */

/*
 * Armenian
 */


#define XK_Armenian_ligature_ew       0x1000587  /* U+0587 ARMENIAN SMALL LIGATURE ECH YIWN */
#define XK_Armenian_full_stop         0x1000589  /* U+0589 ARMENIAN FULL STOP */
#define XK_Armenian_verjaket          0x1000589  /* U+0589 ARMENIAN FULL STOP */
#define XK_Armenian_separation_mark   0x100055d  /* U+055D ARMENIAN COMMA */
#define XK_Armenian_but               0x100055d  /* U+055D ARMENIAN COMMA */
#define XK_Armenian_hyphen            0x100058a  /* U+058A ARMENIAN HYPHEN */
#define XK_Armenian_yentamna          0x100058a  /* U+058A ARMENIAN HYPHEN */
#define XK_Armenian_exclam            0x100055c  /* U+055C ARMENIAN EXCLAMATION MARK */
#define XK_Armenian_amanak            0x100055c  /* U+055C ARMENIAN EXCLAMATION MARK */
#define XK_Armenian_accent            0x100055b  /* U+055B ARMENIAN EMPHASIS MARK */
#define XK_Armenian_shesht            0x100055b  /* U+055B ARMENIAN EMPHASIS MARK */
#define XK_Armenian_question          0x100055e  /* U+055E ARMENIAN QUESTION MARK */
#define XK_Armenian_paruyk            0x100055e  /* U+055E ARMENIAN QUESTION MARK */
#define XK_Armenian_AYB               0x1000531  /* U+0531 ARMENIAN CAPITAL LETTER AYB */
#define XK_Armenian_ayb               0x1000561  /* U+0561 ARMENIAN SMALL LETTER AYB */
#define XK_Armenian_BEN               0x1000532  /* U+0532 ARMENIAN CAPITAL LETTER BEN */
#define XK_Armenian_ben               0x1000562  /* U+0562 ARMENIAN SMALL LETTER BEN */
#define XK_Armenian_GIM               0x1000533  /* U+0533 ARMENIAN CAPITAL LETTER GIM */
#define XK_Armenian_gim               0x1000563  /* U+0563 ARMENIAN SMALL LETTER GIM */
#define XK_Armenian_DA                0x1000534  /* U+0534 ARMENIAN CAPITAL LETTER DA */
#define XK_Armenian_da                0x1000564  /* U+0564 ARMENIAN SMALL LETTER DA */
#define XK_Armenian_YECH              0x1000535  /* U+0535 ARMENIAN CAPITAL LETTER ECH */
#define XK_Armenian_yech              0x1000565  /* U+0565 ARMENIAN SMALL LETTER ECH */
#define XK_Armenian_ZA                0x1000536  /* U+0536 ARMENIAN CAPITAL LETTER ZA */
#define XK_Armenian_za                0x1000566  /* U+0566 ARMENIAN SMALL LETTER ZA */
#define XK_Armenian_E                 0x1000537  /* U+0537 ARMENIAN CAPITAL LETTER EH */
#define XK_Armenian_e                 0x1000567  /* U+0567 ARMENIAN SMALL LETTER EH */
#define XK_Armenian_AT                0x1000538  /* U+0538 ARMENIAN CAPITAL LETTER ET */
#define XK_Armenian_at                0x1000568  /* U+0568 ARMENIAN SMALL LETTER ET */
#define XK_Armenian_TO                0x1000539  /* U+0539 ARMENIAN CAPITAL LETTER TO */
#define XK_Armenian_to                0x1000569  /* U+0569 ARMENIAN SMALL LETTER TO */
#define XK_Armenian_ZHE               0x100053a  /* U+053A ARMENIAN CAPITAL LETTER ZHE */
#define XK_Armenian_zhe               0x100056a  /* U+056A ARMENIAN SMALL LETTER ZHE */
#define XK_Armenian_INI               0x100053b  /* U+053B ARMENIAN CAPITAL LETTER INI */
#define XK_Armenian_ini               0x100056b  /* U+056B ARMENIAN SMALL LETTER INI */
#define XK_Armenian_LYUN              0x100053c  /* U+053C ARMENIAN CAPITAL LETTER LIWN */
#define XK_Armenian_lyun              0x100056c  /* U+056C ARMENIAN SMALL LETTER LIWN */
#define XK_Armenian_KHE               0x100053d  /* U+053D ARMENIAN CAPITAL LETTER XEH */
#define XK_Armenian_khe               0x100056d  /* U+056D ARMENIAN SMALL LETTER XEH */
#define XK_Armenian_TSA               0x100053e  /* U+053E ARMENIAN CAPITAL LETTER CA */
#define XK_Armenian_tsa               0x100056e  /* U+056E ARMENIAN SMALL LETTER CA */
#define XK_Armenian_KEN               0x100053f  /* U+053F ARMENIAN CAPITAL LETTER KEN */
#define XK_Armenian_ken               0x100056f  /* U+056F ARMENIAN SMALL LETTER KEN */
#define XK_Armenian_HO                0x1000540  /* U+0540 ARMENIAN CAPITAL LETTER HO */
#define XK_Armenian_ho                0x1000570  /* U+0570 ARMENIAN SMALL LETTER HO */
#define XK_Armenian_DZA               0x1000541  /* U+0541 ARMENIAN CAPITAL LETTER JA */
#define XK_Armenian_dza               0x1000571  /* U+0571 ARMENIAN SMALL LETTER JA */
#define XK_Armenian_GHAT              0x1000542  /* U+0542 ARMENIAN CAPITAL LETTER GHAD */
#define XK_Armenian_ghat              0x1000572  /* U+0572 ARMENIAN SMALL LETTER GHAD */
#define XK_Armenian_TCHE              0x1000543  /* U+0543 ARMENIAN CAPITAL LETTER CHEH */
#define XK_Armenian_tche              0x1000573  /* U+0573 ARMENIAN SMALL LETTER CHEH */
#define XK_Armenian_MEN               0x1000544  /* U+0544 ARMENIAN CAPITAL LETTER MEN */
#define XK_Armenian_men               0x1000574  /* U+0574 ARMENIAN SMALL LETTER MEN */
#define XK_Armenian_HI                0x1000545  /* U+0545 ARMENIAN CAPITAL LETTER YI */
#define XK_Armenian_hi                0x1000575  /* U+0575 ARMENIAN SMALL LETTER YI */
#define XK_Armenian_NU                0x1000546  /* U+0546 ARMENIAN CAPITAL LETTER NOW */
#define XK_Armenian_nu                0x1000576  /* U+0576 ARMENIAN SMALL LETTER NOW */
#define XK_Armenian_SHA               0x1000547  /* U+0547 ARMENIAN CAPITAL LETTER SHA */
#define XK_Armenian_sha               0x1000577  /* U+0577 ARMENIAN SMALL LETTER SHA */
#define XK_Armenian_VO                0x1000548  /* U+0548 ARMENIAN CAPITAL LETTER VO */
#define XK_Armenian_vo                0x1000578  /* U+0578 ARMENIAN SMALL LETTER VO */
#define XK_Armenian_CHA               0x1000549  /* U+0549 ARMENIAN CAPITAL LETTER CHA */
#define XK_Armenian_cha               0x1000579  /* U+0579 ARMENIAN SMALL LETTER CHA */
#define XK_Armenian_PE                0x100054a  /* U+054A ARMENIAN CAPITAL LETTER PEH */
#define XK_Armenian_pe                0x100057a  /* U+057A ARMENIAN SMALL LETTER PEH */
#define XK_Armenian_JE                0x100054b  /* U+054B ARMENIAN CAPITAL LETTER JHEH */
#define XK_Armenian_je                0x100057b  /* U+057B ARMENIAN SMALL LETTER JHEH */
#define XK_Armenian_RA                0x100054c  /* U+054C ARMENIAN CAPITAL LETTER RA */
#define XK_Armenian_ra                0x100057c  /* U+057C ARMENIAN SMALL LETTER RA */
#define XK_Armenian_SE                0x100054d  /* U+054D ARMENIAN CAPITAL LETTER SEH */
#define XK_Armenian_se                0x100057d  /* U+057D ARMENIAN SMALL LETTER SEH */
#define XK_Armenian_VEV               0x100054e  /* U+054E ARMENIAN CAPITAL LETTER VEW */
#define XK_Armenian_vev               0x100057e  /* U+057E ARMENIAN SMALL LETTER VEW */
#define XK_Armenian_TYUN              0x100054f  /* U+054F ARMENIAN CAPITAL LETTER TIWN */
#define XK_Armenian_tyun              0x100057f  /* U+057F ARMENIAN SMALL LETTER TIWN */
#define XK_Armenian_RE                0x1000550  /* U+0550 ARMENIAN CAPITAL LETTER REH */
#define XK_Armenian_re                0x1000580  /* U+0580 ARMENIAN SMALL LETTER REH */
#define XK_Armenian_TSO               0x1000551  /* U+0551 ARMENIAN CAPITAL LETTER CO */
#define XK_Armenian_tso               0x1000581  /* U+0581 ARMENIAN SMALL LETTER CO */
#define XK_Armenian_VYUN              0x1000552  /* U+0552 ARMENIAN CAPITAL LETTER YIWN */
#define XK_Armenian_vyun              0x1000582  /* U+0582 ARMENIAN SMALL LETTER YIWN */
#define XK_Armenian_PYUR              0x1000553  /* U+0553 ARMENIAN CAPITAL LETTER PIWR */
#define XK_Armenian_pyur              0x1000583  /* U+0583 ARMENIAN SMALL LETTER PIWR */
#define XK_Armenian_KE                0x1000554  /* U+0554 ARMENIAN CAPITAL LETTER KEH */
#define XK_Armenian_ke                0x1000584  /* U+0584 ARMENIAN SMALL LETTER KEH */
#define XK_Armenian_O                 0x1000555  /* U+0555 ARMENIAN CAPITAL LETTER OH */
#define XK_Armenian_o                 0x1000585  /* U+0585 ARMENIAN SMALL LETTER OH */
#define XK_Armenian_FE                0x1000556  /* U+0556 ARMENIAN CAPITAL LETTER FEH */
#define XK_Armenian_fe                0x1000586  /* U+0586 ARMENIAN SMALL LETTER FEH */
#define XK_Armenian_apostrophe        0x100055a  /* U+055A ARMENIAN APOSTROPHE */
/* XK_ARMENIAN */

/*
 * Georgian
 */


#define XK_Georgian_an                0x10010d0  /* U+10D0 GEORGIAN LETTER AN */
#define XK_Georgian_ban               0x10010d1  /* U+10D1 GEORGIAN LETTER BAN */
#define XK_Georgian_gan               0x10010d2  /* U+10D2 GEORGIAN LETTER GAN */
#define XK_Georgian_don               0x10010d3  /* U+10D3 GEORGIAN LETTER DON */
#define XK_Georgian_en                0x10010d4  /* U+10D4 GEORGIAN LETTER EN */
#define XK_Georgian_vin               0x10010d5  /* U+10D5 GEORGIAN LETTER VIN */
#define XK_Georgian_zen               0x10010d6  /* U+10D6 GEORGIAN LETTER ZEN */
#define XK_Georgian_tan               0x10010d7  /* U+10D7 GEORGIAN LETTER TAN */
#define XK_Georgian_in                0x10010d8  /* U+10D8 GEORGIAN LETTER IN */
#define XK_Georgian_kan               0x10010d9  /* U+10D9 GEORGIAN LETTER KAN */
#define XK_Georgian_las               0x10010da  /* U+10DA GEORGIAN LETTER LAS */
#define XK_Georgian_man               0x10010db  /* U+10DB GEORGIAN LETTER MAN */
#define XK_Georgian_nar               0x10010dc  /* U+10DC GEORGIAN LETTER NAR */
#define XK_Georgian_on                0x10010dd  /* U+10DD GEORGIAN LETTER ON */
#define XK_Georgian_par               0x10010de  /* U+10DE GEORGIAN LETTER PAR */
#define XK_Georgian_zhar              0x10010df  /* U+10DF GEORGIAN LETTER ZHAR */
#define XK_Georgian_rae               0x10010e0  /* U+10E0 GEORGIAN LETTER RAE */
#define XK_Georgian_san               0x10010e1  /* U+10E1 GEORGIAN LETTER SAN */
#define XK_Georgian_tar               0x10010e2  /* U+10E2 GEORGIAN LETTER TAR */
#define XK_Georgian_un                0x10010e3  /* U+10E3 GEORGIAN LETTER UN */
#define XK_Georgian_phar              0x10010e4  /* U+10E4 GEORGIAN LETTER PHAR */
#define XK_Georgian_khar              0x10010e5  /* U+10E5 GEORGIAN LETTER KHAR */
#define XK_Georgian_ghan              0x10010e6  /* U+10E6 GEORGIAN LETTER GHAN */
#define XK_Georgian_qar               0x10010e7  /* U+10E7 GEORGIAN LETTER QAR */
#define XK_Georgian_shin              0x10010e8  /* U+10E8 GEORGIAN LETTER SHIN */
#define XK_Georgian_chin              0x10010e9  /* U+10E9 GEORGIAN LETTER CHIN */
#define XK_Georgian_can               0x10010ea  /* U+10EA GEORGIAN LETTER CAN */
#define XK_Georgian_jil               0x10010eb  /* U+10EB GEORGIAN LETTER JIL */
#define XK_Georgian_cil               0x10010ec  /* U+10EC GEORGIAN LETTER CIL */
#define XK_Georgian_char              0x10010ed  /* U+10ED GEORGIAN LETTER CHAR */
#define XK_Georgian_xan               0x10010ee  /* U+10EE GEORGIAN LETTER XAN */
#define XK_Georgian_jhan              0x10010ef  /* U+10EF GEORGIAN LETTER JHAN */
#define XK_Georgian_hae               0x10010f0  /* U+10F0 GEORGIAN LETTER HAE */
#define XK_Georgian_he                0x10010f1  /* U+10F1 GEORGIAN LETTER HE */
#define XK_Georgian_hie               0x10010f2  /* U+10F2 GEORGIAN LETTER HIE */
#define XK_Georgian_we                0x10010f3  /* U+10F3 GEORGIAN LETTER WE */
#define XK_Georgian_har               0x10010f4  /* U+10F4 GEORGIAN LETTER HAR */
#define XK_Georgian_hoe               0x10010f5  /* U+10F5 GEORGIAN LETTER HOE */
#define XK_Georgian_fi                0x10010f6  /* U+10F6 GEORGIAN LETTER FI */
/* XK_GEORGIAN */

/*
 * Azeri (and other Turkic or Caucasian languages)
 */


/* latin */
#define XK_Xabovedot                  0x1001e8a  /* U+1E8A LATIN CAPITAL LETTER X WITH DOT ABOVE */
#define XK_Ibreve                     0x100012c  /* U+012C LATIN CAPITAL LETTER I WITH BREVE */
#define XK_Zstroke                    0x10001b5  /* U+01B5 LATIN CAPITAL LETTER Z WITH STROKE */
#define XK_Gcaron                     0x10001e6  /* U+01E6 LATIN CAPITAL LETTER G WITH CARON */
#define XK_Ocaron                     0x10001d1  /* U+01D2 LATIN CAPITAL LETTER O WITH CARON */
#define XK_Obarred                    0x100019f  /* U+019F LATIN CAPITAL LETTER O WITH MIDDLE TILDE */
#define XK_xabovedot                  0x1001e8b  /* U+1E8B LATIN SMALL LETTER X WITH DOT ABOVE */
#define XK_ibreve                     0x100012d  /* U+012D LATIN SMALL LETTER I WITH BREVE */
#define XK_zstroke                    0x10001b6  /* U+01B6 LATIN SMALL LETTER Z WITH STROKE */
#define XK_gcaron                     0x10001e7  /* U+01E7 LATIN SMALL LETTER G WITH CARON */
#define XK_ocaron                     0x10001d2  /* U+01D2 LATIN SMALL LETTER O WITH CARON */
#define XK_obarred                    0x1000275  /* U+0275 LATIN SMALL LETTER BARRED O */
#define XK_SCHWA                      0x100018f  /* U+018F LATIN CAPITAL LETTER SCHWA */
#define XK_schwa                      0x1000259  /* U+0259 LATIN SMALL LETTER SCHWA */
/* those are not really Caucasus */
/* For Inupiak */
#define XK_Lbelowdot                  0x1001e36  /* U+1E36 LATIN CAPITAL LETTER L WITH DOT BELOW */
#define XK_lbelowdot                  0x1001e37  /* U+1E37 LATIN SMALL LETTER L WITH DOT BELOW */
/* XK_CAUCASUS */

/*
 * Vietnamese
 */
 

#define XK_Abelowdot                  0x1001ea0  /* U+1EA0 LATIN CAPITAL LETTER A WITH DOT BELOW */
#define XK_abelowdot                  0x1001ea1  /* U+1EA1 LATIN SMALL LETTER A WITH DOT BELOW */
#define XK_Ahook                      0x1001ea2  /* U+1EA2 LATIN CAPITAL LETTER A WITH HOOK ABOVE */
#define XK_ahook                      0x1001ea3  /* U+1EA3 LATIN SMALL LETTER A WITH HOOK ABOVE */
#define XK_Acircumflexacute           0x1001ea4  /* U+1EA4 LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE */
#define XK_acircumflexacute           0x1001ea5  /* U+1EA5 LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE */
#define XK_Acircumflexgrave           0x1001ea6  /* U+1EA6 LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE */
#define XK_acircumflexgrave           0x1001ea7  /* U+1EA7 LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE */
#define XK_Acircumflexhook            0x1001ea8  /* U+1EA8 LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE */
#define XK_acircumflexhook            0x1001ea9  /* U+1EA9 LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE */
#define XK_Acircumflextilde           0x1001eaa  /* U+1EAA LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE */
#define XK_acircumflextilde           0x1001eab  /* U+1EAB LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE */
#define XK_Acircumflexbelowdot        0x1001eac  /* U+1EAC LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW */
#define XK_acircumflexbelowdot        0x1001ead  /* U+1EAD LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW */
#define XK_Abreveacute                0x1001eae  /* U+1EAE LATIN CAPITAL LETTER A WITH BREVE AND ACUTE */
#define XK_abreveacute                0x1001eaf  /* U+1EAF LATIN SMALL LETTER A WITH BREVE AND ACUTE */
#define XK_Abrevegrave                0x1001eb0  /* U+1EB0 LATIN CAPITAL LETTER A WITH BREVE AND GRAVE */
#define XK_abrevegrave                0x1001eb1  /* U+1EB1 LATIN SMALL LETTER A WITH BREVE AND GRAVE */
#define XK_Abrevehook                 0x1001eb2  /* U+1EB2 LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE */
#define XK_abrevehook                 0x1001eb3  /* U+1EB3 LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE */
#define XK_Abrevetilde                0x1001eb4  /* U+1EB4 LATIN CAPITAL LETTER A WITH BREVE AND TILDE */
#define XK_abrevetilde                0x1001eb5  /* U+1EB5 LATIN SMALL LETTER A WITH BREVE AND TILDE */
#define XK_Abrevebelowdot             0x1001eb6  /* U+1EB6 LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW */
#define XK_abrevebelowdot             0x1001eb7  /* U+1EB7 LATIN SMALL LETTER A WITH BREVE AND DOT BELOW */
#define XK_Ebelowdot                  0x1001eb8  /* U+1EB8 LATIN CAPITAL LETTER E WITH DOT BELOW */
#define XK_ebelowdot                  0x1001eb9  /* U+1EB9 LATIN SMALL LETTER E WITH DOT BELOW */
#define XK_Ehook                      0x1001eba  /* U+1EBA LATIN CAPITAL LETTER E WITH HOOK ABOVE */
#define XK_ehook                      0x1001ebb  /* U+1EBB LATIN SMALL LETTER E WITH HOOK ABOVE */
#define XK_Etilde                     0x1001ebc  /* U+1EBC LATIN CAPITAL LETTER E WITH TILDE */
#define XK_etilde                     0x1001ebd  /* U+1EBD LATIN SMALL LETTER E WITH TILDE */
#define XK_Ecircumflexacute           0x1001ebe  /* U+1EBE LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE */
#define XK_ecircumflexacute           0x1001ebf  /* U+1EBF LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE */
#define XK_Ecircumflexgrave           0x1001ec0  /* U+1EC0 LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE */
#define XK_ecircumflexgrave           0x1001ec1  /* U+1EC1 LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE */
#define XK_Ecircumflexhook            0x1001ec2  /* U+1EC2 LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE */
#define XK_ecircumflexhook            0x1001ec3  /* U+1EC3 LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE */
#define XK_Ecircumflextilde           0x1001ec4  /* U+1EC4 LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE */
#define XK_ecircumflextilde           0x1001ec5  /* U+1EC5 LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE */
#define XK_Ecircumflexbelowdot        0x1001ec6  /* U+1EC6 LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW */
#define XK_ecircumflexbelowdot        0x1001ec7  /* U+1EC7 LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW */
#define XK_Ihook                      0x1001ec8  /* U+1EC8 LATIN CAPITAL LETTER I WITH HOOK ABOVE */
#define XK_ihook                      0x1001ec9  /* U+1EC9 LATIN SMALL LETTER I WITH HOOK ABOVE */
#define XK_Ibelowdot                  0x1001eca  /* U+1ECA LATIN CAPITAL LETTER I WITH DOT BELOW */
#define XK_ibelowdot                  0x1001ecb  /* U+1ECB LATIN SMALL LETTER I WITH DOT BELOW */
#define XK_Obelowdot                  0x1001ecc  /* U+1ECC LATIN CAPITAL LETTER O WITH DOT BELOW */
#define XK_obelowdot                  0x1001ecd  /* U+1ECD LATIN SMALL LETTER O WITH DOT BELOW */
#define XK_Ohook                      0x1001ece  /* U+1ECE LATIN CAPITAL LETTER O WITH HOOK ABOVE */
#define XK_ohook                      0x1001ecf  /* U+1ECF LATIN SMALL LETTER O WITH HOOK ABOVE */
#define XK_Ocircumflexacute           0x1001ed0  /* U+1ED0 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE */
#define XK_ocircumflexacute           0x1001ed1  /* U+1ED1 LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE */
#define XK_Ocircumflexgrave           0x1001ed2  /* U+1ED2 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE */
#define XK_ocircumflexgrave           0x1001ed3  /* U+1ED3 LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE */
#define XK_Ocircumflexhook            0x1001ed4  /* U+1ED4 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE */
#define XK_ocircumflexhook            0x1001ed5  /* U+1ED5 LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE */
#define XK_Ocircumflextilde           0x1001ed6  /* U+1ED6 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE */
#define XK_ocircumflextilde           0x1001ed7  /* U+1ED7 LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE */
#define XK_Ocircumflexbelowdot        0x1001ed8  /* U+1ED8 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW */
#define XK_ocircumflexbelowdot        0x1001ed9  /* U+1ED9 LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW */
#define XK_Ohornacute                 0x1001eda  /* U+1EDA LATIN CAPITAL LETTER O WITH HORN AND ACUTE */
#define XK_ohornacute                 0x1001edb  /* U+1EDB LATIN SMALL LETTER O WITH HORN AND ACUTE */
#define XK_Ohorngrave                 0x1001edc  /* U+1EDC LATIN CAPITAL LETTER O WITH HORN AND GRAVE */
#define XK_ohorngrave                 0x1001edd  /* U+1EDD LATIN SMALL LETTER O WITH HORN AND GRAVE */
#define XK_Ohornhook                  0x1001ede  /* U+1EDE LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE */
#define XK_ohornhook                  0x1001edf  /* U+1EDF LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE */
#define XK_Ohorntilde                 0x1001ee0  /* U+1EE0 LATIN CAPITAL LETTER O WITH HORN AND TILDE */
#define XK_ohorntilde                 0x1001ee1  /* U+1EE1 LATIN SMALL LETTER O WITH HORN AND TILDE */
#define XK_Ohornbelowdot              0x1001ee2  /* U+1EE2 LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW */
#define XK_ohornbelowdot              0x1001ee3  /* U+1EE3 LATIN SMALL LETTER O WITH HORN AND DOT BELOW */
#define XK_Ubelowdot                  0x1001ee4  /* U+1EE4 LATIN CAPITAL LETTER U WITH DOT BELOW */
#define XK_ubelowdot                  0x1001ee5  /* U+1EE5 LATIN SMALL LETTER U WITH DOT BELOW */
#define XK_Uhook                      0x1001ee6  /* U+1EE6 LATIN CAPITAL LETTER U WITH HOOK ABOVE */
#define XK_uhook                      0x1001ee7  /* U+1EE7 LATIN SMALL LETTER U WITH HOOK ABOVE */
#define XK_Uhornacute                 0x1001ee8  /* U+1EE8 LATIN CAPITAL LETTER U WITH HORN AND ACUTE */
#define XK_uhornacute                 0x1001ee9  /* U+1EE9 LATIN SMALL LETTER U WITH HORN AND ACUTE */
#define XK_Uhorngrave                 0x1001eea  /* U+1EEA LATIN CAPITAL LETTER U WITH HORN AND GRAVE */
#define XK_uhorngrave                 0x1001eeb  /* U+1EEB LATIN SMALL LETTER U WITH HORN AND GRAVE */
#define XK_Uhornhook                  0x1001eec  /* U+1EEC LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE */
#define XK_uhornhook                  0x1001eed  /* U+1EED LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE */
#define XK_Uhorntilde                 0x1001eee  /* U+1EEE LATIN CAPITAL LETTER U WITH HORN AND TILDE */
#define XK_uhorntilde                 0x1001eef  /* U+1EEF LATIN SMALL LETTER U WITH HORN AND TILDE */
#define XK_Uhornbelowdot              0x1001ef0  /* U+1EF0 LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW */
#define XK_uhornbelowdot              0x1001ef1  /* U+1EF1 LATIN SMALL LETTER U WITH HORN AND DOT BELOW */
#define XK_Ybelowdot                  0x1001ef4  /* U+1EF4 LATIN CAPITAL LETTER Y WITH DOT BELOW */
#define XK_ybelowdot                  0x1001ef5  /* U+1EF5 LATIN SMALL LETTER Y WITH DOT BELOW */
#define XK_Yhook                      0x1001ef6  /* U+1EF6 LATIN CAPITAL LETTER Y WITH HOOK ABOVE */
#define XK_yhook                      0x1001ef7  /* U+1EF7 LATIN SMALL LETTER Y WITH HOOK ABOVE */
#define XK_Ytilde                     0x1001ef8  /* U+1EF8 LATIN CAPITAL LETTER Y WITH TILDE */
#define XK_ytilde                     0x1001ef9  /* U+1EF9 LATIN SMALL LETTER Y WITH TILDE */
#define XK_Ohorn                      0x10001a0  /* U+01A0 LATIN CAPITAL LETTER O WITH HORN */
#define XK_ohorn                      0x10001a1  /* U+01A1 LATIN SMALL LETTER O WITH HORN */
#define XK_Uhorn                      0x10001af  /* U+01AF LATIN CAPITAL LETTER U WITH HORN */
#define XK_uhorn                      0x10001b0  /* U+01B0 LATIN SMALL LETTER U WITH HORN */

/* XK_VIETNAMESE */


#define XK_EcuSign                    0x10020a0  /* U+20A0 EURO-CURRENCY SIGN */
#define XK_ColonSign                  0x10020a1  /* U+20A1 COLON SIGN */
#define XK_CruzeiroSign               0x10020a2  /* U+20A2 CRUZEIRO SIGN */
#define XK_FFrancSign                 0x10020a3  /* U+20A3 FRENCH FRANC SIGN */
#define XK_LiraSign                   0x10020a4  /* U+20A4 LIRA SIGN */
#define XK_MillSign                   0x10020a5  /* U+20A5 MILL SIGN */
#define XK_NairaSign                  0x10020a6  /* U+20A6 NAIRA SIGN */
#define XK_PesetaSign                 0x10020a7  /* U+20A7 PESETA SIGN */
#define XK_RupeeSign                  0x10020a8  /* U+20A8 RUPEE SIGN */
#define XK_WonSign                    0x10020a9  /* U+20A9 WON SIGN */
#define XK_NewSheqelSign              0x10020aa  /* U+20AA NEW SHEQEL SIGN */
#define XK_DongSign                   0x10020ab  /* U+20AB DONG SIGN */
#define XK_EuroSign                      0x20ac  /* U+20AC EURO SIGN */
/* XK_CURRENCY */


/* one, two and three are defined above. */
#define XK_zerosuperior               0x1002070  /* U+2070 SUPERSCRIPT ZERO */
#define XK_foursuperior               0x1002074  /* U+2074 SUPERSCRIPT FOUR */
#define XK_fivesuperior               0x1002075  /* U+2075 SUPERSCRIPT FIVE */
#define XK_sixsuperior                0x1002076  /* U+2076 SUPERSCRIPT SIX */
#define XK_sevensuperior              0x1002077  /* U+2077 SUPERSCRIPT SEVEN */
#define XK_eightsuperior              0x1002078  /* U+2078 SUPERSCRIPT EIGHT */
#define XK_ninesuperior               0x1002079  /* U+2079 SUPERSCRIPT NINE */
#define XK_zerosubscript              0x1002080  /* U+2080 SUBSCRIPT ZERO */
#define XK_onesubscript               0x1002081  /* U+2081 SUBSCRIPT ONE */
#define XK_twosubscript               0x1002082  /* U+2082 SUBSCRIPT TWO */
#define XK_threesubscript             0x1002083  /* U+2083 SUBSCRIPT THREE */
#define XK_foursubscript              0x1002084  /* U+2084 SUBSCRIPT FOUR */
#define XK_fivesubscript              0x1002085  /* U+2085 SUBSCRIPT FIVE */
#define XK_sixsubscript               0x1002086  /* U+2086 SUBSCRIPT SIX */
#define XK_sevensubscript             0x1002087  /* U+2087 SUBSCRIPT SEVEN */
#define XK_eightsubscript             0x1002088  /* U+2088 SUBSCRIPT EIGHT */
#define XK_ninesubscript              0x1002089  /* U+2089 SUBSCRIPT NINE */
#define XK_partdifferential           0x1002202  /* U+2202 PARTIAL DIFFERENTIAL */
#define XK_emptyset                   0x1002205  /* U+2205 NULL SET */
#define XK_elementof                  0x1002208  /* U+2208 ELEMENT OF */
#define XK_notelementof               0x1002209  /* U+2209 NOT AN ELEMENT OF */
#define XK_containsas                 0x100220B  /* U+220B CONTAINS AS MEMBER */
#define XK_squareroot                 0x100221A  /* U+221A SQUARE ROOT */
#define XK_cuberoot                   0x100221B  /* U+221B CUBE ROOT */
#define XK_fourthroot                 0x100221C  /* U+221C FOURTH ROOT */
#define XK_dintegral                  0x100222C  /* U+222C DOUBLE INTEGRAL */
#define XK_tintegral                  0x100222D  /* U+222D TRIPLE INTEGRAL */
#define XK_because                    0x1002235  /* U+2235 BECAUSE */
#define XK_approxeq                   0x1002248  /* U+2245 ALMOST EQUAL TO */
#define XK_notapproxeq                0x1002247  /* U+2247 NOT ALMOST EQUAL TO */
#define XK_notidentical               0x1002262  /* U+2262 NOT IDENTICAL TO */
#define XK_stricteq                   0x1002263  /* U+2263 STRICTLY EQUIVALENT TO */          
/* XK_MATHEMATICAL */


#define XK_braille_dot_1                 0xfff1
#define XK_braille_dot_2                 0xfff2
#define XK_braille_dot_3                 0xfff3
#define XK_braille_dot_4                 0xfff4
#define XK_braille_dot_5                 0xfff5
#define XK_braille_dot_6                 0xfff6
#define XK_braille_dot_7                 0xfff7
#define XK_braille_dot_8                 0xfff8
#define XK_braille_dot_9                 0xfff9
#define XK_braille_dot_10                0xfffa
#define XK_braille_blank              0x1002800  /* U+2800 BRAILLE PATTERN BLANK */
#define XK_braille_dots_1             0x1002801  /* U+2801 BRAILLE PATTERN DOTS-1 */
#define XK_braille_dots_2             0x1002802  /* U+2802 BRAILLE PATTERN DOTS-2 */
#define XK_braille_dots_12            0x1002803  /* U+2803 BRAILLE PATTERN DOTS-12 */
#define XK_braille_dots_3             0x1002804  /* U+2804 BRAILLE PATTERN DOTS-3 */
#define XK_braille_dots_13            0x1002805  /* U+2805 BRAILLE PATTERN DOTS-13 */
#define XK_braille_dots_23            0x1002806  /* U+2806 BRAILLE PATTERN DOTS-23 */
#define XK_braille_dots_123           0x1002807  /* U+2807 BRAILLE PATTERN DOTS-123 */
#define XK_braille_dots_4             0x1002808  /* U+2808 BRAILLE PATTERN DOTS-4 */
#define XK_braille_dots_14            0x1002809  /* U+2809 BRAILLE PATTERN DOTS-14 */
#define XK_braille_dots_24            0x100280a  /* U+280a BRAILLE PATTERN DOTS-24 */
#define XK_braille_dots_124           0x100280b  /* U+280b BRAILLE PATTERN DOTS-124 */
#define XK_braille_dots_34            0x100280c  /* U+280c BRAILLE PATTERN DOTS-34 */
#define XK_braille_dots_134           0x100280d  /* U+280d BRAILLE PATTERN DOTS-134 */
#define XK_braille_dots_234           0x100280e  /* U+280e BRAILLE PATTERN DOTS-234 */
#define XK_braille_dots_1234          0x100280f  /* U+280f BRAILLE PATTERN DOTS-1234 */
#define XK_braille_dots_5             0x1002810  /* U+2810 BRAILLE PATTERN DOTS-5 */
#define XK_braille_dots_15            0x1002811  /* U+2811 BRAILLE PATTERN DOTS-15 */
#define XK_braille_dots_25            0x1002812  /* U+2812 BRAILLE PATTERN DOTS-25 */
#define XK_braille_dots_125           0x1002813  /* U+2813 BRAILLE PATTERN DOTS-125 */
#define XK_braille_dots_35            0x1002814  /* U+2814 BRAILLE PATTERN DOTS-35 */
#define XK_braille_dots_135           0x1002815  /* U+2815 BRAILLE PATTERN DOTS-135 */
#define XK_braille_dots_235           0x1002816  /* U+2816 BRAILLE PATTERN DOTS-235 */
#define XK_braille_dots_1235          0x1002817  /* U+2817 BRAILLE PATTERN DOTS-1235 */
#define XK_braille_dots_45            0x1002818  /* U+2818 BRAILLE PATTERN DOTS-45 */
#define XK_braille_dots_145           0x1002819  /* U+2819 BRAILLE PATTERN DOTS-145 */
#define XK_braille_dots_245           0x100281a  /* U+281a BRAILLE PATTERN DOTS-245 */
#define XK_braille_dots_1245          0x100281b  /* U+281b BRAILLE PATTERN DOTS-1245 */
#define XK_braille_dots_345           0x100281c  /* U+281c BRAILLE PATTERN DOTS-345 */
#define XK_braille_dots_1345          0x100281d  /* U+281d BRAILLE PATTERN DOTS-1345 */
#define XK_braille_dots_2345          0x100281e  /* U+281e BRAILLE PATTERN DOTS-2345 */
#define XK_braille_dots_12345         0x100281f  /* U+281f BRAILLE PATTERN DOTS-12345 */
#define XK_braille_dots_6             0x1002820  /* U+2820 BRAILLE PATTERN DOTS-6 */
#define XK_braille_dots_16            0x1002821  /* U+2821 BRAILLE PATTERN DOTS-16 */
#define XK_braille_dots_26            0x1002822  /* U+2822 BRAILLE PATTERN DOTS-26 */
#define XK_braille_dots_126           0x1002823  /* U+2823 BRAILLE PATTERN DOTS-126 */
#define XK_braille_dots_36            0x1002824  /* U+2824 BRAILLE PATTERN DOTS-36 */
#define XK_braille_dots_136           0x1002825  /* U+2825 BRAILLE PATTERN DOTS-136 */
#define XK_braille_dots_236           0x1002826  /* U+2826 BRAILLE PATTERN DOTS-236 */
#define XK_braille_dots_1236          0x1002827  /* U+2827 BRAILLE PATTERN DOTS-1236 */
#define XK_braille_dots_46            0x1002828  /* U+2828 BRAILLE PATTERN DOTS-46 */
#define XK_braille_dots_146           0x1002829  /* U+2829 BRAILLE PATTERN DOTS-146 */
#define XK_braille_dots_246           0x100282a  /* U+282a BRAILLE PATTERN DOTS-246 */
#define XK_braille_dots_1246          0x100282b  /* U+282b BRAILLE PATTERN DOTS-1246 */
#define XK_braille_dots_346           0x100282c  /* U+282c BRAILLE PATTERN DOTS-346 */
#define XK_braille_dots_1346          0x100282d  /* U+282d BRAILLE PATTERN DOTS-1346 */
#define XK_braille_dots_2346          0x100282e  /* U+282e BRAILLE PATTERN DOTS-2346 */
#define XK_braille_dots_12346         0x100282f  /* U+282f BRAILLE PATTERN DOTS-12346 */
#define XK_braille_dots_56            0x1002830  /* U+2830 BRAILLE PATTERN DOTS-56 */
#define XK_braille_dots_156           0x1002831  /* U+2831 BRAILLE PATTERN DOTS-156 */
#define XK_braille_dots_256           0x1002832  /* U+2832 BRAILLE PATTERN DOTS-256 */
#define XK_braille_dots_1256          0x1002833  /* U+2833 BRAILLE PATTERN DOTS-1256 */
#define XK_braille_dots_356           0x1002834  /* U+2834 BRAILLE PATTERN DOTS-356 */
#define XK_braille_dots_1356          0x1002835  /* U+2835 BRAILLE PATTERN DOTS-1356 */
#define XK_braille_dots_2356          0x1002836  /* U+2836 BRAILLE PATTERN DOTS-2356 */
#define XK_braille_dots_12356         0x1002837  /* U+2837 BRAILLE PATTERN DOTS-12356 */
#define XK_braille_dots_456           0x1002838  /* U+2838 BRAILLE PATTERN DOTS-456 */
#define XK_braille_dots_1456          0x1002839  /* U+2839 BRAILLE PATTERN DOTS-1456 */
#define XK_braille_dots_2456          0x100283a  /* U+283a BRAILLE PATTERN DOTS-2456 */
#define XK_braille_dots_12456         0x100283b  /* U+283b BRAILLE PATTERN DOTS-12456 */
#define XK_braille_dots_3456          0x100283c  /* U+283c BRAILLE PATTERN DOTS-3456 */
#define XK_braille_dots_13456         0x100283d  /* U+283d BRAILLE PATTERN DOTS-13456 */
#define XK_braille_dots_23456         0x100283e  /* U+283e BRAILLE PATTERN DOTS-23456 */
#define XK_braille_dots_123456        0x100283f  /* U+283f BRAILLE PATTERN DOTS-123456 */
#define XK_braille_dots_7             0x1002840  /* U+2840 BRAILLE PATTERN DOTS-7 */
#define XK_braille_dots_17            0x1002841  /* U+2841 BRAILLE PATTERN DOTS-17 */
#define XK_braille_dots_27            0x1002842  /* U+2842 BRAILLE PATTERN DOTS-27 */
#define XK_braille_dots_127           0x1002843  /* U+2843 BRAILLE PATTERN DOTS-127 */
#define XK_braille_dots_37            0x1002844  /* U+2844 BRAILLE PATTERN DOTS-37 */
#define XK_braille_dots_137           0x1002845  /* U+2845 BRAILLE PATTERN DOTS-137 */
#define XK_braille_dots_237           0x1002846  /* U+2846 BRAILLE PATTERN DOTS-237 */
#define XK_braille_dots_1237          0x1002847  /* U+2847 BRAILLE PATTERN DOTS-1237 */
#define XK_braille_dots_47            0x1002848  /* U+2848 BRAILLE PATTERN DOTS-47 */
#define XK_braille_dots_147           0x1002849  /* U+2849 BRAILLE PATTERN DOTS-147 */
#define XK_braille_dots_247           0x100284a  /* U+284a BRAILLE PATTERN DOTS-247 */
#define XK_braille_dots_1247          0x100284b  /* U+284b BRAILLE PATTERN DOTS-1247 */
#define XK_braille_dots_347           0x100284c  /* U+284c BRAILLE PATTERN DOTS-347 */
#define XK_braille_dots_1347          0x100284d  /* U+284d BRAILLE PATTERN DOTS-1347 */
#define XK_braille_dots_2347          0x100284e  /* U+284e BRAILLE PATTERN DOTS-2347 */
#define XK_braille_dots_12347         0x100284f  /* U+284f BRAILLE PATTERN DOTS-12347 */
#define XK_braille_dots_57            0x1002850  /* U+2850 BRAILLE PATTERN DOTS-57 */
#define XK_braille_dots_157           0x1002851  /* U+2851 BRAILLE PATTERN DOTS-157 */
#define XK_braille_dots_257           0x1002852  /* U+2852 BRAILLE PATTERN DOTS-257 */
#define XK_braille_dots_1257          0x1002853  /* U+2853 BRAILLE PATTERN DOTS-1257 */
#define XK_braille_dots_357           0x1002854  /* U+2854 BRAILLE PATTERN DOTS-357 */
#define XK_braille_dots_1357          0x1002855  /* U+2855 BRAILLE PATTERN DOTS-1357 */
#define XK_braille_dots_2357          0x1002856  /* U+2856 BRAILLE PATTERN DOTS-2357 */
#define XK_braille_dots_12357         0x1002857  /* U+2857 BRAILLE PATTERN DOTS-12357 */
#define XK_braille_dots_457           0x1002858  /* U+2858 BRAILLE PATTERN DOTS-457 */
#define XK_braille_dots_1457          0x1002859  /* U+2859 BRAILLE PATTERN DOTS-1457 */
#define XK_braille_dots_2457          0x100285a  /* U+285a BRAILLE PATTERN DOTS-2457 */
#define XK_braille_dots_12457         0x100285b  /* U+285b BRAILLE PATTERN DOTS-12457 */
#define XK_braille_dots_3457          0x100285c  /* U+285c BRAILLE PATTERN DOTS-3457 */
#define XK_braille_dots_13457         0x100285d  /* U+285d BRAILLE PATTERN DOTS-13457 */
#define XK_braille_dots_23457         0x100285e  /* U+285e BRAILLE PATTERN DOTS-23457 */
#define XK_braille_dots_123457        0x100285f  /* U+285f BRAILLE PATTERN DOTS-123457 */
#define XK_braille_dots_67            0x1002860  /* U+2860 BRAILLE PATTERN DOTS-67 */
#define XK_braille_dots_167           0x1002861  /* U+2861 BRAILLE PATTERN DOTS-167 */
#define XK_braille_dots_267           0x1002862  /* U+2862 BRAILLE PATTERN DOTS-267 */
#define XK_braille_dots_1267          0x1002863  /* U+2863 BRAILLE PATTERN DOTS-1267 */
#define XK_braille_dots_367           0x1002864  /* U+2864 BRAILLE PATTERN DOTS-367 */
#define XK_braille_dots_1367          0x1002865  /* U+2865 BRAILLE PATTERN DOTS-1367 */
#define XK_braille_dots_2367          0x1002866  /* U+2866 BRAILLE PATTERN DOTS-2367 */
#define XK_braille_dots_12367         0x1002867  /* U+2867 BRAILLE PATTERN DOTS-12367 */
#define XK_braille_dots_467           0x1002868  /* U+2868 BRAILLE PATTERN DOTS-467 */
#define XK_braille_dots_1467          0x1002869  /* U+2869 BRAILLE PATTERN DOTS-1467 */
#define XK_braille_dots_2467          0x100286a  /* U+286a BRAILLE PATTERN DOTS-2467 */
#define XK_braille_dots_12467         0x100286b  /* U+286b BRAILLE PATTERN DOTS-12467 */
#define XK_braille_dots_3467          0x100286c  /* U+286c BRAILLE PATTERN DOTS-3467 */
#define XK_braille_dots_13467         0x100286d  /* U+286d BRAILLE PATTERN DOTS-13467 */
#define XK_braille_dots_23467         0x100286e  /* U+286e BRAILLE PATTERN DOTS-23467 */
#define XK_braille_dots_123467        0x100286f  /* U+286f BRAILLE PATTERN DOTS-123467 */
#define XK_braille_dots_567           0x1002870  /* U+2870 BRAILLE PATTERN DOTS-567 */
#define XK_braille_dots_1567          0x1002871  /* U+2871 BRAILLE PATTERN DOTS-1567 */
#define XK_braille_dots_2567          0x1002872  /* U+2872 BRAILLE PATTERN DOTS-2567 */
#define XK_braille_dots_12567         0x1002873  /* U+2873 BRAILLE PATTERN DOTS-12567 */
#define XK_braille_dots_3567          0x1002874  /* U+2874 BRAILLE PATTERN DOTS-3567 */
#define XK_braille_dots_13567         0x1002875  /* U+2875 BRAILLE PATTERN DOTS-13567 */
#define XK_braille_dots_23567         0x1002876  /* U+2876 BRAILLE PATTERN DOTS-23567 */
#define XK_braille_dots_123567        0x1002877  /* U+2877 BRAILLE PATTERN DOTS-123567 */
#define XK_braille_dots_4567          0x1002878  /* U+2878 BRAILLE PATTERN DOTS-4567 */
#define XK_braille_dots_14567         0x1002879  /* U+2879 BRAILLE PATTERN DOTS-14567 */
#define XK_braille_dots_24567         0x100287a  /* U+287a BRAILLE PATTERN DOTS-24567 */
#define XK_braille_dots_124567        0x100287b  /* U+287b BRAILLE PATTERN DOTS-124567 */
#define XK_braille_dots_34567         0x100287c  /* U+287c BRAILLE PATTERN DOTS-34567 */
#define XK_braille_dots_134567        0x100287d  /* U+287d BRAILLE PATTERN DOTS-134567 */
#define XK_braille_dots_234567        0x100287e  /* U+287e BRAILLE PATTERN DOTS-234567 */
#define XK_braille_dots_1234567       0x100287f  /* U+287f BRAILLE PATTERN DOTS-1234567 */
#define XK_braille_dots_8             0x1002880  /* U+2880 BRAILLE PATTERN DOTS-8 */
#define XK_braille_dots_18            0x1002881  /* U+2881 BRAILLE PATTERN DOTS-18 */
#define XK_braille_dots_28            0x1002882  /* U+2882 BRAILLE PATTERN DOTS-28 */
#define XK_braille_dots_128           0x1002883  /* U+2883 BRAILLE PATTERN DOTS-128 */
#define XK_braille_dots_38            0x1002884  /* U+2884 BRAILLE PATTERN DOTS-38 */
#define XK_braille_dots_138           0x1002885  /* U+2885 BRAILLE PATTERN DOTS-138 */
#define XK_braille_dots_238           0x1002886  /* U+2886 BRAILLE PATTERN DOTS-238 */
#define XK_braille_dots_1238          0x1002887  /* U+2887 BRAILLE PATTERN DOTS-1238 */
#define XK_braille_dots_48            0x1002888  /* U+2888 BRAILLE PATTERN DOTS-48 */
#define XK_braille_dots_148           0x1002889  /* U+2889 BRAILLE PATTERN DOTS-148 */
#define XK_braille_dots_248           0x100288a  /* U+288a BRAILLE PATTERN DOTS-248 */
#define XK_braille_dots_1248          0x100288b  /* U+288b BRAILLE PATTERN DOTS-1248 */
#define XK_braille_dots_348           0x100288c  /* U+288c BRAILLE PATTERN DOTS-348 */
#define XK_braille_dots_1348          0x100288d  /* U+288d BRAILLE PATTERN DOTS-1348 */
#define XK_braille_dots_2348          0x100288e  /* U+288e BRAILLE PATTERN DOTS-2348 */
#define XK_braille_dots_12348         0x100288f  /* U+288f BRAILLE PATTERN DOTS-12348 */
#define XK_braille_dots_58            0x1002890  /* U+2890 BRAILLE PATTERN DOTS-58 */
#define XK_braille_dots_158           0x1002891  /* U+2891 BRAILLE PATTERN DOTS-158 */
#define XK_braille_dots_258           0x1002892  /* U+2892 BRAILLE PATTERN DOTS-258 */
#define XK_braille_dots_1258          0x1002893  /* U+2893 BRAILLE PATTERN DOTS-1258 */
#define XK_braille_dots_358           0x1002894  /* U+2894 BRAILLE PATTERN DOTS-358 */
#define XK_braille_dots_1358          0x1002895  /* U+2895 BRAILLE PATTERN DOTS-1358 */
#define XK_braille_dots_2358          0x1002896  /* U+2896 BRAILLE PATTERN DOTS-2358 */
#define XK_braille_dots_12358         0x1002897  /* U+2897 BRAILLE PATTERN DOTS-12358 */
#define XK_braille_dots_458           0x1002898  /* U+2898 BRAILLE PATTERN DOTS-458 */
#define XK_braille_dots_1458          0x1002899  /* U+2899 BRAILLE PATTERN DOTS-1458 */
#define XK_braille_dots_2458          0x100289a  /* U+289a BRAILLE PATTERN DOTS-2458 */
#define XK_braille_dots_12458         0x100289b  /* U+289b BRAILLE PATTERN DOTS-12458 */
#define XK_braille_dots_3458          0x100289c  /* U+289c BRAILLE PATTERN DOTS-3458 */
#define XK_braille_dots_13458         0x100289d  /* U+289d BRAILLE PATTERN DOTS-13458 */
#define XK_braille_dots_23458         0x100289e  /* U+289e BRAILLE PATTERN DOTS-23458 */
#define XK_braille_dots_123458        0x100289f  /* U+289f BRAILLE PATTERN DOTS-123458 */
#define XK_braille_dots_68            0x10028a0  /* U+28a0 BRAILLE PATTERN DOTS-68 */
#define XK_braille_dots_168           0x10028a1  /* U+28a1 BRAILLE PATTERN DOTS-168 */
#define XK_braille_dots_268           0x10028a2  /* U+28a2 BRAILLE PATTERN DOTS-268 */
#define XK_braille_dots_1268          0x10028a3  /* U+28a3 BRAILLE PATTERN DOTS-1268 */
#define XK_braille_dots_368           0x10028a4  /* U+28a4 BRAILLE PATTERN DOTS-368 */
#define XK_braille_dots_1368          0x10028a5  /* U+28a5 BRAILLE PATTERN DOTS-1368 */
#define XK_braille_dots_2368          0x10028a6  /* U+28a6 BRAILLE PATTERN DOTS-2368 */
#define XK_braille_dots_12368         0x10028a7  /* U+28a7 BRAILLE PATTERN DOTS-12368 */
#define XK_braille_dots_468           0x10028a8  /* U+28a8 BRAILLE PATTERN DOTS-468 */
#define XK_braille_dots_1468          0x10028a9  /* U+28a9 BRAILLE PATTERN DOTS-1468 */
#define XK_braille_dots_2468          0x10028aa  /* U+28aa BRAILLE PATTERN DOTS-2468 */
#define XK_braille_dots_12468         0x10028ab  /* U+28ab BRAILLE PATTERN DOTS-12468 */
#define XK_braille_dots_3468          0x10028ac  /* U+28ac BRAILLE PATTERN DOTS-3468 */
#define XK_braille_dots_13468         0x10028ad  /* U+28ad BRAILLE PATTERN DOTS-13468 */
#define XK_braille_dots_23468         0x10028ae  /* U+28ae BRAILLE PATTERN DOTS-23468 */
#define XK_braille_dots_123468        0x10028af  /* U+28af BRAILLE PATTERN DOTS-123468 */
#define XK_braille_dots_568           0x10028b0  /* U+28b0 BRAILLE PATTERN DOTS-568 */
#define XK_braille_dots_1568          0x10028b1  /* U+28b1 BRAILLE PATTERN DOTS-1568 */
#define XK_braille_dots_2568          0x10028b2  /* U+28b2 BRAILLE PATTERN DOTS-2568 */
#define XK_braille_dots_12568         0x10028b3  /* U+28b3 BRAILLE PATTERN DOTS-12568 */
#define XK_braille_dots_3568          0x10028b4  /* U+28b4 BRAILLE PATTERN DOTS-3568 */
#define XK_braille_dots_13568         0x10028b5  /* U+28b5 BRAILLE PATTERN DOTS-13568 */
#define XK_braille_dots_23568         0x10028b6  /* U+28b6 BRAILLE PATTERN DOTS-23568 */
#define XK_braille_dots_123568        0x10028b7  /* U+28b7 BRAILLE PATTERN DOTS-123568 */
#define XK_braille_dots_4568          0x10028b8  /* U+28b8 BRAILLE PATTERN DOTS-4568 */
#define XK_braille_dots_14568         0x10028b9  /* U+28b9 BRAILLE PATTERN DOTS-14568 */
#define XK_braille_dots_24568         0x10028ba  /* U+28ba BRAILLE PATTERN DOTS-24568 */
#define XK_braille_dots_124568        0x10028bb  /* U+28bb BRAILLE PATTERN DOTS-124568 */
#define XK_braille_dots_34568         0x10028bc  /* U+28bc BRAILLE PATTERN DOTS-34568 */
#define XK_braille_dots_134568        0x10028bd  /* U+28bd BRAILLE PATTERN DOTS-134568 */
#define XK_braille_dots_234568        0x10028be  /* U+28be BRAILLE PATTERN DOTS-234568 */
#define XK_braille_dots_1234568       0x10028bf  /* U+28bf BRAILLE PATTERN DOTS-1234568 */
#define XK_braille_dots_78            0x10028c0  /* U+28c0 BRAILLE PATTERN DOTS-78 */
#define XK_braille_dots_178           0x10028c1  /* U+28c1 BRAILLE PATTERN DOTS-178 */
#define XK_braille_dots_278           0x10028c2  /* U+28c2 BRAILLE PATTERN DOTS-278 */
#define XK_braille_dots_1278          0x10028c3  /* U+28c3 BRAILLE PATTERN DOTS-1278 */
#define XK_braille_dots_378           0x10028c4  /* U+28c4 BRAILLE PATTERN DOTS-378 */
#define XK_braille_dots_1378          0x10028c5  /* U+28c5 BRAILLE PATTERN DOTS-1378 */
#define XK_braille_dots_2378          0x10028c6  /* U+28c6 BRAILLE PATTERN DOTS-2378 */
#define XK_braille_dots_12378         0x10028c7  /* U+28c7 BRAILLE PATTERN DOTS-12378 */
#define XK_braille_dots_478           0x10028c8  /* U+28c8 BRAILLE PATTERN DOTS-478 */
#define XK_braille_dots_1478          0x10028c9  /* U+28c9 BRAILLE PATTERN DOTS-1478 */
#define XK_braille_dots_2478          0x10028ca  /* U+28ca BRAILLE PATTERN DOTS-2478 */
#define XK_braille_dots_12478         0x10028cb  /* U+28cb BRAILLE PATTERN DOTS-12478 */
#define XK_braille_dots_3478          0x10028cc  /* U+28cc BRAILLE PATTERN DOTS-3478 */
#define XK_braille_dots_13478         0x10028cd  /* U+28cd BRAILLE PATTERN DOTS-13478 */
#define XK_braille_dots_23478         0x10028ce  /* U+28ce BRAILLE PATTERN DOTS-23478 */
#define XK_braille_dots_123478        0x10028cf  /* U+28cf BRAILLE PATTERN DOTS-123478 */
#define XK_braille_dots_578           0x10028d0  /* U+28d0 BRAILLE PATTERN DOTS-578 */
#define XK_braille_dots_1578          0x10028d1  /* U+28d1 BRAILLE PATTERN DOTS-1578 */
#define XK_braille_dots_2578          0x10028d2  /* U+28d2 BRAILLE PATTERN DOTS-2578 */
#define XK_braille_dots_12578         0x10028d3  /* U+28d3 BRAILLE PATTERN DOTS-12578 */
#define XK_braille_dots_3578          0x10028d4  /* U+28d4 BRAILLE PATTERN DOTS-3578 */
#define XK_braille_dots_13578         0x10028d5  /* U+28d5 BRAILLE PATTERN DOTS-13578 */
#define XK_braille_dots_23578         0x10028d6  /* U+28d6 BRAILLE PATTERN DOTS-23578 */
#define XK_braille_dots_123578        0x10028d7  /* U+28d7 BRAILLE PATTERN DOTS-123578 */
#define XK_braille_dots_4578          0x10028d8  /* U+28d8 BRAILLE PATTERN DOTS-4578 */
#define XK_braille_dots_14578         0x10028d9  /* U+28d9 BRAILLE PATTERN DOTS-14578 */
#define XK_braille_dots_24578         0x10028da  /* U+28da BRAILLE PATTERN DOTS-24578 */
#define XK_braille_dots_124578        0x10028db  /* U+28db BRAILLE PATTERN DOTS-124578 */
#define XK_braille_dots_34578         0x10028dc  /* U+28dc BRAILLE PATTERN DOTS-34578 */
#define XK_braille_dots_134578        0x10028dd  /* U+28dd BRAILLE PATTERN DOTS-134578 */
#define XK_braille_dots_234578        0x10028de  /* U+28de BRAILLE PATTERN DOTS-234578 */
#define XK_braille_dots_1234578       0x10028df  /* U+28df BRAILLE PATTERN DOTS-1234578 */
#define XK_braille_dots_678           0x10028e0  /* U+28e0 BRAILLE PATTERN DOTS-678 */
#define XK_braille_dots_1678          0x10028e1  /* U+28e1 BRAILLE PATTERN DOTS-1678 */
#define XK_braille_dots_2678          0x10028e2  /* U+28e2 BRAILLE PATTERN DOTS-2678 */
#define XK_braille_dots_12678         0x10028e3  /* U+28e3 BRAILLE PATTERN DOTS-12678 */
#define XK_braille_dots_3678          0x10028e4  /* U+28e4 BRAILLE PATTERN DOTS-3678 */
#define XK_braille_dots_13678         0x10028e5  /* U+28e5 BRAILLE PATTERN DOTS-13678 */
#define XK_braille_dots_23678         0x10028e6  /* U+28e6 BRAILLE PATTERN DOTS-23678 */
#define XK_braille_dots_123678        0x10028e7  /* U+28e7 BRAILLE PATTERN DOTS-123678 */
#define XK_braille_dots_4678          0x10028e8  /* U+28e8 BRAILLE PATTERN DOTS-4678 */
#define XK_braille_dots_14678         0x10028e9  /* U+28e9 BRAILLE PATTERN DOTS-14678 */
#define XK_braille_dots_24678         0x10028ea  /* U+28ea BRAILLE PATTERN DOTS-24678 */
#define XK_braille_dots_124678        0x10028eb  /* U+28eb BRAILLE PATTERN DOTS-124678 */
#define XK_braille_dots_34678         0x10028ec  /* U+28ec BRAILLE PATTERN DOTS-34678 */
#define XK_braille_dots_134678        0x10028ed  /* U+28ed BRAILLE PATTERN DOTS-134678 */
#define XK_braille_dots_234678        0x10028ee  /* U+28ee BRAILLE PATTERN DOTS-234678 */
#define XK_braille_dots_1234678       0x10028ef  /* U+28ef BRAILLE PATTERN DOTS-1234678 */
#define XK_braille_dots_5678          0x10028f0  /* U+28f0 BRAILLE PATTERN DOTS-5678 */
#define XK_braille_dots_15678         0x10028f1  /* U+28f1 BRAILLE PATTERN DOTS-15678 */
#define XK_braille_dots_25678         0x10028f2  /* U+28f2 BRAILLE PATTERN DOTS-25678 */
#define XK_braille_dots_125678        0x10028f3  /* U+28f3 BRAILLE PATTERN DOTS-125678 */
#define XK_braille_dots_35678         0x10028f4  /* U+28f4 BRAILLE PATTERN DOTS-35678 */
#define XK_braille_dots_135678        0x10028f5  /* U+28f5 BRAILLE PATTERN DOTS-135678 */
#define XK_braille_dots_235678        0x10028f6  /* U+28f6 BRAILLE PATTERN DOTS-235678 */
#define XK_braille_dots_1235678       0x10028f7  /* U+28f7 BRAILLE PATTERN DOTS-1235678 */
#define XK_braille_dots_45678         0x10028f8  /* U+28f8 BRAILLE PATTERN DOTS-45678 */
#define XK_braille_dots_145678        0x10028f9  /* U+28f9 BRAILLE PATTERN DOTS-145678 */
#define XK_braille_dots_245678        0x10028fa  /* U+28fa BRAILLE PATTERN DOTS-245678 */
#define XK_braille_dots_1245678       0x10028fb  /* U+28fb BRAILLE PATTERN DOTS-1245678 */
#define XK_braille_dots_345678        0x10028fc  /* U+28fc BRAILLE PATTERN DOTS-345678 */
#define XK_braille_dots_1345678       0x10028fd  /* U+28fd BRAILLE PATTERN DOTS-1345678 */
#define XK_braille_dots_2345678       0x10028fe  /* U+28fe BRAILLE PATTERN DOTS-2345678 */
#define XK_braille_dots_12345678      0x10028ff  /* U+28ff BRAILLE PATTERN DOTS-12345678 */
/* XK_BRAILLE */

/*
 * Sinhala (http://unicode.org/charts/PDF/U0D80.pdf)
 * http://www.nongnu.org/sinhala/doc/transliteration/sinhala-transliteration_6.html
 */


#define XK_Sinh_ng            0x1000d82  /* U+0D82 SINHALA ANUSVARAYA */
#define XK_Sinh_h2            0x1000d83  /* U+0D83 SINHALA VISARGAYA */
#define XK_Sinh_a             0x1000d85  /* U+0D85 SINHALA AYANNA */
#define XK_Sinh_aa            0x1000d86  /* U+0D86 SINHALA AAYANNA */
#define XK_Sinh_ae            0x1000d87  /* U+0D87 SINHALA AEYANNA */
#define XK_Sinh_aee           0x1000d88  /* U+0D88 SINHALA AEEYANNA */
#define XK_Sinh_i             0x1000d89  /* U+0D89 SINHALA IYANNA */
#define XK_Sinh_ii            0x1000d8a  /* U+0D8A SINHALA IIYANNA */
#define XK_Sinh_u             0x1000d8b  /* U+0D8B SINHALA UYANNA */
#define XK_Sinh_uu            0x1000d8c  /* U+0D8C SINHALA UUYANNA */
#define XK_Sinh_ri            0x1000d8d  /* U+0D8D SINHALA IRUYANNA */
#define XK_Sinh_rii           0x1000d8e  /* U+0D8E SINHALA IRUUYANNA */
#define XK_Sinh_lu            0x1000d8f  /* U+0D8F SINHALA ILUYANNA */
#define XK_Sinh_luu           0x1000d90  /* U+0D90 SINHALA ILUUYANNA */
#define XK_Sinh_e             0x1000d91  /* U+0D91 SINHALA EYANNA */
#define XK_Sinh_ee            0x1000d92  /* U+0D92 SINHALA EEYANNA */
#define XK_Sinh_ai            0x1000d93  /* U+0D93 SINHALA AIYANNA */
#define XK_Sinh_o             0x1000d94  /* U+0D94 SINHALA OYANNA */
#define XK_Sinh_oo            0x1000d95  /* U+0D95 SINHALA OOYANNA */
#define XK_Sinh_au            0x1000d96  /* U+0D96 SINHALA AUYANNA */
#define XK_Sinh_ka            0x1000d9a  /* U+0D9A SINHALA KAYANNA */
#define XK_Sinh_kha           0x1000d9b  /* U+0D9B SINHALA MAHA. KAYANNA */
#define XK_Sinh_ga            0x1000d9c  /* U+0D9C SINHALA GAYANNA */
#define XK_Sinh_gha           0x1000d9d  /* U+0D9D SINHALA MAHA. GAYANNA */
#define XK_Sinh_ng2           0x1000d9e  /* U+0D9E SINHALA KANTAJA NAASIKYAYA */
#define XK_Sinh_nga           0x1000d9f  /* U+0D9F SINHALA SANYAKA GAYANNA */
#define XK_Sinh_ca            0x1000da0  /* U+0DA0 SINHALA CAYANNA */
#define XK_Sinh_cha           0x1000da1  /* U+0DA1 SINHALA MAHA. CAYANNA */
#define XK_Sinh_ja            0x1000da2  /* U+0DA2 SINHALA JAYANNA */
#define XK_Sinh_jha           0x1000da3  /* U+0DA3 SINHALA MAHA. JAYANNA */
#define XK_Sinh_nya           0x1000da4  /* U+0DA4 SINHALA TAALUJA NAASIKYAYA */
#define XK_Sinh_jnya          0x1000da5  /* U+0DA5 SINHALA TAALUJA SANYOOGA NAASIKYAYA */
#define XK_Sinh_nja           0x1000da6  /* U+0DA6 SINHALA SANYAKA JAYANNA */
#define XK_Sinh_tta           0x1000da7  /* U+0DA7 SINHALA TTAYANNA */
#define XK_Sinh_ttha          0x1000da8  /* U+0DA8 SINHALA MAHA. TTAYANNA */
#define XK_Sinh_dda           0x1000da9  /* U+0DA9 SINHALA DDAYANNA */
#define XK_Sinh_ddha          0x1000daa  /* U+0DAA SINHALA MAHA. DDAYANNA */
#define XK_Sinh_nna           0x1000dab  /* U+0DAB SINHALA MUURDHAJA NAYANNA */
#define XK_Sinh_ndda          0x1000dac  /* U+0DAC SINHALA SANYAKA DDAYANNA */
#define XK_Sinh_tha           0x1000dad  /* U+0DAD SINHALA TAYANNA */
#define XK_Sinh_thha          0x1000dae  /* U+0DAE SINHALA MAHA. TAYANNA */
#define XK_Sinh_dha           0x1000daf  /* U+0DAF SINHALA DAYANNA */
#define XK_Sinh_dhha          0x1000db0  /* U+0DB0 SINHALA MAHA. DAYANNA */
#define XK_Sinh_na            0x1000db1  /* U+0DB1 SINHALA DANTAJA NAYANNA */
#define XK_Sinh_ndha          0x1000db3  /* U+0DB3 SINHALA SANYAKA DAYANNA */
#define XK_Sinh_pa            0x1000db4  /* U+0DB4 SINHALA PAYANNA */
#define XK_Sinh_pha           0x1000db5  /* U+0DB5 SINHALA MAHA. PAYANNA */
#define XK_Sinh_ba            0x1000db6  /* U+0DB6 SINHALA BAYANNA */
#define XK_Sinh_bha           0x1000db7  /* U+0DB7 SINHALA MAHA. BAYANNA */
#define XK_Sinh_ma            0x1000db8  /* U+0DB8 SINHALA MAYANNA */
#define XK_Sinh_mba           0x1000db9  /* U+0DB9 SINHALA AMBA BAYANNA */
#define XK_Sinh_ya            0x1000dba  /* U+0DBA SINHALA YAYANNA */
#define XK_Sinh_ra            0x1000dbb  /* U+0DBB SINHALA RAYANNA */
#define XK_Sinh_la            0x1000dbd  /* U+0DBD SINHALA DANTAJA LAYANNA */
#define XK_Sinh_va            0x1000dc0  /* U+0DC0 SINHALA VAYANNA */
#define XK_Sinh_sha           0x1000dc1  /* U+0DC1 SINHALA TAALUJA SAYANNA */
#define XK_Sinh_ssha          0x1000dc2  /* U+0DC2 SINHALA MUURDHAJA SAYANNA */
#define XK_Sinh_sa            0x1000dc3  /* U+0DC3 SINHALA DANTAJA SAYANNA */
#define XK_Sinh_ha            0x1000dc4  /* U+0DC4 SINHALA HAYANNA */
#define XK_Sinh_lla           0x1000dc5  /* U+0DC5 SINHALA MUURDHAJA LAYANNA */
#define XK_Sinh_fa            0x1000dc6  /* U+0DC6 SINHALA FAYANNA */
#define XK_Sinh_al            0x1000dca  /* U+0DCA SINHALA AL-LAKUNA */
#define XK_Sinh_aa2           0x1000dcf  /* U+0DCF SINHALA AELA-PILLA */
#define XK_Sinh_ae2           0x1000dd0  /* U+0DD0 SINHALA AEDA-PILLA */
#define XK_Sinh_aee2          0x1000dd1  /* U+0DD1 SINHALA DIGA AEDA-PILLA */
#define XK_Sinh_i2            0x1000dd2  /* U+0DD2 SINHALA IS-PILLA */
#define XK_Sinh_ii2           0x1000dd3  /* U+0DD3 SINHALA DIGA IS-PILLA */
#define XK_Sinh_u2            0x1000dd4  /* U+0DD4 SINHALA PAA-PILLA */
#define XK_Sinh_uu2           0x1000dd6  /* U+0DD6 SINHALA DIGA PAA-PILLA */
#define XK_Sinh_ru2           0x1000dd8  /* U+0DD8 SINHALA GAETTA-PILLA */
#define XK_Sinh_e2            0x1000dd9  /* U+0DD9 SINHALA KOMBUVA */
#define XK_Sinh_ee2           0x1000dda  /* U+0DDA SINHALA DIGA KOMBUVA */
#define XK_Sinh_ai2           0x1000ddb  /* U+0DDB SINHALA KOMBU DEKA */
#define XK_Sinh_o2            0x1000ddc  /* U+0DDC SINHALA KOMBUVA HAA AELA-PILLA*/
#define XK_Sinh_oo2           0x1000ddd  /* U+0DDD SINHALA KOMBUVA HAA DIGA AELA-PILLA*/
#define XK_Sinh_au2           0x1000dde  /* U+0DDE SINHALA KOMBUVA HAA GAYANUKITTA */
#define XK_Sinh_lu2           0x1000ddf  /* U+0DDF SINHALA GAYANUKITTA */
#define XK_Sinh_ruu2          0x1000df2  /* U+0DF2 SINHALA DIGA GAETTA-PILLA */
#define XK_Sinh_luu2          0x1000df3  /* U+0DF3 SINHALA DIGA GAYANUKITTA */
#define XK_Sinh_kunddaliya    0x1000df4  /* U+0DF4 SINHALA KUNDDALIYA */
/* XK_SINHALA */
# 73 "/usr/include/X11/keysym.h" 2 3


# 102 "include/forms.h" 2

#include <X11/Xresource.h>
# 1 "/usr/include/X11/Xresource.h" 1 3

/***********************************************************

Copyright 1987, 1988, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.


Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/


#define _X11_XRESOURCE_H_


#include <X11/Xlib.h>


/****************************************************************
 ****************************************************************
 ***                                                          ***
 ***                                                          ***
 ***          X Resource Manager Intrinsics                   ***
 ***                                                          ***
 ***                                                          ***
 ****************************************************************
 ****************************************************************/

 

/****************************************************************
 *
 * Memory Management
 *
 ****************************************************************/

extern char *Xpermalloc(
    unsigned int	/* size */
);

/****************************************************************
 *
 * Quark Management
 *
 ****************************************************************/

typedef int       XrmQuark, *XrmQuarkList;
#define NULLQUARK ((XrmQuark) 0)

typedef char *XrmString;
#define NULLSTRING ((XrmString) 0)

/* find quark for string, create new quark if none already exists */
extern XrmQuark XrmStringToQuark(
    const  char* 	/* string */
);

extern XrmQuark XrmPermStringToQuark(
    const  char* 	/* string */
);

/* find string for quark */
extern XrmString XrmQuarkToString(
    XrmQuark 		/* quark */
);

extern XrmQuark XrmUniqueQuark(
    void
);

#define XrmStringsEqual(a1, a2) (strcmp(a1, a2) == 0)


/****************************************************************
 *
 * Conversion of Strings to Lists
 *
 ****************************************************************/

typedef enum {XrmBindTightly, XrmBindLoosely} XrmBinding, *XrmBindingList;

extern void XrmStringToQuarkList(
    const  char*	/* string */,
    XrmQuarkList	/* quarks_return */
);

extern void XrmStringToBindingQuarkList(
    const  char*	/* string */,
    XrmBindingList	/* bindings_return */,
    XrmQuarkList	/* quarks_return */
);

/****************************************************************
 *
 * Name and Class lists.
 *
 ****************************************************************/

typedef XrmQuark     XrmName;
typedef XrmQuarkList XrmNameList;
#define XrmNameToString(name)		XrmQuarkToString(name)
#define XrmStringToName(string)		XrmStringToQuark(string)
#define XrmStringToNameList(str, name)	XrmStringToQuarkList(str, name)

typedef XrmQuark     XrmClass;
typedef XrmQuarkList XrmClassList;
#define XrmClassToString(c_class)	XrmQuarkToString(c_class)
#define XrmStringToClass(c_class)	XrmStringToQuark(c_class)
#define XrmStringToClassList(str,c_class) XrmStringToQuarkList(str, c_class)



/****************************************************************
 *
 * Resource Representation Types and Values
 *
 ****************************************************************/

typedef XrmQuark     XrmRepresentation;
#define XrmStringToRepresentation(string)   XrmStringToQuark(string)
#define	XrmRepresentationToString(type)   XrmQuarkToString(type)

typedef struct {
    unsigned int    size;
    XPointer	    addr;
} XrmValue, *XrmValuePtr;


/****************************************************************
 *
 * Resource Manager Functions
 *
 ****************************************************************/

typedef struct _XrmHashBucketRec *XrmHashBucket;
typedef XrmHashBucket *XrmHashTable;
typedef XrmHashTable XrmSearchList[];
typedef struct _XrmHashBucketRec *XrmDatabase;


extern void XrmDestroyDatabase(
    XrmDatabase		/* database */
);

extern void XrmQPutResource(
    XrmDatabase*	/* database */,
    XrmBindingList	/* bindings */,
    XrmQuarkList	/* quarks */,
    XrmRepresentation	/* type */,
    XrmValue*		/* value */
);

extern void XrmPutResource(
    XrmDatabase*	/* database */,
    const  char*	/* specifier */,
    const  char*	/* type */,
    XrmValue*		/* value */
);

extern void XrmQPutStringResource(
    XrmDatabase*	/* database */,
    XrmBindingList      /* bindings */,
    XrmQuarkList	/* quarks */,
    const  char*	/* value */
);

extern void XrmPutStringResource(
    XrmDatabase*	/* database */,
    const  char*	/* specifier */,
    const  char*	/* value */
);

extern void XrmPutLineResource(
    XrmDatabase*	/* database */,
    const  char*	/* line */
);

extern int  XrmQGetResource(
    XrmDatabase		/* database */,
    XrmNameList		/* quark_name */,
    XrmClassList	/* quark_class */,
    XrmRepresentation*	/* quark_type_return */,
    XrmValue*		/* value_return */
);

extern int  XrmGetResource(
    XrmDatabase		/* database */,
    const  char*	/* str_name */,
    const  char*	/* str_class */,
    char**		/* str_type_return */,
    XrmValue*		/* value_return */
);

extern int  XrmQGetSearchList(
    XrmDatabase		/* database */,
    XrmNameList		/* names */,
    XrmClassList	/* classes */,
    XrmSearchList	/* list_return */,
    int			/* list_length */
);

extern int  XrmQGetSearchResource(
    XrmSearchList	/* list */,
    XrmName		/* name */,
    XrmClass		/* class */,
    XrmRepresentation*	/* type_return */,
    XrmValue*		/* value_return */
);

/****************************************************************
 *
 * Resource Database Management
 *
 ****************************************************************/



extern void XrmSetDatabase(
    Display*		/* display */,
    XrmDatabase		/* database */
);

extern XrmDatabase XrmGetDatabase(
    Display*		/* display */
);

/* !_XP_PRINT_SERVER_ */

extern XrmDatabase XrmGetFileDatabase(
    const  char*	/* filename */
);

extern int  XrmCombineFileDatabase(
    const  char* 	/* filename */,
    XrmDatabase*	/* target */,
    int 		/* override */
);

extern XrmDatabase XrmGetStringDatabase(
    const  char*	/* data */  /*  null terminated string */
);

extern void XrmPutFileDatabase(
    XrmDatabase		/* database */,
    const  char*	/* filename */
);

extern void XrmMergeDatabases(
    XrmDatabase		/* source_db */,
    XrmDatabase*	/* target_db */
);

extern void XrmCombineDatabase(
    XrmDatabase		/* source_db */,
    XrmDatabase*	/* target_db */,
    int 		/* override */
);

#define XrmEnumAllLevels 0
#define XrmEnumOneLevel  1

extern int  XrmEnumerateDatabase(
    XrmDatabase		/* db */,
    XrmNameList		/* name_prefix */,
    XrmClassList	/* class_prefix */,
    int			/* mode */,
    int  (*)(
	     XrmDatabase*	/* db */,
	     XrmBindingList	/* bindings */,
	     XrmQuarkList	/* quarks */,
	     XrmRepresentation*	/* type */,
	     XrmValue*		/* value */,
	     XPointer		/* closure */
	     )		/* proc */,
    XPointer		/* closure */
);

extern const char *XrmLocaleOfDatabase(
    XrmDatabase 	/* database */
);


/****************************************************************
 *
 * Command line option mapping to resource entries
 *
 ****************************************************************/

typedef enum {
    XrmoptionNoArg,	/* Value is specified in OptionDescRec.value	    */
    XrmoptionIsArg,     /* Value is the option string itself		    */
    XrmoptionStickyArg, /* Value is characters immediately following option */
    XrmoptionSepArg,    /* Value is next argument in argv		    */
    XrmoptionResArg,	/* Resource and value in next argument in argv      */
    XrmoptionSkipArg,   /* Ignore this option and the next argument in argv */
    XrmoptionSkipLine,  /* Ignore this option and the rest of argv	    */
    XrmoptionSkipNArgs	/* Ignore this option and the next
			   OptionDescRes.value arguments in argv */
} XrmOptionKind;

typedef struct {
    char	    *option;	    /* Option abbreviation in argv	    */
    char	    *specifier;     /* Resource specifier		    */
    XrmOptionKind   argKind;	    /* Which style of option it is	    */
    XPointer	    value;	    /* Value to provide if XrmoptionNoArg   */
} XrmOptionDescRec, *XrmOptionDescList;


extern void XrmParseCommand(
    XrmDatabase*	/* database */,
    XrmOptionDescList	/* table */,
    int			/* table_count */,
    const  char*	/* name */,
    int*		/* argc_in_out */,
    char**		/* argv_in_out */
);

 

/* _X11_XRESOURCE_H_ */
/* DON'T ADD STUFF AFTER THIS #endif */
# 103 "include/forms.h" 2



#define FL_UNUSED_ARG __attribute__ ((unused))




/* Some general constants */

enum {
    FL_ON          = 1,
    FL_OK          = 1,
    FL_VALID       = 1,
    FL_PREEMPT     = 1,
    FL_AUTO        = 2,
    FL_WHEN_NEEDED = FL_AUTO,
    FL_OFF         = 0,
    FL_CANCEL      = 0,
    FL_INVALID     = 0,

    /* WM_DELETE_WINDOW callback return */

    FL_IGNORE      = -1
};

/* Max  directory length  */





#define FL_PATH_MAX       PATH_MAX

/* ! def FL_PATH_MAX */

/* The screen coordinate unit, FL_Coord, must be of signed type */

typedef int FL_Coord;
#define FL_COORD         FL_Coord

typedef unsigned long FL_COLOR;

/* Coordinates can be in pixels, milli-meters or points (1/72inch) */

typedef enum {
    FL_COORD_PIXEL,         /* default, Pixel           */
    FL_COORD_MM,            /* milli-meter              */
    FL_COORD_POINT,         /* point                    */
    FL_COORD_centiMM,       /* one hundredth of a mm    */
    FL_COORD_centiPOINT     /* one hundredth of a point */
} FL_COORD_UNIT;

/* All object classes. */

typedef enum {
    FL_INVALID_CLASS,      /*  0 */
    FL_BUTTON,             /*  1 */
    FL_LIGHTBUTTON,        /*  2 */
    FL_ROUNDBUTTON,        /*  3 */
    FL_ROUND3DBUTTON,      /*  4 */
    FL_CHECKBUTTON,        /*  5 */
    FL_BITMAPBUTTON,       /*  6 */
    FL_PIXMAPBUTTON,       /*  7 */
    FL_BITMAP,             /*  8 */
    FL_PIXMAP,             /*  9 */
    FL_BOX,                /* 10 */
    FL_TEXT,               /* 11 */
    FL_MENU,               /* 12 */
    FL_CHART,              /* 13 */
    FL_CHOICE,             /* 14 */
    FL_COUNTER,            /* 15 */
    FL_SLIDER,             /* 16 */
    FL_VALSLIDER,          /* 17 */
    FL_INPUT,              /* 18 */
    FL_BROWSER,            /* 19 */
    FL_DIAL,               /* 20 */
    FL_TIMER,              /* 21 */
    FL_CLOCK,              /* 22 */
    FL_POSITIONER,         /* 23 */
    FL_FREE,               /* 24 */
    FL_XYPLOT,             /* 25 */
    FL_FRAME,              /* 26 */
    FL_LABELFRAME,         /* 27 */
    FL_CANVAS,             /* 28 */
    FL_GLCANVAS,           /* 29 */
    FL_TABFOLDER,          /* 30 */
    FL_SCROLLBAR,          /* 31 */
    FL_SCROLLBUTTON,       /* 32 */
    FL_MENUBAR,            /* 33 */
    FL_TEXTBOX,            /* 34, for internal use only */
    FL_LABELBUTTON,        /* 35 */
    FL_COMBOBOX,           /* 36 */
    FL_IMAGECANVAS,        /* 37 */
    FL_THUMBWHEEL,         /* 38 */
    FL_COLORWHEEL,         /* 39 */
    FL_FORMBROWSER,        /* 40 */
    FL_SELECT,             /* 41 */
    FL_NMENU,              /* 42 */
    FL_SPINNER,            /* 43 */
    FL_TBOX,               /* 44 */
    FL_CLASS_END           /* sentinel */
} FL_CLASS;

#define FL_BEGIN_GROUP        10000
#define FL_END_GROUP          20000

#define FL_USER_CLASS_START   1001  /* min. user class  value */
#define FL_USER_CLASS_END     9999  /* max. user class  value */

/* Maximum border width (in pixel) */

#define FL_MAX_BW          10

/* How to display a form onto screen */

typedef enum {
    FL_PLACE_FREE       =   0,      /* size remain resizable      */
    FL_PLACE_MOUSE      =   1,      /* mouse centered on form     */
    FL_PLACE_CENTER     =   2,         /* center of the screen       */
    FL_PLACE_POSITION   =   4,         /* specific position          */
    FL_PLACE_SIZE       =   8,         /* specific size              */
    FL_PLACE_GEOMETRY   =  16,         /* specific size and position */
    FL_PLACE_ASPECT     =  32,         /* keep aspect ratio          */
    FL_PLACE_FULLSCREEN =  64,         /* scale to fit to screen     */
    FL_PLACE_HOTSPOT    = 128,         /* so mouse fall on (x,y)     */
    FL_PLACE_ICONIC     = 256,         /* start in iconified form    */

    /* Modifiers */

    FL_FREE_SIZE        = ( 1 << 14 ),
	FL_FIX_SIZE         = ( 1 << 15 )  /* seems to be useless, but some
										  programs seem to rely on it... */
} FL_PLACE;

#define FL_PLACE_FREE_CENTER ( FL_PLACE_CENTER | FL_FREE_SIZE )
#define FL_PLACE_CENTERFREE  ( FL_PLACE_CENTER | FL_FREE_SIZE )

/* Window manager decoration request and forms attributes */

enum {
    FL_FULLBORDER = 1,      /* normal                                  */
    FL_TRANSIENT,           /* set TRANSIENT_FOR property              */
    FL_NOBORDER             /* use override_redirect to supress decor. */
 };

/* All box types */

typedef enum {
    FL_NO_BOX,                /*  0 */
    FL_UP_BOX,                /*  1 */
    FL_DOWN_BOX,              /*  2 */
    FL_BORDER_BOX,            /*  3 */
    FL_SHADOW_BOX,            /*  4 */
    FL_FRAME_BOX,             /*  5 */
    FL_ROUNDED_BOX,           /*  6 */
    FL_EMBOSSED_BOX,          /*  7 */
    FL_FLAT_BOX,              /*  8 */
    FL_RFLAT_BOX,             /*  9 */
    FL_RSHADOW_BOX,           /* 10 */
    FL_OVAL_BOX,              /* 11 */
    FL_ROUNDED3D_UPBOX,       /* 12 */
    FL_ROUNDED3D_DOWNBOX,     /* 13 */
    FL_OVAL3D_UPBOX,          /* 14 */
    FL_OVAL3D_DOWNBOX,        /* 15 */
    FL_OVAL3D_FRAMEBOX,       /* 16 */
    FL_OVAL3D_EMBOSSEDBOX,    /* 17 */

    /* for internal use only */

    FL_TOPTAB_UPBOX,
    FL_SELECTED_TOPTAB_UPBOX,
    FL_BOTTOMTAB_UPBOX,
    FL_SELECTED_BOTTOMTAB_UPBOX,
 
    FL_MAX_BOX_STYLES               /* sentinel */
} FL_BOX_TYPE;

#define FL_IS_UPBOX( t )    (    ( t ) == FL_UP_BOX           \
                              || ( t ) == FL_OVAL3D_UPBOX     \
                              || ( t ) == FL_ROUNDED3D_UPBOX)

#define FL_IS_DOWNBOX( t )  (    ( t ) == FL_DOWN_BOX          \
                              || ( t ) == FL_OVAL3D_DOWNBOX    \
                              || ( t ) == FL_ROUNDED3D_DOWNBOX)

#define FL_TO_DOWNBOX( t )  ( ( t ) == FL_UP_BOX ? FL_DOWN_BOX:         \
                              ( ( t ) == FL_ROUNDED3D_UPBOX ?           \
                                FL_ROUNDED3D_DOWNBOX:                   \
                                ( ( t ) == FL_OVAL3D_UPBOX ?            \
                                  FL_OVAL3D_DOWNBOX : ( t ) ) ) )

/* How to place text relative to a box */

typedef enum {
	FL_ALIGN_CENTER,
    FL_ALIGN_TOP          = 1,
    FL_ALIGN_BOTTOM       = 2,
    FL_ALIGN_LEFT         = 4,
    FL_ALIGN_RIGHT        = 8,
    FL_ALIGN_LEFT_TOP     = ( FL_ALIGN_TOP    | FL_ALIGN_LEFT  ),
    FL_ALIGN_RIGHT_TOP    = ( FL_ALIGN_TOP    | FL_ALIGN_RIGHT ),
    FL_ALIGN_LEFT_BOTTOM  = ( FL_ALIGN_BOTTOM | FL_ALIGN_LEFT  ),
    FL_ALIGN_RIGHT_BOTTOM = ( FL_ALIGN_BOTTOM | FL_ALIGN_RIGHT ),
    FL_ALIGN_INSIDE       = ( 1 << 13 ),
    FL_ALIGN_VERT         = ( 1 << 14 ),    /* not functional yet  */

    /* the rest is for backward compatibility only, don't use! */

    FL_ALIGN_TOP_LEFT     = FL_ALIGN_LEFT_TOP,
    FL_ALIGN_TOP_RIGHT    = FL_ALIGN_RIGHT_TOP,
    FL_ALIGN_BOTTOM_LEFT  = FL_ALIGN_LEFT_BOTTOM,
    FL_ALIGN_BOTTOM_RIGHT = FL_ALIGN_RIGHT_BOTTOM
} FL_ALIGN;


extern  int fl_is_inside_lalign( int align );

extern  int fl_is_outside_lalign( int align );

extern  int fl_is_center_lalign( int align );

extern  int fl_to_inside_lalign( int align );

extern  int fl_to_outside_lalign( int align );

/* Mouse buttons. Don't have to be consecutive */

enum {
    FL_MBUTTON1 = 1,
    FL_MBUTTON2,
    FL_MBUTTON3,
    FL_MBUTTON4,
    FL_MBUTTON5
};

#define FL_LEFT_MOUSE        FL_MBUTTON1
#define FL_MIDDLE_MOUSE      FL_MBUTTON2
#define FL_RIGHT_MOUSE       FL_MBUTTON3
#define FL_SCROLLUP_MOUSE    FL_MBUTTON4
#define FL_SCROLLDOWN_MOUSE  FL_MBUTTON5

#define FL_LEFTMOUSE         FL_LEFT_MOUSE
#define FL_MIDDLEMOUSE       FL_MIDDLE_MOUSE
#define FL_RIGHTMOUSE        FL_RIGHT_MOUSE
#define FL_SCROLLUPMOUSE     FL_SCROLLUP_MOUSE
#define FL_SCROLLDOWNMOUSE   FL_SCROLLDOWN_MOUSE

/* control when to return input, slider and dial etc. object. */

#define FL_RETURN_NONE         0U
#define FL_RETURN_CHANGED      1U
#define FL_RETURN_END          2U
#define FL_RETURN_END_CHANGED  4U
#define FL_RETURN_SELECTION    8U
#define FL_RETURN_DESELECTION  16U
#define FL_RETURN_TRIGGERED    1024U
#define FL_RETURN_ALWAYS       ( ~ FL_RETURN_END_CHANGED )


/*  Some special color indices for FL private colormap. It does not matter
 *  what the value of each enum is, but it must start from 0 and be
 *  consecutive. */

typedef enum {
    FL_BLACK,
	FL_RED,
	FL_GREEN,
	FL_YELLOW,
    FL_BLUE,
	FL_MAGENTA,
	FL_CYAN,
	FL_WHITE,
    FL_TOMATO,
	FL_INDIANRED,
	FL_SLATEBLUE,
    FL_COL1,
	FL_RIGHT_BCOL,
	FL_BOTTOM_BCOL,
	FL_TOP_BCOL,
	FL_LEFT_BCOL,
    FL_MCOL,
    FL_INACTIVE,
	FL_PALEGREEN,
	FL_DARKGOLD,
    FL_ORCHID,
	FL_DARKCYAN,
	FL_DARKTOMATO,
	FL_WHEAT,
	FL_DARKORANGE,
    FL_DEEPPINK,
	FL_CHARTREUSE,
	FL_DARKVIOLET,
	FL_SPRINGGREEN,
    FL_DODGERBLUE,
	FL_LIGHTER_COL1,
	FL_DARKER_COL1,
	FL_ALICEBLUE,
	FL_ANTIQUEWHITE,
	FL_AQUA,
	FL_AQUAMARINE,
	FL_AZURE,
	FL_BEIGE,
	FL_BISQUE,
	FL_BLANCHEDALMOND,
	FL_BLUEVIOLET,
	FL_BROWN,
	FL_BURLYWOOD,
	FL_CADETBLUE,
	FL_CHOCOLATE,
	FL_CORAL,
	FL_CORNFLOWERBLUE,
	FL_CORNSILK,
	FL_CRIMSON,
	FL_DARKBLUE,
	FL_DARKGOLDENROD,
	FL_DARKGRAY,
	FL_DARKGREEN,
	FL_DARKGREY,
	FL_DARKKHAKI,
	FL_DARKMAGENTA,
	FL_DARKOLIVEGREEN,
	FL_DARKORCHID,
	FL_DARKRED,
	FL_DARKSALMON,
	FL_DARKSEAGREEN,
	FL_DARKSLATEBLUE,
	FL_DARKSLATEGRAY,
	FL_DARKSLATEGREY,
	FL_DARKTURQUOISE,
	FL_DEEPSKYBLUE,
	FL_DIMGRAY,
	FL_DIMGREY,
	FL_FIREBRICK,
	FL_FLORALWHITE,
	FL_FORESTGREEN,
	FL_FUCHSIA,
	FL_GAINSBORO,
	FL_GHOSTWHITE,
	FL_GOLD,
	FL_GOLDENROD,
	FL_GRAY,
	FL_GREENYELLOW,
	FL_GREY,
	FL_HONEYDEW,
	FL_HOTPINK,
	FL_INDIGO,
	FL_IVORY,
	FL_KHAKI,
	FL_LAVENDER,
	FL_LAVENDERBLUSH,
	FL_LAWNGREEN,
	FL_LEMONCHIFFON,
	FL_LIGHTBLUE,
	FL_LIGHTCORAL,
	FL_LIGHTCYAN,
	FL_LIGHTGOLDENRODYELLOW,
	FL_LIGHTGRAY,
	FL_LIGHTGREEN,
	FL_LIGHTGREY,
	FL_LIGHTPINK,
	FL_LIGHTSALMON,
	FL_LIGHTSEAGREEN,
	FL_LIGHTSKYBLUE,
	FL_LIGHTSLATEGRAY,
	FL_LIGHTSLATEGREY,
	FL_LIGHTSTEELBLUE,
	FL_LIGHTYELLOW,
	FL_LIME,
	FL_LIMEGREEN,
	FL_LINEN,
	FL_MAROON,
	FL_MEDIUMAQUAMARINE,
	FL_MEDIUMBLUE,
	FL_MEDIUMORCHID,
	FL_MEDIUMPURPLE,
	FL_MEDIUMSEAGREEN,
	FL_MEDIUMSLATEBLUE,
	FL_MEDIUMSPRINGGREEN,
	FL_MEDIUMTURQUOISE,
	FL_MEDIUMVIOLETRED,
	FL_MIDNIGHTBLUE,
	FL_MINTCREAM,
	FL_MISTYROSE,
	FL_MOCCASIN,
	FL_NAVAJOWHITE,
	FL_NAVY,
	FL_OLDLACE,
	FL_OLIVE,
	FL_OLIVEDRAB,
	FL_ORANGE,
	FL_ORANGERED,
	FL_PALEGOLDENROD,
	FL_PALETURQUOISE,
	FL_PALEVIOLETRED,
	FL_PAPAYAWHIP,
	FL_PEACHPUFF,
	FL_PERU,
	FL_PINK,
	FL_PLUM,
	FL_POWDERBLUE,
	FL_PURPLE,
	FL_ROSYBROWN,
	FL_ROYALBLUE,
	FL_SADDLEBROWN,
	FL_SALMON,
	FL_SANDYBROWN,
	FL_SEAGREEN,
	FL_SEASHELL,
	FL_SIENNA,
	FL_SILVER,
	FL_SKYBLUE,
	FL_SLATEGRAY,
	FL_SLATEGREY,
	FL_SNOW,
	FL_STEELBLUE,
	FL_TAN,
	FL_TEAL,
	FL_THISTLE,
	FL_TURQUOISE,
	FL_VIOLET,
	FL_WHITESMOKE,
	FL_YELLOWGREEN,
    FL_FREE_COL1 = 256,
    FL_FREE_COL2,
    FL_FREE_COL3,
    FL_FREE_COL4,
    FL_FREE_COL5,
    FL_FREE_COL6,
    FL_FREE_COL7,
    FL_FREE_COL8,
    FL_FREE_COL9,
    FL_FREE_COL10,
    FL_FREE_COL11,
    FL_FREE_COL12,
    FL_FREE_COL13,
    FL_FREE_COL14,
    FL_FREE_COL15,
    FL_FREE_COL16,
    FL_NOCOLOR = 2147483647  
} FL_PD_COL;


#define FL_BUILT_IN_COLS  ( FL_YELLOWGREEN + 1 )
#define FL_INACTIVE_COL   FL_INACTIVE

/* Some aliases for a number of colors */

#define FL_GRAY16           FL_RIGHT_BCOL
#define FL_GRAY35           FL_BOTTOM_BCOL
#define FL_GRAY80           FL_TOP_BCOL
#define FL_GRAY90           FL_LEFT_BCOL
#define FL_GRAY63           FL_COL1
#define FL_GRAY75           FL_MCOL
#define FL_LCOL             FL_BLACK
#define FL_NoColor          FL_NOCOLOR

/* An alias probably for an earlier typo */

#define FL_DOGERBLUE        FL_DODGERBLUE

/* Events that a form reacts to  */

typedef enum {
    FL_NOEVENT,                /*  0 No event */
    FL_DRAW,                   /*  1 object is asked to redraw itself */
    FL_PUSH,                   /*  2 mouse button was pressed on the object */
    FL_RELEASE,                /*  3 mouse button was release gain */
    FL_ENTER,                  /*  4 mouse entered the object */
    FL_LEAVE,                  /*  5 mouse left the object */
    FL_MOTION,                 /*  6 mouse motion over the object happend */
    FL_FOCUS,                  /*  7 object obtained focus */
    FL_UNFOCUS,                /*  8 object lost focus */
    FL_KEYPRESS,               /*  9 key was pressed while object has focus */
    FL_UPDATE,                 /* 10 for objects that need to update something
                                     from time to time */
    FL_STEP,                   /* 11 */
    FL_SHORTCUT,               /* 12 */
    FL_FREEMEM,                /* 13 object is asked to free all its memory */
    FL_OTHER,                  /* 14 property, selection etc */
    FL_DRAWLABEL,              /* 15 */
    FL_DBLCLICK,               /* 16 double click on object */
    FL_TRPLCLICK,              /* 17 triple click on object */
    FL_ATTRIB,                 /* 18 an object attribute changed */
    FL_KEYRELEASE,             /* 19 key was released while object has focus */
    FL_PS,                     /* 20 dump a form into EPS      */
    FL_MOVEORIGIN,             /* 21 dragging the form across the screen
                                     changes its absolute x,y coords. Objects
                                     that themselves contain forms should
                                     ensure that they are up to date. */
    FL_RESIZED,                /* 22 the object has been resized by scale_form
                                     Tell it that this has happened so that
                                     it can resize any FL_FORMs that it
                                     contains. */
	FL_PASTE,                  /* 23 text was pasted into input object */
	FL_TRIGGER,                /* 24 result of fl_trigger_object() */

	/* The following are only for backward compatibility, not used anymore */

	FL_MOVE      = FL_MOTION,
    FL_KEYBOARD  = FL_KEYPRESS,
    FL_MOUSE     = FL_UPDATE
} FL_EVENTS;


/* Resize policies */

typedef enum {
    FL_RESIZE_NONE,
    FL_RESIZE_X,
    FL_RESIZE_Y,
    FL_RESIZE_ALL = ( FL_RESIZE_X | FL_RESIZE_Y )
} FL_RESIZE_T;


/* Keyboard focus control */

typedef enum {
    FL_KEY_NORMAL  = 1,     /* normal keys(0-255) - tab +left/right */
    FL_KEY_TAB     = 2,     /* normal keys + 4 direction cursor     */
    FL_KEY_SPECIAL = 4,     /* only needs special keys (>255)       */
    FL_KEY_ALL     = 7      /* all keys                             */
} FL_KEY;

#define FL_ALT_MASK      ( 1L << 25 )   /* alt + Key --> FL_ALT_MASK + key */
#define FL_CONTROL_MASK  ( 1L << 26 )
#define FL_SHIFT_MASK    ( 1L << 27 )
#define FL_ALT_VAL       FL_ALT_MASK    /* Don' use! */

#define MAX_SHORTCUTS    8

/* Pop-up menu item attributes. NOTE if more than 8, need to change
 * choice and menu class where mode is kept by a single byte */

enum {
    FL_PUP_NONE,
    FL_PUP_GREY  = 1,
    FL_PUP_BOX   = 2,
    FL_PUP_CHECK = 4,
    FL_PUP_RADIO = 8
};

#define FL_PUP_GRAY      FL_PUP_GREY
#define FL_PUP_TOGGLE    FL_PUP_BOX        /* not used anymore */
#define FL_PUP_INACTIVE  FL_PUP_GREY

/* Popup and menu entries */

typedef int ( * FL_PUP_CB )( int );        /* callback prototype  */

typedef struct {
    const char * text;           /* label of a popup/menu item   */
    FL_PUP_CB    callback;       /* the callback function        */
    const char * shortcut;       /* hotkeys                      */
    int          mode;           /* FL_PUP_GRAY, FL_PUP_CHECK etc */
} FL_PUP_ENTRY;

#define FL_MENU_ENTRY  FL_PUP_ENTRY

/*******************************************************************
 * FONTS
 ******************************************************************/

#define FL_MAXFONTS     48  /* max number of fonts */

typedef enum {
    FL_INVALID_STYLE = -1,
    FL_NORMAL_STYLE,
    FL_BOLD_STYLE,
    FL_ITALIC_STYLE,
    FL_BOLDITALIC_STYLE,

    FL_FIXED_STYLE,
    FL_FIXEDBOLD_STYLE,
    FL_FIXEDITALIC_STYLE,
    FL_FIXEDBOLDITALIC_STYLE,

    FL_TIMES_STYLE,
    FL_TIMESBOLD_STYLE,
    FL_TIMESITALIC_STYLE,
    FL_TIMESBOLDITALIC_STYLE,

    FL_MISC_STYLE,
    FL_MISCBOLD_STYLE,
    FL_MISCITALIC_STYLE,
    FL_SYMBOL_STYLE,

    /* modfier masks. Need to fit a short  */

    FL_SHADOW_STYLE   = ( 1 <<  9 ),
    FL_ENGRAVED_STYLE = ( 1 << 10 ),
    FL_EMBOSSED_STYLE = ( 1 << 11 )
} FL_TEXT_STYLE;

#define FL_FONT_STYLE FL_TEXT_STYLE

#define special_style( a )  (    ( a ) >= FL_SHADOW_STYLE                     \
                              && ( a ) <= ( FL_EMBOSSED_STYLE + FL_MAXFONTS ) )

/* Standard sizes in XForms */

#define FL_TINY_SIZE        8
#define FL_SMALL_SIZE      10
#define FL_NORMAL_SIZE     12
#define FL_MEDIUM_SIZE     14
#define FL_LARGE_SIZE      18
#define FL_HUGE_SIZE       24

#define FL_DEFAULT_SIZE   FL_SMALL_SIZE

/* Defines for compatibility */

#define FL_TINY_FONT      FL_TINY_SIZE
#define FL_SMALL_FONT     FL_SMALL_SIZE
#define FL_NORMAL_FONT    FL_NORMAL_SIZE
#define FL_MEDIUM_FONT    FL_MEDIUM_SIZE
#define FL_LARGE_FONT     FL_LARGE_SIZE
#define FL_HUGE_FONT      FL_HUGE_SIZE

#define FL_NORMAL_FONT1   FL_SMALL_FONT
#define FL_NORMAL_FONT2   FL_NORMAL_FONT
#define FL_DEFAULT_FONT   FL_SMALL_FONT

#define FL_BOUND_WIDTH  ( FL_Coord ) 1     /* Border width of boxes */

/* Definition of basic struct that holds an object */

#define  FL_CLICK_TIMEOUT  400  /* double click interval */

typedef struct FL_FORM_    FL_FORM;
typedef struct FL_OBJECT_  FL_OBJECT;
typedef struct FL_pixmap_  FL_pixmap;

struct FL_OBJECT_ {
    FL_FORM        * form;           /* the form this object belongs to */
    void           * u_vdata;        /* anything the user likes */
    char           * u_cdata;        /* anything the user likes */
    long             u_ldata;        /* anything the user likes */

    int              objclass;       /* class of object, button, slider etc */
    int              type;           /* type within the class */
    int              boxtype;        /* what kind of box type */
    FL_Coord         x,              /* current obj. location and size */
                     y,
                     w,
                     h;
    double           fl1,            /* distances of upper left hand (1) and */
                     fr1,            /* lower right hand corner (2) to left, */
                     ft1,            /* right, top and bottom of enclosing   */
                     fb1,            /* form */
                     fl2,
                     fr2,
                     ft2,
                     fb2;
    FL_Coord         bw;
    FL_COLOR         col1,           /* colors of obj */
                     col2;
    char           * label;          /* object label */
    FL_COLOR         lcol;           /* label color */
    int              align;
    int              lsize,          /* label size and style */
                     lstyle;
    long           * shortcut;
    int              ( * handle )( FL_OBJECT *,
                                   int,
                                   FL_Coord,
                                   FL_Coord,
                                   int,
                                   void * );
    void             ( * object_callback )( FL_OBJECT *,
                                            long );
    long             argument;
    void           * spec;           /* instantiation */

    int              ( * prehandle )( FL_OBJECT *,
                                      int,
                                      FL_Coord,
                                      FL_Coord,
                                      int,
                                      void * );
    int              ( * posthandle )( FL_OBJECT *,
                                       int,
                                       FL_Coord,
                                       FL_Coord,
                                       int,
                                       void * );
    void             ( * set_return )( FL_OBJECT *,
                                       unsigned int );

    /* Re-configure preference */

    unsigned int     resize;         /* what to do if WM resizes the FORM     */
    unsigned int     nwgravity;      /* how to re-position top-left corner    */
    unsigned int     segravity;      /* how to re-position lower-right corner */

    FL_OBJECT      * prev;           /* prev. obj in form */
    FL_OBJECT      * next;           /* next. obj in form */

    FL_OBJECT      * parent;
    FL_OBJECT      * child;
    FL_OBJECT      * nc;             /* next child */

    FL_pixmap      * flpixmap;       /* pixmap double buffering stateinfo */
    int              use_pixmap;     /* true to use pixmap double buffering*/

    /* Some interaction flags */

    int              returned;       /* what last interaction returned */
    unsigned int     how_return;     /* under which conditions to return */
    int              double_buffer;  /* only used by mesa/gl canvas */
    int              pushed;
    int              focus;
    int              belowmouse;
    int              active;         /* if object accepts events */
    int              input;
    int              wantkey;
    int              radio;
    int              automatic;
    int              redraw;
    int              visible;
    int              is_under;       /* if (partially) hidden by other object */
    int              clip;
    unsigned long    click_timeout;
    void           * c_vdata;        /* for class use */
    char           * c_cdata;        /* for class use */
    long             c_ldata;        /* for class use */
    FL_COLOR         dbl_background; /* double buffer background */
    char           * tooltip;
    int              tipID;
    int              group_id;
    int              want_motion;
    int              want_update;
};


/* Callback function for an entire form */

typedef void ( * FL_FORMCALLBACKPTR )( FL_OBJECT *,
                                       void * );
/* Object callback function      */

typedef void ( * FL_CALLBACKPTR )( FL_OBJECT *,
                                   long );

/* Preemptive callback function  */

typedef int ( * FL_RAW_CALLBACK )( FL_FORM *,
                                   void * );

/* At close (WM menu delete/close etc.) function */

typedef int ( * FL_FORM_ATCLOSE )( FL_FORM *,
                                   void * );
/* Deactivate/activate callback */

typedef void ( * FL_FORM_ATDEACTIVATE )( FL_FORM *,
                                         void * );
typedef void ( * FL_FORM_ATACTIVATE )( FL_FORM *,
                                       void * );

typedef int ( * FL_HANDLEPTR )( FL_OBJECT *,
                                int,
                                FL_Coord,
                                FL_Coord,
                                int,
                                void * );

/* Error callback */

typedef void ( * FL_ERROR_FUNC )( const char *,
                                  const char *,
                                  ... );

extern  FL_OBJECT *FL_EVENT;

/*** FORM ****/

/* Form visibility state: form->visible */

enum {
  FL_BEING_HIDDEN = -1,
  FL_HIDDEN       = 0,
  FL_INVISIBLE    = FL_HIDDEN,
  FL_VISIBLE      = 1
};

struct FL_FORM_ {
    void                 * fdui;          /* for fdesign */
    void                 * u_vdata;       /* for application */
    char                 * u_cdata;       /* for application */
    long                   u_ldata;       /* for application */

    char *                 label;         /* window title */
    Window                 window;        /* X resource ID for window */
    FL_Coord               x,             /* current geometry info */
                           y,
                           w,
                           h;
    int                    handle_dec_x,
                           handle_dec_y;
    FL_Coord               hotx,          /* hot-spot of the form */
                           hoty;
    double                 w_hr,          /* high resolution width and height */
                           h_hr;          /* (needed for precise scaling) */

    FL_OBJECT            * first;
    FL_OBJECT            * last;
    FL_OBJECT            * focusobj;

    FL_FORMCALLBACKPTR     form_callback;
    FL_FORM_ATACTIVATE     activate_callback;
    FL_FORM_ATDEACTIVATE   deactivate_callback;
    void                 * form_cb_data;
    void                 * activate_data;
    void                 * deactivate_data;

    FL_RAW_CALLBACK        key_callback;
    FL_RAW_CALLBACK        push_callback;
    FL_RAW_CALLBACK        crossing_callback;
    FL_RAW_CALLBACK        motion_callback;
    FL_RAW_CALLBACK        all_callback;

    unsigned long          compress_mask;
    unsigned long          evmask;

    /* WM_DELETE_WINDOW message handler */

    FL_FORM_ATCLOSE        close_callback;
    void                 * close_data;

    FL_pixmap            * flpixmap;         /* back buffer */

    Pixmap                 icon_pixmap;
    Pixmap                 icon_mask;

    /* Interaction and other flags */

    int                    deactivated;      /* non-zero if deactivated */
    int                    use_pixmap;       /* true if dbl buffering */
    int                    frozen;           /* true if sync change */
    int                    visible;          /* true if mapped */
    int                    wm_border;        /* window manager info */
    unsigned int           prop;             /* other attributes */
    int                    num_auto_objects;
    int                    needs_full_redraw;
    int                    sort_of_modal;    /* internal use */
    FL_FORM              * parent;
    FL_FORM              * child;
    FL_OBJECT            * parent_obj;
    int                    attached;         /* not independent anymore */
    void                   ( * pre_attach )( FL_FORM * );
    void                 * attach_data;
    int                    in_redraw;
};


/* All FD_xxx structure emitted by fdesign contains at least the
 * following */

typedef struct {
    FL_FORM * form;
    void    * vdata;
    char    * cdata;
    long      ldata;
} FD_Any;

/* Async IO stuff */

enum {
    FL_READ   = 1,
    FL_WRITE  = 2,
    FL_EXCEPT = 4
};

/* IO other than XEvent Q */

typedef void ( * FL_IO_CALLBACK )( int,
                                   void * );

extern  void fl_add_io_callback( int              fd,
                                   unsigned int     mask,
                                   FL_IO_CALLBACK   callback,
                                   void           * data );

extern  void fl_remove_io_callback( int            fd,
                                      unsigned int   mask,
                                      FL_IO_CALLBACK cb );

/* signals */

typedef void ( * FL_SIGNAL_HANDLER )( int,
                                      void * );

extern  void fl_add_signal_callback( int                 s,
                                       FL_SIGNAL_HANDLER   cb,
                                       void              * data );

extern  void fl_remove_signal_callback( int s );

extern  void fl_signal_caught( int s );

extern  void fl_app_signal_direct( int y );


enum {
	FL_INPUT_END_EVENT_CLASSIC = 0,
	FL_INPUT_END_EVENT_ALWAYS  = 1
};

extern  int fl_input_end_return_handling( int type );


/* Timeouts */

typedef void (* FL_TIMEOUT_CALLBACK )( int, void * );

extern  int fl_add_timeout( long                  msec,
                              FL_TIMEOUT_CALLBACK   callback,
                              void                * data );

extern  void fl_remove_timeout( int id );

/* Basic public routine prototypes */

extern  int fl_library_version( int * ver,
                                  int * rev );

extern  long fl_library_full_version( int         * version,
										int         * revision,
										int         * fix_level,
										const char ** extra );

/** Generic routines that deal with FORMS **/

extern  FL_FORM * fl_bgn_form( int      type,
                                 FL_Coord w,
                                 FL_Coord h );

extern  void fl_end_form( void );

extern  FL_OBJECT * fl_do_forms( void );

extern  FL_OBJECT * fl_check_forms( void );

extern  FL_OBJECT * fl_do_only_forms( void );

extern  FL_OBJECT * fl_check_only_forms( void );

extern  void fl_freeze_form( FL_FORM * form );

extern  void fl_set_focus_object( FL_FORM   * form,
                                    FL_OBJECT * obj );

extern  FL_OBJECT *fl_get_focus_object( FL_FORM * form );

extern  void fl_reset_focus_object( FL_OBJECT * ob );

#define fl_set_object_focus   fl_set_focus_object

extern  FL_FORM_ATCLOSE fl_set_form_atclose( FL_FORM         * form,
                                               FL_FORM_ATCLOSE   fmclose,
                                               void            * data );

extern  FL_FORM_ATCLOSE fl_set_atclose( FL_FORM_ATCLOSE   fmclose,
                                          void            * data );

extern  FL_FORM_ATACTIVATE fl_set_form_atactivate( FL_FORM            * form,
													 FL_FORM_ATACTIVATE   cb,
													 void               * data );

extern  FL_FORM_ATDEACTIVATE fl_set_form_atdeactivate( FL_FORM              * form,
														 FL_FORM_ATDEACTIVATE   cb,
														 void                 * data );

extern  void fl_unfreeze_form( FL_FORM * form );

extern  int fl_form_is_activated( FL_FORM * form );

extern  void fl_deactivate_form( FL_FORM * form );

extern  void fl_activate_form( FL_FORM * form );

extern  void fl_deactivate_all_forms( void );

extern  void fl_activate_all_forms( void );

extern  void fl_freeze_all_forms( void );

extern  void fl_unfreeze_all_forms( void );

extern  void fl_scale_form( FL_FORM * form,
                              double    xsc,
                              double    ysc );

extern  void fl_set_form_position( FL_FORM  * form,
                                     FL_Coord   x,
                                     FL_Coord   y );

extern  void fl_set_form_title( FL_FORM    * form,
                                  const char * name );

extern  void fl_set_form_title_f( FL_FORM *    form,
									const char * fmt,
									... );

extern  void fl_set_app_mainform( FL_FORM * form );

extern  FL_FORM * fl_get_app_mainform( void );

extern  void fl_set_app_nomainform( int flag );

extern  void fl_set_form_callback( FL_FORM            * form,
                                     FL_FORMCALLBACKPTR   callback,
                                     void               * d );

#define  fl_set_form_call_back    fl_set_form_callback

extern  void fl_set_form_size( FL_FORM  * form,
                                 FL_Coord   w,
                                 FL_Coord   h );

extern  void fl_set_form_background_color( FL_FORM * form,
											 FL_COLOR  color );

extern  FL_COLOR fl_get_form_background_color( FL_FORM * form );

extern  void fl_set_form_hotspot( FL_FORM  * form,
                                    FL_Coord   x,
                                    FL_Coord   y );

extern  void fl_set_form_hotobject( FL_FORM   * form,
                                      FL_OBJECT * ob );

extern  void fl_set_form_minsize( FL_FORM  * form,
                                    FL_Coord   w,
                                    FL_Coord   h );

extern  void fl_set_form_maxsize( FL_FORM  * form,
                                    FL_Coord   w,
                                    FL_Coord   h );

extern  void fl_set_form_event_cmask( FL_FORM       * form,
                                        unsigned long   cmask );

extern  unsigned long fl_get_form_event_cmask( FL_FORM * form );

extern  void fl_set_form_geometry( FL_FORM  * form,
                                     FL_Coord   x,
                                     FL_Coord   y,
                                     FL_Coord   w,
                                     FL_Coord   h );

#define fl_set_initial_placement fl_set_form_geometry

extern  Window fl_show_form( FL_FORM    * form,
                               int          place,
                               int          border,
                               const char * name );

extern  Window fl_show_form_f( FL_FORM    * form,
								 int          place,
								 int          border,
								 const char * fmt,
								 ... );

extern  void fl_hide_form( FL_FORM * form );

extern  void fl_free_form( FL_FORM * form );

extern  void fl_redraw_form( FL_FORM * form );

extern  void fl_set_form_dblbuffer( FL_FORM * form,
                                      int       y );

extern  Window fl_prepare_form_window( FL_FORM    * form,
                                         int          place,
                                         int          border,
                                         const char * name );

extern  Window fl_prepare_form_window_f( FL_FORM    * form,
										   int          place,
										   int          border,
										   const char * fmt,
										   ... );

extern  Window fl_show_form_window( FL_FORM * form );

extern  double fl_adjust_form_size( FL_FORM * form );

extern  int fl_form_is_visible( FL_FORM * form );

extern  int fl_form_is_iconified( FL_FORM * form );

extern  FL_RAW_CALLBACK fl_register_raw_callback( FL_FORM         * form,
                                                    unsigned long     mask,
                                                    FL_RAW_CALLBACK   rcb );

#define fl_register_call_back fl_register_raw_callback

extern  FL_OBJECT * fl_bgn_group( void );

extern  void fl_end_group( void );

extern  FL_OBJECT *fl_addto_group( FL_OBJECT * group );


/****** Routines that deal with FL_OBJECTS ********/

extern  int fl_get_object_objclass( FL_OBJECT * obj );

extern  int fl_get_object_type( FL_OBJECT * obj );

extern  void fl_set_object_boxtype( FL_OBJECT * ob,
                                      int         boxtype );

extern  int fl_get_object_boxtype( FL_OBJECT * obj );

extern  void fl_set_object_bw( FL_OBJECT * ob,
                                 int         bw );

extern  int fl_get_object_bw( FL_OBJECT * ob );

extern  void fl_set_object_resize( FL_OBJECT    * ob,
                                     unsigned int   what );

extern  void fl_get_object_resize( FL_OBJECT    * ob,
                                     unsigned int * what );

extern  void fl_set_object_gravity( FL_OBJECT    * ob,
                                      unsigned int   nw,
                                      unsigned int   se );

extern  void fl_get_object_gravity( FL_OBJECT    * ob,
                                      unsigned int * nw,
                                      unsigned int * se );

extern  void fl_set_object_lsize( FL_OBJECT * obj,
                                    int         lsize );

extern  int fl_get_object_lsize( FL_OBJECT * obj );


extern  void fl_set_object_lstyle( FL_OBJECT * obj,
                                     int         lstyle );

extern  int fl_get_object_lstyle( FL_OBJECT * obj );

extern  void fl_set_object_lcol( FL_OBJECT * ob,
								   FL_COLOR    lcol );

extern  FL_COLOR fl_get_object_lcol( FL_OBJECT * obj );

extern  int fl_set_object_return( FL_OBJECT    * ob,
                                    unsigned int   when );

extern  void fl_set_object_lalign( FL_OBJECT * obj,
                                     int         align );

extern  int fl_get_object_lalign( FL_OBJECT * obj );

extern  void fl_set_object_shortcut( FL_OBJECT  * obj,
                                       const char * sstr,
                                       int          showit );

extern  void fl_set_object_shortcutkey( FL_OBJECT    * obj,
                                          unsigned int   keysym );

extern  void fl_set_object_dblbuffer( FL_OBJECT * ob,
                                        int         y );

extern  void fl_set_object_color( FL_OBJECT * ob,
                                    FL_COLOR    col1,
                                    FL_COLOR    col2 );

extern  void fl_get_object_color( FL_OBJECT * obj,
									FL_COLOR  * col1,
									FL_COLOR  * col2 );

extern  void fl_set_object_label( FL_OBJECT  * ob,
                                    const char * label );

extern  void fl_set_object_label_f( FL_OBJECT  * obj,
									  const char * fmt,
									  ... );

extern  const char * fl_get_object_label( FL_OBJECT * obj );

extern  void fl_set_object_helper( FL_OBJECT  * ob,
                                     const char * tip );

extern  void fl_set_object_helper_f( FL_OBJECT  * ob,
									   const char * fmt,
									   ... );

extern  void fl_set_object_position( FL_OBJECT * obj,
                                       FL_Coord    x,
                                       FL_Coord    y );

extern  void fl_get_object_size( FL_OBJECT * obj,
                                   FL_Coord  * w,
                                   FL_Coord  * h );

extern  void fl_set_object_size( FL_OBJECT * obj,
                                   FL_Coord    w,
                                   FL_Coord    h );

extern  void fl_set_object_automatic( FL_OBJECT * obj,
                                        int         flag );

extern  int fl_object_is_automatic( FL_OBJECT * obj );

extern  void fl_draw_object_label( FL_OBJECT * ob );

extern  void fl_draw_object_label_outside( FL_OBJECT * ob );

extern  FL_OBJECT * fl_get_object_component( FL_OBJECT * composite,
                                               int          objclass,
                                               int          type,
                                               int          numb );

extern  void fl_for_all_objects( FL_FORM * form,
                                   int       ( * cb )( FL_OBJECT *, void * ),
                                   void    * v );

#define fl_draw_object_outside_label fl_draw_object_label_outside

extern  void fl_set_object_dblclick( FL_OBJECT     * obj,
									   unsigned long   timeout );

extern  unsigned long fl_get_object_dblclick( FL_OBJECT * obj );

extern  void fl_set_object_geometry( FL_OBJECT * obj,
                                       FL_Coord    x,
                                       FL_Coord    y,
                                       FL_Coord    w,
                                       FL_Coord    h );

extern  void fl_move_object( FL_OBJECT * obj,
                               FL_Coord    dx,
                               FL_Coord    dy );

#define fl_set_object_lcolor  fl_set_object_lcol
#define fl_get_object_lcolor  fl_get_object_lcol

extern  void fl_fit_object_label( FL_OBJECT * obj,
                                    FL_Coord    xmargin,
                                    FL_Coord    ymargin );

extern  void fl_get_object_geometry( FL_OBJECT * ob,
                                       FL_Coord  *  x,
                                       FL_Coord  *  y,
                                       FL_Coord  *  w,
                                       FL_Coord  *  h );

extern  void fl_get_object_position( FL_OBJECT * ob,
                                       FL_Coord  * x,
                                       FL_Coord  * y );

/* This one takes into account the label */

extern  void fl_get_object_bbox( FL_OBJECT * obj,
                                   FL_Coord  * x,
                                   FL_Coord  * y,
                                   FL_Coord  * w,
                                   FL_Coord  * h );

#define fl_compute_object_geometry   fl_get_object_bbox

extern  void fl_call_object_callback( FL_OBJECT * ob );

extern  FL_HANDLEPTR fl_set_object_prehandler( FL_OBJECT    * ob,
                                                 FL_HANDLEPTR   phandler );

extern  FL_HANDLEPTR fl_set_object_posthandler( FL_OBJECT    * ob,
                                                  FL_HANDLEPTR   post );

extern  FL_CALLBACKPTR fl_set_object_callback( FL_OBJECT      * obj,
                                                 FL_CALLBACKPTR   callback,
                                                 long             argument );

#define fl_set_object_align   fl_set_object_lalign
#define fl_set_call_back      fl_set_object_callback

extern  void fl_redraw_object( FL_OBJECT * obj );

extern  void fl_show_object( FL_OBJECT * ob );

extern  void fl_hide_object( FL_OBJECT * ob );

extern  int fl_object_is_visible( FL_OBJECT * obj );

extern  void fl_free_object( FL_OBJECT * obj );

extern  void fl_delete_object( FL_OBJECT * obj );

extern  int fl_get_object_return_state( FL_OBJECT *obj );

extern  void fl_trigger_object( FL_OBJECT * obj );

extern  void fl_activate_object( FL_OBJECT * ob );

extern  void fl_deactivate_object( FL_OBJECT * ob );

extern  int fl_object_is_active( FL_OBJECT * obj );

extern  int fl_enumerate_fonts( void ( * output )( const char * s ),
                                  int  shortform );

extern  int fl_set_font_name( int          n,
                                const char * name );

extern  int fl_set_font_name_f( int          n,
								  const char * fmt,
								  ... );

extern  void fl_set_font( int numb,
                            int size );

/* Routines that facilitate free object */

extern  int fl_get_char_height( int   style,
                                  int   size,
                                  int * asc,
                                  int * desc );

extern  int fl_get_char_width( int style,
                                 int size );

extern  int fl_get_string_height( int          style,
                                    int          size,
                                    const char * s,
                                    int          len,
                                    int        * asc,
                                    int        * desc );

extern  int fl_get_string_width( int          style,
                                   int          size,
                                   const char * s,
                                   int          len );

extern  int fl_get_string_widthTAB( int          style,
                                      int          size,
                                      const char * s,
                                      int          len );

extern  void fl_get_string_dimension( int          fntstyle,
                                        int          fntsize,
                                        const char * s,
                                        int          len,
                                        int        * width,
                                        int        * height );

#define fl_get_string_size  fl_get_string_dimension

extern  void fl_get_align_xy( int   align,
                                int   x,
                                int   y,
                                int   w,
                                int   h,
                                int   xsize,
                                int   ysize,
                                int   xoff,
                                int   yoff,
                                int * xx,
                                int * yy );

extern  int fl_get_label_char_at_mouse( FL_OBJECT * obj );

extern  void fl_drw_text( int          align,
                            FL_Coord     x,
                            FL_Coord     y,
                            FL_Coord     w,
                            FL_Coord     h,
                            FL_COLOR     c,
                            int          style,
                            int          size,
                            const char * istr );

extern  void fl_drw_text_beside( int          align,
                                   FL_Coord     x,
                                   FL_Coord     y,
                                   FL_Coord     w,
                                   FL_Coord     h,
                                   FL_COLOR     c,
                                   int          style,
                                   int          size,
                                   const char * str );

extern  void fl_drw_text_cursor( int          align,
                                   FL_Coord     x,
                                   FL_Coord     y,
                                   FL_Coord     w,
                                   FL_Coord     h,
                                   FL_COLOR     c,
                                   int          style,
                                   int          size,
                                   const char * str,
                                   int          cc,
                                   int          pos );

extern  void fl_drw_box( int      style,
                           FL_Coord x,
                           FL_Coord y,
                           FL_Coord w,
                           FL_Coord h,
                           FL_COLOR c,
                           int      bw_in );

typedef void ( * FL_DRAWPTR )( FL_Coord,
                               FL_Coord,
                               FL_Coord,
                               FL_Coord,
                               int,
                               FL_COLOR);

extern  int fl_add_symbol( const char * name,
                             FL_DRAWPTR   drawit,
                             int          scalable );

extern  int fl_delete_symbol( const char * name );

extern  int fl_draw_symbol( const char * label,
                              FL_Coord     x,
                              FL_Coord     y,
                              FL_Coord     w,
                              FL_Coord     h,
                              FL_COLOR     col );

extern  unsigned long fl_mapcolor( FL_COLOR col,
                                     int      r,
                                     int      g,
                                     int      b );

extern  long fl_mapcolorname( FL_COLOR     col,
                                const char * name );

#define fl_mapcolor_name  fl_mapcolorname

extern  void fl_free_colors( FL_COLOR * c,
                               int        n );

extern  void fl_free_pixels( unsigned long * pix,
                               int             n );

extern  void fl_set_color_leak( int y );

extern  unsigned long fl_getmcolor( FL_COLOR   i,
                                      int      * r,
                                      int      * g,
                                      int      * b );

extern  unsigned long fl_get_pixel( FL_COLOR col );

#define fl_get_flcolor   fl_get_pixel

extern  void fl_get_icm_color( FL_COLOR   col,
                                 int      * r,
                                 int      * g,
                                 int      * b );

extern  void fl_set_icm_color( FL_COLOR col,
                                 int      r,
                                 int      g,
                                 int      b );

extern  void fl_color( FL_COLOR col );

extern  void fl_bk_color( FL_COLOR col );

extern  void fl_set_gamma( double r,
                             double g,
                             double b );

extern  void fl_show_errors( int y );

/* Some macros */

#define FL_max( a, b )            ( ( a ) > ( b ) ? ( a ) : ( b ) )
#define FL_min( a, b )            ( ( a ) < ( b ) ? ( a ) : ( b ) )
#define FL_abs( a )               ( ( a ) > 0 ? ( a ) : ( - ( a ) ) )
#define FL_nint( a )              ( ( int ) ( ( a ) > 0 ?               \
                                              ( ( a ) + 0.5 ) :         \
                                              ( ( a ) - 0.5 ) ) )
#define FL_clamp( a, amin, amax ) ( ( a ) < ( amin ) ?                  \
                                    ( amin ) : ( ( a ) > ( amax ) ?     \
                                                 ( amax ) : ( a ) ) )
#define FL_crnd( a )              ( ( FL_Coord ) ( ( a ) > 0 ?          \
                                                   ( ( a ) + 0.5 ) :    \
                                                   ( ( a ) - 0.5 ) ) )

typedef int ( * FL_FSCB )( const char *,
                           void * );

/* Utilities for new objects */

extern  FL_FORM *fl_current_form;

extern  void fl_add_object( FL_FORM   * form,
                              FL_OBJECT * obj );

extern  FL_FORM *fl_addto_form( FL_FORM * form );

extern  FL_OBJECT * fl_make_object( int            objclass,
                                      int            type,
                                      FL_Coord       x,
                                      FL_Coord       y,
                                      FL_Coord       w,
                                      FL_Coord       h,
                                      const char   * label,
                                      FL_HANDLEPTR   handle );

extern  void fl_add_child( FL_OBJECT *,
                             FL_OBJECT * );

extern  void fl_set_coordunit( int u );

extern  void fl_set_border_width( int bw );

extern  void fl_set_scrollbar_type( int t );

#define fl_set_thinscrollbar( t )                                        \
    fl_set_scrollbar_type( t ? FL_THIN_SCROLLBAR : FL_NORMAL_SCROLLBAR )

extern  void fl_flip_yorigin( void );

extern  int fl_get_coordunit( void );

extern  int fl_get_border_width( void );

/* Misc. routines */

extern  void fl_ringbell( int percent );

extern  void fl_gettime( long * sec,
                           long * usec );

extern  const char * fl_now( void );

extern  const char * fl_whoami( void );

extern  long fl_mouse_button( void );

extern  int fl_current_event( void );

extern  char * fl_strdup( const char * s );

extern  void fl_set_err_logfp( FILE * fp );

extern  void fl_set_error_handler( FL_ERROR_FUNC user_func );

extern  char ** fl_get_cmdline_args( int * );

/* This function was called 'fl_set_error_logfp/' in XForms 0.89. */

#define fl_set_error_logfp fl_set_err_logfp

#define fl_mousebutton fl_mouse_button

/* These give more flexibility for future changes. Also application
 * can re-assign these pointers to whatever function it wants, e.g.,
 * to a shared memory pool allocator. */

extern  void ( * fl_free )( void * );

extern  void * ( * fl_malloc )( size_t );

extern  void * ( * fl_calloc )( size_t,
                                  size_t );

extern  void * ( * fl_realloc )( void *,
                                   size_t );

extern  int fl_msleep( unsigned long msec );

#define FL_MAX_MENU_CHOICE_ITEMS   128

typedef const char * ( * FL_VAL_FILTER )( FL_OBJECT *,
                                          double,
                                          int );

extern  int fl_is_same_object( FL_OBJECT * obj1,
								 FL_OBJECT * obj2 );

/* ! defined FL_BASIC_H */


/**
 * \file XBasic.h
 *
 *  X Window dependent stuff
 *
 */


#define FL_XBASIC_H

/* Draw mode */

enum {
    FL_XOR  = 0x6 ,
    FL_COPY = 0x3 ,
    FL_AND  = 0x1 
};

#define FL_MINDEPTH  1


/* FL_xxx does not do anything anymore, but kept for compatibility */

enum {
    FL_IllegalVisual = -1,
    FL_StaticGray    = 0 ,
    FL_GrayScale     = 1 ,
    FL_StaticColor   = 2 ,
    FL_PseudoColor   = 3 ,
    FL_TrueColor     = 4 ,
    FL_DirectColor   = 5 ,
    FL_DefaultVisual = 10         /* special request */
};


enum {
    FL_North         = 2 ,
    FL_NorthEast     = 3 ,
    FL_NorthWest     = 1 ,
    FL_South         = 8 ,
    FL_SouthEast     = 9 ,
    FL_SouthWest     = 7 ,
    FL_East          = 6 ,
    FL_West          = 4 ,
    FL_NoGravity     = 0 ,
    FL_ForgetGravity = 0 
};


#define GreyScale   GrayScale
#define StaticGrey  StaticGray


#define FL_is_gray( v )  ( ( v ) == GrayScale || ( v ) == StaticGray )
#define FL_is_rgb( v )   ( ( v ) == TrueColor || ( v ) == DirectColor )


/* Internal colormap size. Not really very meaningful as fl_mapcolor
 * and company allow color "leakage", that is, although only FL_MAX_COLS
 * are kept in the internal colormap, the server might have substantially
 * more colors allocated */

#define FL_MAX_COLORS   1024
#define FL_MAX_COLS     FL_MAX_COLORS


/* FL graphics state information. Some are redundant. */

typedef struct {
    XVisualInfo   * xvinfo;
    XFontStruct   * cur_fnt;            /* current font in default GC */
    Colormap        colormap;           /* colormap valid for xvinfo */
    Window          trailblazer;        /* a valid window for xvinfo */
    int             vclass,             /* visual class and color depth */
                    depth;
    int             rgb_bits;           /* primary color resolution */
    int             dithered;           /* true if dithered color */
    int             pcm;                /* true if colormap is not shared */
    GC              gc[ 16 ];           /* working GC */
    GC              textgc[ 16 ];       /* GC used exclusively for text */
    GC              dimmedGC;           /* A GC having a checkboard stipple */
    unsigned long   lut[ 1024   ]; /* secondary lookup table */
    unsigned int    rshift,
                    rmask,
                    rbits;
    unsigned int    gshift,
                    gmask,
                    gbits;
    unsigned int    bshift,
                    bmask,
                    bbits;
} FL_State;

#define FL_STATE FL_State    /* for compatibility */


/***** Global variables ******/

extern  Display *fl_display;

extern  int fl_screen;

extern  Window fl_root;   /* root window */
extern  Window fl_vroot;  /* virtual root window */
extern  int fl_scrh,      /* screen dimension in pixels */
              fl_scrw;
extern  int fl_vmode;


/* Current version only runs in single visual mode */

#define  fl_get_vclass( )          fl_vmode
#define  fl_get_form_vclass( a )   fl_vmode
#define  fl_get_gc( )              fl_state[ fl_vmode ].gc[ 0 ]

extern  FL_State fl_state[ ];

extern  char *fl_ul_magic_char;

extern  int fl_mode_capable( int mode,
                               int warn );


#define fl_default_win( )       ( fl_state[ fl_vmode ].trailblazer )
#define fl_default_window( )    ( fl_state[ fl_vmode ].trailblazer )


/* All pixmaps used by FL_OBJECT to simulate double buffering have the
 * following entries in the structure. FL_Coord x,y are used to shift
 * the origin of the drawing routines */

struct FL_pixmap_ {
    Pixmap         pixmap;
    Window         win;
    Visual       * visual;
    FL_Coord       x,
                   y,
                   w,
                   h;
    int            depth;
    FL_COLOR       dbl_background;
    FL_COLOR       pixel;
};


/* Fonts related */

#define FL_MAX_FONTSIZES         10
#define FL_MAX_FONTNAME_LENGTH   80

typedef struct {
    XFontStruct * fs[ 10  ];               /* cached fontstruct */
    short         size[ 10  ];             /* cached sizes */
    short         nsize;                                /* cached so far */
    char          fname[ 80  + 1 ];  /* without size info */
} FL_FONT;

/* Some basic drawing routines */

typedef XPoint      FL_POINT;
typedef XRectangle  FL_RECT;

/* Rectangles */

extern  void fl_rectangle( int      fill,
                             FL_Coord x,
                             FL_Coord y,
                             FL_Coord w,
                             FL_Coord h,
                             FL_COLOR col );

extern  void fl_rectbound( FL_Coord x,
                             FL_Coord y,
                             FL_Coord w,
                             FL_Coord h,
                             FL_COLOR col );

#define fl_rectf( x, y, w, h, c)   fl_rectangle( 1, x, y, w, h, c )
#define fl_rect( x, y, w, h, c )   fl_rectangle( 0, x, y, w, h, c )

/* Rectangle with rounded-corners */

extern  void fl_roundrectangle( int      fill,
                                  FL_Coord x,
                                  FL_Coord y,
                                  FL_Coord w,
                                  FL_Coord h,
                                  FL_COLOR col );

#define fl_roundrectf( x, y, w, h, c )  fl_roundrectangle( 1, x, y, w, h, c )
#define fl_roundrect( x, y, w, h, c )   fl_roundrectangle( 0, x, y, w, h, c )

/* General polygon and polylines */

extern  void fl_polygon( int        fill,
                           FL_POINT * xp,
                           int        n,
                           FL_COLOR   col );

#define fl_polyf( p, n, c )       fl_polygon( 1, p, n, c )
#define fl_polyl( p, n, c )       fl_polygon( 0, p, n, c )

#define fl_polybound( p, n, c )               \
    do { fl_polygon( 1, p, n, c );            \
         fl_polygon( 0, p, n, FL_BLACK );     \
       } while( 0 )

extern  void fl_lines( FL_POINT * xp,
                         int        n,
                         FL_COLOR   col );

extern  void fl_line( FL_Coord xi,
                        FL_Coord yi,
                        FL_Coord xf,
                        FL_Coord yf,
                        FL_COLOR c );

extern  void fl_point( FL_Coord x,
                         FL_Coord y,
                         FL_COLOR c );

extern  void fl_points( FL_POINT * p,
                          int        np,
                          FL_COLOR   c );

#define fl_simple_line fl_line

extern  void fl_dashedlinestyle( const char * dash,
                                   int          ndash );

extern  void fl_update_display( int block );


#define fl_diagline( x, y, w, h, c )  \
    fl_line( x, y, ( x ) + ( w ) - 1, ( y ) + ( h ) - 1, c )

/* Line attributes */

enum {
    FL_SOLID          = 0 ,
    FL_USERDASH       = 1 ,
    FL_USERDOUBLEDASH = 2 ,
    FL_DOT,
    FL_DOTDASH,
    FL_DASH,
    FL_LONGDASH
};

extern  void fl_linewidth( int n );

extern  void fl_linestyle( int n );

extern  void fl_drawmode( int request );

extern  int fl_get_linewidth( void );

extern  int fl_get_linestyle( void );

extern  int fl_get_drawmode( void );

#define fl_set_linewidth    fl_linewidth
#define fl_set_linestyle    fl_linestyle
#define fl_set_drawmode     fl_drawmode

/** Ellipses **/

extern  void fl_circ( FL_Coord  x,
                        FL_Coord  y,
                        FL_Coord  r,
                        FL_COLOR col );

extern  void fl_circf( FL_Coord  x,
                         FL_Coord  y,
                         FL_Coord  r,
                         FL_COLOR col );

extern  void fl_circbound( FL_Coord  x,
                             FL_Coord  y,
                             FL_Coord  r,
                             FL_COLOR col );

extern  void fl_oval( int      fill,
                        FL_Coord x,
                        FL_Coord y,
                        FL_Coord w,
                        FL_Coord h,
                        FL_COLOR col );

extern  void fl_ovalbound( FL_Coord x,
                             FL_Coord y,
                             FL_Coord w,
                             FL_Coord h,
                             FL_COLOR col );

extern  void fl_ovalarc( int      fill,
                           FL_Coord x,
                           FL_Coord y,
                           FL_Coord w,
                           FL_Coord h,
                           int      t0,
                           int      dt,
                           FL_COLOR col );

#define fl_ovalf( x, y, w, h, c )     fl_oval( 1, x, y, w, h, c )
#define fl_ovall( x, y, w, h, c )     fl_oval( 0, x, y, w, h, c )
#define fl_oval_bound                 fl_ovalbound

/* Arcs */

extern  void fl_arcf( FL_Coord  x,
                        FL_Coord y,
                        FL_Coord  r,
                        int      a1,
                        int      a2,
                        FL_COLOR col );

extern  void fl_arc( FL_Coord  x,
                       FL_Coord y,
                       FL_Coord  r,
                       int      a1,
                       int      a2,
                       FL_COLOR col );

extern  void fl_pieslice( int      fill,
                            FL_Coord x,
                            FL_Coord y,
                            FL_Coord w,
                            FL_Coord h,
                            int      a1,
                            int      a2,
                            FL_COLOR col );

/* High level drawing routines */

extern  void fl_drw_frame( int      style,
                             FL_Coord x,
                             FL_Coord y,
                             FL_Coord w,
                             FL_Coord h,
                             FL_COLOR c,
                             int      bw );

/*
 * Interfaces
 */

extern  XFontStruct *fl_get_fontstruct( int style,
                                          int size );

#define fl_get_font_struct    fl_get_fontstruct
#define fl_get_fntstruct      fl_get_font_struct

extern  Window fl_get_mouse( FL_Coord  * x,
                               FL_Coord  * y,
                               unsigned int * keymask );

extern  void fl_set_mouse( FL_Coord mx,
                             FL_Coord my );

extern  Window fl_get_win_mouse( Window         win,
                                   FL_Coord     * x,
                                   FL_Coord     * y,
                                   unsigned int * keymask );

extern  Window fl_get_form_mouse( FL_FORM      * fm,
                                    FL_Coord     * x,
                                    FL_Coord     * y,
                                    unsigned int * keymask );

extern  FL_FORM * fl_win_to_form( Window win );

extern  void fl_set_form_icon( FL_FORM * form,
                                 Pixmap   p,
                                 Pixmap   m );

extern  int fl_get_decoration_sizes( FL_FORM * form,
                                       int     * top,
                                       int     * right,
                                       int     * bottom,
                                       int     * left );

extern  void fl_raise_form( FL_FORM * form );

extern  void fl_lower_form( FL_FORM * form );

extern  void fl_set_foreground( GC       gc,
                                  FL_COLOR color );
extern  void fl_set_background( GC       gc,
                                  FL_COLOR color );

/* General windowing support */

extern  Window fl_wincreate( const char * label );

extern  Window fl_winshow( Window win );

extern  Window fl_winopen( const char * label );

extern  void fl_winhide( Window win );

extern  void fl_winclose( Window win );

extern  void fl_winset( Window win );

extern  int fl_winreparent( Window win,
                              Window new_parent );

extern  void fl_winfocus( Window win );

extern  Window fl_winget( void );

extern  int fl_iconify( Window win );

extern  void fl_winresize( Window   win,
                             FL_Coord neww,
                             FL_Coord newh );

extern  void fl_winmove( Window   win,
                           FL_Coord dx,
                           FL_Coord dy );

extern  void fl_winreshape( Window   win,
                              FL_Coord dx,
                              FL_Coord dy,
                              FL_Coord w,
                              FL_Coord h );

extern  void fl_winicon( Window win,
                           Pixmap p,
                           Pixmap m );

extern  void fl_winbackground( Window        win,
                                 unsigned long bk );

extern  void fl_winstepsize( Window   win,
                               FL_Coord dx,
                               FL_Coord dy );

extern  int fl_winisvalid( Window win );

extern  void fl_wintitle( Window       win,
                            const char * title );

extern  void fl_wintitle_f( Window       win,
							  const char * fmt,
							  ... );

extern  void fl_winicontitle( Window       win,
                                const char * title );

extern  void fl_winicontitle_f( Window       win,
								  const char * fmt,
								  ... );

extern  void fl_winposition( FL_Coord x,
                               FL_Coord y );

#define fl_pref_winposition   fl_winposition
#define fl_win_background     fl_winbackground
#define fl_winstepunit        fl_winstepsize
#define fl_set_winstepunit    fl_winstepsize

extern  void fl_winminsize( Window   win,
                              FL_Coord w,
                              FL_Coord h );

extern  void fl_winmaxsize( Window   win,
                              FL_Coord w,
                              FL_Coord h );

extern  void fl_winaspect( Window   win,
                             FL_Coord x,
                             FL_Coord y );

extern  void fl_reset_winconstraints( Window win );


extern  void fl_winsize( FL_Coord w,
                           FL_Coord h );

extern  void fl_initial_winsize( FL_Coord w,
                                   FL_Coord h );

#define fl_pref_winsize  fl_winsize

extern  void fl_initial_winstate( int state );

extern  Colormap fl_create_colormap( XVisualInfo * xv,
                                       int           nfill );



extern  void fl_wingeometry( FL_Coord x,
                               FL_Coord y,
                               FL_Coord w,
                               FL_Coord h );

#define fl_pref_wingeometry  fl_wingeometry

extern  void fl_initial_wingeometry( FL_Coord x,
                                       FL_Coord y,
                                       FL_Coord w,
                                       FL_Coord h );

extern  void fl_noborder( void );

extern  void fl_transient( void );

extern  void fl_get_winsize( Window     win,
                               FL_Coord * w,
                               FL_Coord * h );

extern  void fl_get_winorigin( Window     win,
                                 FL_Coord * x,
                                 FL_Coord * y );

extern  void fl_get_wingeometry( Window     win,
                                   FL_Coord * x,
                                   FL_Coord * y,
                                   FL_Coord * w,
                                   FL_Coord * h );

/* For compatibility */

#define fl_get_win_size          fl_get_winsize
#define fl_get_win_origin        fl_get_winorigin
#define fl_get_win_geometry      fl_get_wingeometry
#define fl_initial_winposition   fl_pref_winposition

#define fl_get_display( )            fl_display
#define FL_FormDisplay( form )       fl_display
#define FL_ObjectDisplay( object )   fl_display
#define FL_IS_CANVAS( o )   \
    ( ( o )->objclass == FL_CANVAS || ( o )->objclass == FL_GLCANVAS )

/* The window an object belongs to - for drawing */

#define FL_ObjWin( o )   \
    ( FL_IS_CANVAS( o ) ? fl_get_canvas_id( o ) : ( o )->form->window )


extern  Window fl_get_real_object_window( FL_OBJECT * ob );

#define FL_OBJECT_WID  FL_ObjWin

/*  All registerable events, including Client Message */

#define FL_ALL_EVENT  (   KeyPressMask       \
                        | KeyReleaseMask     \
                        | ButtonPressMask    \
                        | ButtonReleaseMask  \
                        | EnterWindowMask    \
                        | LeaveWindowMask    \
                        | ButtonMotionMask   \
                        | PointerMotionMask )


/* Replacements for X functions that access the event queue */

extern  int fl_XNextEvent( XEvent * xev );

extern  int fl_XPeekEvent( XEvent * xev );

extern  int fl_XEventsQueued( int mode );

extern  void fl_XPutBackEvent( XEvent * xev );

extern  const XEvent *fl_last_event( void );

typedef int ( * FL_APPEVENT_CB )( XEvent *, void * );

extern  FL_APPEVENT_CB fl_set_event_callback( FL_APPEVENT_CB   callback,
                                                void           * user_data );

extern  FL_APPEVENT_CB fl_set_idle_callback( FL_APPEVENT_CB   callback,
                                               void           * user_data );

extern  long fl_addto_selected_xevent( Window win,
                                         long   mask );

extern  long fl_remove_selected_xevent( Window win,
                                          long   mask );

#define fl_add_selected_xevent  fl_addto_selected_xevent

extern  void fl_set_idle_delta( long delta );

extern  FL_APPEVENT_CB fl_add_event_callback( Window           win,
                                                int              ev,
                                                FL_APPEVENT_CB   wincb,
                                                void           * user_data );

extern  void fl_remove_event_callback( Window win,
                                         int    ev );

extern  void fl_activate_event_callbacks( Window win );

extern  XEvent *fl_print_xevent_name( const char   * where,
                                        const XEvent * xev );

extern  void fl_XFlush( void );

#define metakey_down( mask )     ( ( mask ) & Mod1Mask )
#define shiftkey_down( mask )    ( ( mask ) & ShiftMask )
#define controlkey_down( mask )  ( ( mask ) & ControlMask )
#define button_down( mask )      (    ( ( mask ) & Button1Mask )  \
                                   || ( ( mask ) & Button2Mask )  \
                                   || ( ( mask ) & Button3Mask )  \
                                   || ( ( mask ) & Button4Mask )  \
                                   || ( ( mask ) & Button5Mask ) )

#define fl_keypressed            fl_keysym_pressed

/****************** Resources ***************/

typedef enum {
    FL_NONE,
    FL_SHORT = 10,
    FL_BOOL,
    FL_INT,
    FL_LONG,
    FL_FLOAT,
    FL_STRING
} FL_RTYPE;

typedef struct {
    const char * res_name;      /* resource name                        */
    const char * res_class;     /* resource class                       */
    FL_RTYPE     type;          /* FL_INT, FL_FLOAT, FL_BOOL, FL_STRING */
    void       * var;           /* address for the variable             */
    const char * defval;        /* default setting in string form       */
    int          nbytes;        /* used only for strings                */
} FL_RESOURCE;

#define FL_resource FL_RESOURCE

#define FL_CMD_OPT   XrmOptionDescRec

extern  Display * fl_initialize( int        * na,
                                   char       * arg[ ],
                                   const char * appclass,
                                   XrmOptionDescRec  * appopt,
                                   int          nappopt );

extern  void fl_finish( void );

extern  const char * fl_get_resource( const char * rname,
                                        const char * cname,
                                        FL_RTYPE     dtype,
                                        const char * defval,
                                        void       * val,
                                        int          size );

extern  void fl_set_resource( const char * str,
                                const char * val );

extern  void fl_get_app_resources( FL_RESOURCE * appresource,
                                     int           n );

extern  void fl_set_visualID( long id );

extern  int fl_keysym_pressed( KeySym k );

#define buttonLabelSize  buttonFontSize
#define sliderLabelSize  sliderFontSize
#define inputLabelSize   inputFontSize

/* All Form control variables. Named closely as its resource name */

typedef struct {
    float  rgamma,
           ggamma,
           bgamma;
    int    debug,
           sync;
    int    depth,
           vclass,
           doubleBuffer;
    int    ulPropWidth,         /* underline stuff       */
           ulThickness;
    int    buttonFontSize;
    int    sliderFontSize;
    int    inputFontSize;
    int    browserFontSize;
    int    menuFontSize;
    int    choiceFontSize;
    int    labelFontSize;       /* all other labels fonts */
    int    pupFontSize,         /* font for pop-up menus  */
           pupFontStyle;
    int    privateColormap;
    int    sharedColormap;
    int    standardColormap;
    int    scrollbarType;
    int    backingStore;
    int    coordUnit;
    int    borderWidth;
    int    safe;
    char * rgbfile;             /* where RGB file is, not used */
    char   vname[ 24 ];
} FL_IOPT;

#define FL_PDButtonLabelSize  FL_PDButtonFontSize
#define FL_PDSliderLabelSize  FL_PDSliderFontSize
#define FL_PDInputLabelSize   FL_PDInputFontSize

/* Program default masks */

enum {
    FL_PDDepth           = ( 1 <<  1 ),
    FL_PDClass           = ( 1 <<  2 ),
    FL_PDDouble          = ( 1 <<  3 ),
    FL_PDSync            = ( 1 <<  4 ),
    FL_PDPrivateMap      = ( 1 <<  5 ),
    FL_PDScrollbarType   = ( 1 <<  6 ),
    FL_PDPupFontSize     = ( 1 <<  7 ),
    FL_PDButtonFontSize  = ( 1 <<  8 ),
    FL_PDInputFontSize   = ( 1 <<  9 ),
    FL_PDSliderFontSize  = ( 1 << 10 ),
    FL_PDVisual          = ( 1 << 11 ),
    FL_PDULThickness     = ( 1 << 12 ),
    FL_PDULPropWidth     = ( 1 << 13 ),
    FL_PDBS              = ( 1 << 14 ),
    FL_PDCoordUnit       = ( 1 << 15 ),
    FL_PDDebug           = ( 1 << 16 ),
    FL_PDSharedMap       = ( 1 << 17 ),
    FL_PDStandardMap     = ( 1 << 18 ),
    FL_PDBorderWidth     = ( 1 << 19 ),
    FL_PDSafe            = ( 1 << 20 ),
    FL_PDMenuFontSize    = ( 1 << 21 ),
    FL_PDBrowserFontSize = ( 1 << 22 ),
    FL_PDChoiceFontSize  = ( 1 << 23 ),
    FL_PDLabelFontSize   = ( 1 << 24 )
};

#define FL_PDButtonLabel   FL_PDButtonLabelSize

extern  void fl_set_defaults( unsigned   long mask,
                                FL_IOPT  * cntl );

extern  void fl_set_tabstop( const char * s );

extern  int fl_get_visual_depth( void );

extern  int fl_is_global_clipped( void );

extern  int fl_is_clipped( int include_global );

extern  int fl_is_text_clipped( int include_global );

extern  void fl_set_clipping( FL_Coord x,
                                FL_Coord y,
                                FL_Coord w,
                                FL_Coord h );

extern  void fl_unset_clipping( void );

extern  void fl_set_text_clipping( FL_Coord x,
                                     FL_Coord y,
                                     FL_Coord w,
                                     FL_Coord h );

extern  void fl_unset_text_clipping( void );

extern  int fl_get_global_clipping( FL_Coord  * x,
                                      FL_Coord  * y,
                                      FL_Coord  * w,
                                      FL_Coord  * h );

extern  int fl_get_clipping( int        include_global,
                               FL_Coord  * x,
                               FL_Coord  * y,
                               FL_Coord  * w,
                               FL_Coord  * h );

extern  int fl_get_text_clipping( int        include_global,
                                    FL_Coord  * x,
                                    FL_Coord  * y,
                                    FL_Coord  * w,
                                    FL_Coord  * h );

extern  void fl_set_gc_clipping( GC       gc,
                                   FL_Coord x,
                                   FL_Coord y,
                                   FL_Coord w,
                                   FL_Coord h );

extern  void fl_unset_gc_clipping( GC gc );


/* How we pack and unpack colors */


typedef unsigned char     FL_PCTYPE;          /* primary color type */
#define FL_PCBITS         8                   /* primary color bits */
#define FL_PCMAX          ( ( 1 << FL_PCBITS ) - 1 )
#define FL_PCCLAMP( a )   \
    ( ( a ) > ( FL_PCMAX ) ? ( FL_PCMAX ) : ( ( a ) < 0 ? 0 : ( a ) ) )
typedef unsigned int       FL_PACKED4;
#define FL_PACKED          FL_PACKED4

#define FL_RMASK           0x000000ff
#define FL_RSHIFT          0
#define FL_GMASK           0x0000ff00
#define FL_GSHIFT          8
#define FL_BMASK           0x00ff0000
#define FL_BSHIFT          16
#define FL_AMASK           0xff000000
#define FL_ASHIFT          24

/* If PCBITS is not 8, we need to apply the RGBmask */

#define FL_GETR( packed )  ( ( ( packed ) >> FL_RSHIFT ) & FL_RMASK )
#define FL_GETG( packed )  ( ( ( packed ) >> FL_GSHIFT ) & FL_PCMAX )
#define FL_GETB( packed )  ( ( ( packed ) >> FL_BSHIFT ) & FL_PCMAX )
#define FL_GETA( packed )  ( ( ( packed ) >> FL_ASHIFT ) & FL_PCMAX )

#define FL_PACK3( r, g, b )   \
    ( ( ( r ) << FL_RSHIFT ) | ( ( g ) << FL_GSHIFT ) | ( ( b ) << FL_BSHIFT ) )

#define FL_PACK            FL_PACK3

#define FL_PACK4( r, g, b, a ) ( FL_PACK3( r, g, b ) | ( ( a ) << FL_ASHIFT ) )

#define FL_UNPACK( p, r, g, b )   \
    do { r = FL_GETR( p );        \
         g = FL_GETG( p );        \
         b = FL_GETB( p );        \
    } while( 0 )

#define FL_UNPACK3 FL_UNPACK

#define FL_UNPACK4( p, r, g, b, a )   \
    do { FL_UNPACK3( p, r, g, b );    \
         a = FL_GETA( p );            \
    } while( 0 )



typedef struct {
   unsigned int rshift,
                rmask,
                rbits;
   unsigned int gshift,
                gmask,
                gbits;
   unsigned int bshift,
                bmask,
                bbits;
   int          bits_per_rgb;
   int          colormap_size;
} FL_RGB2PIXEL_;

#define FL_RGB2PIXEL  FL_RGB2PIXEL_

/* ! defined FL_XBASIC_H */



#define FL_POPUP_H

typedef struct FL_POPUP_ FL_POPUP;
typedef struct FL_POPUP_ENTRY_ FL_POPUP_ENTRY;
typedef struct FL_POPUP_RETURN_ FL_POPUP_RETURN;

typedef int ( * FL_POPUP_CB )( FL_POPUP_RETURN * );

struct FL_POPUP_RETURN_ {
    long int               val;          /* value assigned to popup entry */
    void                 * user_data;    /* pointer to user data */
    const char           * text;         /* text of the selected popup entry */
    const char           * label;        /* left-flushed label part */
    const char           * accel;        /* right-flushed label part */
    const FL_POPUP_ENTRY * entry;        /* pointer to selected popup entry */
    const FL_POPUP       * popup;        /* popup we're called for */
};

struct FL_POPUP_ {
    FL_POPUP         * next;             /* next in linked list */
    FL_POPUP         * prev;             /* previous in linked list */
    FL_POPUP         * parent;           /* for sub-popups: direct parent */
    FL_POPUP         * top_parent;       /* and top-most parent */
    FL_POPUP_ENTRY   * entries;          /* pointer to list of entries */
    char             * title;
    Window             win;              /* popup window */
    Window             parent_win;       /* parent window of popup window */
    Cursor             cursor;           /* cursor for the popup */
    FL_POPUP_CB        callback;
    int                use_req_pos;      /* if set use req_x, req_y */
    int                req_x,
                       req_y;
    int                x,                /* position of popup window */
                       y;
    unsigned int       w,                /* dimensions of popup window */
                       h;
    int                min_width;        /* minimum width of popup */
    int                title_box_x,      /* position of title box */
                       title_box_y;
    unsigned int       title_box_w,      /* dimensions of title box */
                       title_box_h;
    int                has_subs,
                       has_boxes;
    int                counter;
    int                title_font_style;
    int                title_font_size;
    int                entry_font_style;
    int                entry_font_size;
    unsigned long      event_mask;
    int                bw;               /* border width */
    FL_COLOR           bg_color;         /* background color of popup*/
    FL_COLOR           on_color;         /* color of entry under mouse */
    FL_COLOR           title_color;      /* color of title text */
    FL_COLOR           text_color;       /* normal text color of entry */
    FL_COLOR           text_on_color;    /* text color when mouse on entry */
    FL_COLOR           text_off_color;   /* text color of disabled entry */
    FL_COLOR           radio_color;      /* color of radio buttons */
    int                policy;
    int                need_recalc;      /* do we need to recalc position? */
    FL_POPUP_RETURN    ret;              /* structure passed to calbacks
                                            and returned on selection */
};

struct FL_POPUP_ENTRY_ {
    FL_POPUP_ENTRY * prev;               /* next in linked list */
    FL_POPUP_ENTRY * next;               /* previous in linked list */
    FL_POPUP       * popup;              /* popup it belongs to */
    int              is_act;             /* set while mouse is over it */
    char           * text;               /* complete text of entry */
    char           * label;              /* cleaned-up label text */
    char           * accel;              /* cleaned-up accelerator key text */
    long int         val;                /* value associated with entry */
    void           * user_data;          /* pointer to user data */
    int              type;               /* normal, toggle, radio, sub-popup */
    unsigned int     state;              /* disabled, hidden, checked */
    int              group;              /* group (for radio entries only) */
    FL_POPUP       * sub;                /* sub-popup bound to entry */
    long int       * shortcut;           /* keyboard shortcuts */
    int              ulpos;              /* underline position in text */
    FL_POPUP_CB      callback;           /* callback for entry */
    FL_POPUP_CB      enter_callback;     /* callback for entering entry */
    FL_POPUP_CB      leave_callback;     /* callback for leaving entry */
    int              x,                  /* position of entry text */
                     y;
    unsigned int     w,
                     h;                  /* height of entry text */
    int              box_x,
                     box_y;
    unsigned int     box_w,
                     box_h;
    unsigned int     sl_h;
    int              ul_x,
                     ul_y;
    unsigned int     ul_w,
                     ul_h;
};

typedef struct {
    const char     * text;               /* text of entry */
    FL_POPUP_CB      callback;           /* (selection) callback */
    const char     * shortcut;           /* keyboard shortcut description */
    int              type;               /* type of entry */
    int              state;              /* disabled, hidden, checked */
} FL_POPUP_ITEM;

/* Popup policies */

enum {
    FL_POPUP_NORMAL_SELECT,
    FL_POPUP_DRAG_SELECT
};

/* Popup states */

enum {
    FL_POPUP_NONE     = 0,
    FL_POPUP_DISABLED = 1,               /* entry is disabled */
    FL_POPUP_HIDDEN   = 2,               /* entry is temporarily hidden */
    FL_POPUP_CHECKED  = 4                /* tooogle/radio item is in on state */
};

/* Popup entry types */

enum {
    FL_POPUP_NORMAL,                     /* normal popup entry */
    FL_POPUP_TOGGLE,                     /* toggle ("binary") popup entry */
    FL_POPUP_RADIO,                      /* radio popup entry */
    FL_POPUP_SUB,                        /* sub-popup popup entry */
    FL_POPUP_LINE                        /* line popup entry */
};

/* Popup color types */

enum {
    FL_POPUP_BACKGROUND_COLOR,
    FL_POPUP_HIGHLIGHT_COLOR,
    FL_POPUP_TITLE_COLOR,
    FL_POPUP_TEXT_COLOR,
    FL_POPUP_HIGHLIGHT_TEXT_COLOR,
    FL_POPUP_DISABLED_TEXT_COLOR,
    FL_POPUP_RADIO_COLOR
};

extern  FL_POPUP *fl_popup_add( Window,
                                  const char * );

extern  FL_POPUP_ENTRY *fl_popup_add_entries( FL_POPUP *,
                                                const char *,
                                                ... );

extern  FL_POPUP_ENTRY *fl_popup_insert_entries( FL_POPUP *,
                                                   FL_POPUP_ENTRY *,
                                                   const char *,
                                                   ... );

extern  FL_POPUP *fl_popup_create( Window,
                                     const char *,
                                     FL_POPUP_ITEM * );

extern  FL_POPUP_ENTRY *fl_popup_add_items( FL_POPUP      *,
											  FL_POPUP_ITEM * );

extern  FL_POPUP_ENTRY *fl_popup_insert_items( FL_POPUP       *,
												 FL_POPUP_ENTRY *,
												 FL_POPUP_ITEM  * );

extern  int fl_popup_delete( FL_POPUP * );

extern  int fl_popup_entry_delete( FL_POPUP_ENTRY * );

extern  FL_POPUP_RETURN *fl_popup_do( FL_POPUP * );

extern  void fl_popup_set_position( FL_POPUP *,
                                      int,
                                      int );

extern  int fl_popup_get_policy( FL_POPUP * );

extern  int fl_popup_set_policy( FL_POPUP *,
                                   int );

extern  FL_POPUP_CB fl_popup_set_callback( FL_POPUP *,
                                             FL_POPUP_CB );

extern  void fl_popup_get_title_font( FL_POPUP *,
                                        int *,
                                        int * );

extern  void fl_popup_set_title_font( FL_POPUP *,
                                        int,
                                        int );

extern  void fl_popup_entry_get_font( FL_POPUP *,
                                        int *,
                                        int * );

extern  void fl_popup_entry_set_font( FL_POPUP *,
                                        int,
                                        int );

extern  int fl_popup_get_bw( FL_POPUP * );

extern  int fl_popup_set_bw( FL_POPUP *,
                               int );

extern  FL_COLOR fl_popup_get_color( FL_POPUP *,
                                       int );

extern  FL_COLOR fl_popup_set_color( FL_POPUP *,
                                       int,
                                       FL_COLOR );

extern  void fl_popup_set_cursor( FL_POPUP *,
                                    int );

extern  const char *fl_popup_get_title( FL_POPUP   * );

extern  FL_POPUP *fl_popup_set_title( FL_POPUP *,
                                        const char * );

extern  FL_POPUP * fl_popup_set_title_f( FL_POPUP   * popup,
										   const char * fmt,
										   ... );

extern  FL_POPUP_CB fl_popup_entry_set_callback( FL_POPUP_ENTRY *,
                                                   FL_POPUP_CB );

extern  FL_POPUP_CB fl_popup_entry_set_enter_callback( FL_POPUP_ENTRY *,
                                                         FL_POPUP_CB );

extern  FL_POPUP_CB fl_popup_entry_set_leave_callback( FL_POPUP_ENTRY *,
                                                         FL_POPUP_CB );

extern  unsigned int fl_popup_entry_get_state( FL_POPUP_ENTRY * );

extern  unsigned int fl_popup_entry_set_state( FL_POPUP_ENTRY *,
                                                 unsigned int );

extern  unsigned int fl_popup_entry_clear_state( FL_POPUP_ENTRY *,
                                                   unsigned int );

extern  unsigned int fl_popup_entry_raise_state( FL_POPUP_ENTRY *,
                                                   unsigned int );

extern  unsigned int fl_popup_entry_toggle_state( FL_POPUP_ENTRY *,
                                                    unsigned int );

extern  int fl_popup_entry_set_text( FL_POPUP_ENTRY *,
                                       const char * );

extern  void fl_popup_entry_set_shortcut( FL_POPUP_ENTRY *,
                                            const char * );

extern  long int fl_popup_entry_set_value( FL_POPUP_ENTRY *,
                                             long int );

extern  void *fl_popup_entry_set_user_data( FL_POPUP_ENTRY *,
                                              void * );

extern  FL_POPUP_ENTRY *fl_popup_entry_get_by_position( FL_POPUP *,
                                                          int );

extern  FL_POPUP_ENTRY *fl_popup_entry_get_by_value( FL_POPUP *,
                                                       long );

extern  FL_POPUP_ENTRY *fl_popup_entry_get_by_user_data( FL_POPUP *,
                                                           void * );

extern  FL_POPUP_ENTRY *fl_popup_entry_get_by_text( FL_POPUP *,
                                                      const char * );

extern  FL_POPUP_ENTRY * fl_popup_entry_get_by_text_f( FL_POPUP *,
														 const char *,
														 ... );

extern  FL_POPUP_ENTRY *fl_popup_entry_get_by_label( FL_POPUP *,
                                                       const char * );

extern  FL_POPUP_ENTRY * fl_popup_entry_get_by_label_f( FL_POPUP *,
														  const char *,
														  ... );

extern  int fl_popup_entry_get_group( FL_POPUP_ENTRY * );

extern  int fl_popup_entry_set_group( FL_POPUP_ENTRY *,
                                        int );

extern  FL_POPUP *fl_popup_entry_get_subpopup( FL_POPUP_ENTRY * );

extern  FL_POPUP *fl_popup_entry_set_subpopup( FL_POPUP_ENTRY *,
                                                 FL_POPUP * );

extern  int fl_popup_get_size( FL_POPUP *,
                                 unsigned int *,
                                 unsigned int * );

extern  int fl_popup_get_min_width( FL_POPUP * );

extern  int fl_popup_set_min_width( FL_POPUP *,
                                      int );

/* ! defined FL_POPUP_H */

/**
 * \file bitmap.h
 *
 *   Object Class: Bitmap
 */


#define FL_BITMAP_H

#define    FL_NORMAL_BITMAP      0

/***** Defaults *****/

#define FL_BITMAP_BOXTYPE   FL_NO_BOX
#define FL_BITMAP_COL1      FL_COL1     /* background of bitmap */
#define FL_BITMAP_COL2      FL_COL1     /* not used currently   */
#define FL_BITMAP_LCOL      FL_LCOL     /* foreground of bitmap */
#define FL_BITMAP_ALIGN     FL_ALIGN_BOTTOM

/***** Routines *****/

extern  FL_OBJECT * fl_create_bitmap( int          type,
                                        FL_Coord     x,
                                        FL_Coord     y,
                                        FL_Coord     w,
                                        FL_Coord     h,
                                        const char * label );

extern  FL_OBJECT * fl_add_bitmap( int          type,
                                     FL_Coord     x,
                                     FL_Coord     y,
                                     FL_Coord     w,
                                     FL_Coord     h,
                                     const char * label );

extern  void fl_set_bitmap_data( FL_OBJECT     * ob,
                                   int             w,
                                   int             h,
                                   unsigned char * data );

extern  void fl_set_bitmap_file( FL_OBJECT  * ob,
                                   const char * fname );

extern  Pixmap fl_read_bitmapfile( Window         win,
                                     const char   * file,
                                     unsigned int * w,
                                     unsigned int * h,
                                     int          * hotx,
                                     int          * hoty );

extern  Pixmap fl_create_from_bitmapdata( Window       win,
											const char * data,
											int          width,
											int          height );

/* for compatibility */

#define fl_set_bitmap_datafile    fl_set_bitmap_file

/* PIXMAP stuff */

#define FL_NORMAL_PIXMAP   0

extern  FL_OBJECT * fl_create_pixmap( int          type,
                                        FL_Coord     x,
                                        FL_Coord     y,
                                        FL_Coord     w,
                                        FL_Coord     h,
                                        const char * label );

extern  FL_OBJECT * fl_add_pixmap( int          type,
                                     FL_Coord     x,
                                     FL_Coord     y,
                                     FL_Coord     w,
                                     FL_Coord     h,
                                     const char * label );

extern  void fl_set_pixmap_data( FL_OBJECT  * ob,
                                   char      ** bits );

extern  void fl_set_pixmap_file( FL_OBJECT  * ob,
                                   const char * fname );

extern  void fl_set_pixmap_align( FL_OBJECT * ob,
                                    int         align,
                                    int         xmargin,
                                    int         ymargin );

extern  void fl_set_pixmap_pixmap( FL_OBJECT * ob,
                                     Pixmap      id,
                                     Pixmap      mask );

extern  void fl_set_pixmap_colorcloseness( int red,
                                             int green,
                                             int blue );

extern  void fl_free_pixmap_pixmap( FL_OBJECT * ob );

extern  void fl_free_pixmap_focus_pixmap( FL_OBJECT * obj );

extern  Pixmap fl_get_pixmap_pixmap( FL_OBJECT * ob,
                                       Pixmap    * p,
                                       Pixmap    * m );

extern  Pixmap fl_read_pixmapfile( Window         win,
                                     const char   * file,
                                     unsigned int * w,
                                     unsigned int * h,
                                     Pixmap       * shape_mask,
                                     int          * hotx,
                                     int          * hoty,
                                     FL_COLOR       tran );

extern  Pixmap fl_create_from_pixmapdata( Window          win,
                                            char         ** data,
                                            unsigned int  * w,
                                            unsigned int  * h,
                                            Pixmap        * sm,
                                            int           * hotx,
                                            int           * hoty,
                                            FL_COLOR        tran );

extern  void fl_free_pixmap( Pixmap id );


/* ! defined FL_BITMAP_H */

/**
 * \file box.h
 *
 */


#define FL_BOX_H

/* Type is already defined in Basic.h */

extern  FL_OBJECT * fl_create_box( int          type,
                                     FL_Coord     x,
                                     FL_Coord     y,
                                     FL_Coord     w,
                                     FL_Coord     h,
                                     const char * label );

extern  FL_OBJECT * fl_add_box( int          type,
                                  FL_Coord     x,
                                  FL_Coord     y,
                                  FL_Coord     w,
                                  FL_Coord     h,
                                  const char * label );

/* ! defined FL_BOX_H */

/*
 * \file browser.h
 *
 *  Object class Browser
 */


#define FL_BROWSER_H


/***** Types    *****/

typedef enum {
    FL_NORMAL_BROWSER,
    FL_SELECT_BROWSER,
    FL_HOLD_BROWSER,
    FL_MULTI_BROWSER,
	FL_DESELECTABLE_HOLD_BROWSER
} FL_BROWSER_TYPE;

/***** Defaults *****/

#define FL_BROWSER_BOXTYPE  FL_DOWN_BOX
#define FL_BROWSER_COL1     FL_COL1
#define FL_BROWSER_COL2     FL_YELLOW
#define FL_BROWSER_LCOL     FL_LCOL
#define FL_BROWSER_ALIGN    FL_ALIGN_BOTTOM


/***** Others   *****/

#define FL_BROWSER_SLCOL        FL_COL1
#define FL_BROWSER_FONTSIZE     FL_SMALL_SIZE


/* This exists only for backward compatibility and isn't used anymore! */

#define FL_BROWSER_LINELENGTH   2048


/***** Routines *****/

extern  FL_OBJECT * fl_create_browser( int          type,
                                         FL_Coord     x,
                                         FL_Coord     y,
                                         FL_Coord     w,
                                         FL_Coord     h,
                                         const char * label );

extern  FL_OBJECT * fl_add_browser( int          type,
                                      FL_Coord     x,
                                      FL_Coord     y,
                                      FL_Coord     w,
                                      FL_Coord     h,
                                      const char * label );

extern  void fl_clear_browser( FL_OBJECT * ob );

extern  void fl_add_browser_line( FL_OBJECT  * ob,
                                    const char * newtext );

extern  void fl_add_browser_line_f( FL_OBJECT  * ob,
									  const char * fmt,
									  ... );


extern  void fl_addto_browser( FL_OBJECT  * obj,
                                 const char * text );

extern  void fl_addto_browser_f( FL_OBJECT  * obj,
								   const char * fmt,
								   ...);

#define fl_append_browser  fl_addto_browser_chars
extern  void fl_addto_browser_chars( FL_OBJECT  * ob,
                                       const char * str );

extern  void fl_addto_browser_chars_f( FL_OBJECT  * ob,
										 const char * fmt,
										 ... );

#define fl_append_browser_f  fl_addto_browser_chars_f
extern  void fl_insert_browser_line( FL_OBJECT  * ob,
                                       int          linenumb,
                                       const char * newtext );

extern  void fl_insert_browser_line_f( FL_OBJECT  * ob,
										 int          linenumb,
										 const char * fmt,
										 ... );

extern  void fl_delete_browser_line( FL_OBJECT * ob,
                                       int         linenumb );

extern  void fl_replace_browser_line( FL_OBJECT  * ob,
                                        int          linenumb,
                                        const char * newtext );

extern  void fl_replace_browser_line_f( FL_OBJECT  * ob,
										  int          linenumb,
										  const char * fmt,
										  ... );

extern  const char *fl_get_browser_line( FL_OBJECT * ob,
                                           int         linenumb );

extern  int fl_load_browser( FL_OBJECT  * ob,
                               const char * filename );

extern  void fl_select_browser_line( FL_OBJECT * ob, 
                                       int         line );

extern  void fl_deselect_browser_line( FL_OBJECT * ob,
                                         int         line );

extern  void fl_deselect_browser( FL_OBJECT * ob );

extern  int fl_isselected_browser_line( FL_OBJECT * ob,
                                          int         line );

extern  int fl_get_browser_topline( FL_OBJECT * ob );

extern  int fl_get_browser( FL_OBJECT * ob );

extern  int fl_get_browser_maxline( FL_OBJECT * ob );

extern  int fl_get_browser_screenlines( FL_OBJECT * ob );

extern  void fl_set_browser_topline( FL_OBJECT * ob,
                                       int         line );

extern  void fl_set_browser_bottomline( FL_OBJECT * ob,
										  int         line );

extern  void fl_set_browser_fontsize( FL_OBJECT * ob,
                                        int         size );

extern  void fl_set_browser_fontstyle( FL_OBJECT * ob,
                                         int         style );

extern  void fl_set_browser_specialkey( FL_OBJECT * ob,
                                          int         specialkey );

extern  void fl_set_browser_vscrollbar( FL_OBJECT * ob,
                                          int         on );

extern  void fl_set_browser_hscrollbar( FL_OBJECT * ob,
                                          int         on );

extern  void fl_set_browser_line_selectable( FL_OBJECT * ob,
                                               int         line,
                                               int         flag );

extern  void fl_get_browser_dimension( FL_OBJECT * ob,
                                         FL_Coord  * x,
                                         FL_Coord  * y,
                                         FL_Coord  * w,
                                         FL_Coord  * h );

extern  void fl_set_browser_dblclick_callback( FL_OBJECT      * ob,
                                                 FL_CALLBACKPTR   cb,
                                                 long             a );

extern  FL_Coord fl_get_browser_xoffset( FL_OBJECT * ob );

extern  double fl_get_browser_rel_xoffset( FL_OBJECT * ob );

extern  void fl_set_browser_xoffset( FL_OBJECT * ob,
                                       FL_Coord    npixels );

extern  void fl_set_browser_rel_xoffset( FL_OBJECT * ob,
                                           double      val );

extern  FL_Coord fl_get_browser_yoffset( FL_OBJECT * ob );

extern  double fl_get_browser_rel_yoffset( FL_OBJECT * ob );

extern  void fl_set_browser_yoffset( FL_OBJECT * ob,
                                       FL_Coord    npixels );

extern  void fl_set_browser_rel_yoffset( FL_OBJECT * ob,
                                           double      val );

extern  void fl_set_browser_scrollbarsize( FL_OBJECT * ob,
                                             int         hh,
                                             int         vw );

extern  void fl_show_browser_line( FL_OBJECT * ob,
                                     int         j );

extern  int fl_set_default_browser_maxlinelength( int n );


#define FL_BROWSER_SCROLL_CALLBACKt
typedef void ( * FL_BROWSER_SCROLL_CALLBACK )( FL_OBJECT *,
                                               int,
                                               void * );


extern  void
    fl_set_browser_hscroll_callback( FL_OBJECT *,
                                     FL_BROWSER_SCROLL_CALLBACK,
                                     void * );

extern  void
    fl_set_browser_vscroll_callback( FL_OBJECT *,
                                     FL_BROWSER_SCROLL_CALLBACK,
                                     void * );

extern  int fl_get_browser_line_yoffset( FL_OBJECT *,
										   int  );

extern  FL_BROWSER_SCROLL_CALLBACK
    fl_get_browser_hscroll_callback( FL_OBJECT * );

extern  FL_BROWSER_SCROLL_CALLBACK
    fl_get_browser_vscroll_callback( FL_OBJECT * );

extern  int fl_get_browser_scrollbar_repeat( FL_OBJECT * );

extern  void fl_set_browser_scrollbar_repeat( FL_OBJECT *,
												int  );

/* ! defined FL_BROWSER_H */

/**
 * \file button.h
 *
 * All Buttons: regular button, light button and round button
 *
 */


#define FL_BUTTON_H


typedef enum {
    FL_NORMAL_BUTTON,
    FL_PUSH_BUTTON,
    FL_RADIO_BUTTON,
    FL_HIDDEN_BUTTON,
    FL_TOUCH_BUTTON,
    FL_INOUT_BUTTON,
    FL_RETURN_BUTTON,
    FL_HIDDEN_RET_BUTTON,
    FL_MENU_BUTTON
} FL_BUTTON_TYPE;

#define FL_TOGGLE_BUTTON    FL_PUSH_BUTTON

typedef struct {
    Pixmap         pixmap,
                   mask;
    unsigned int   bits_w,
                   bits_h;
    int            val;             /* state of button (on/off) */
    int            mousebut;        /* mouse button that caused the push     */
    int            timdel;          /* time since last touch (TOUCH buttons) */
    int            event;           /* what event triggers redraw            */
    int            is_pushed;       /* set while drawn as pushed down        */
    int            react_to[ 5 ];   /* mouse buttons button reacts to        */
    long           cspecl;          /* reserved for class specfic stuff      */
    void         * cspecv;          /* misc. things                          */
    char         * filename;
    Pixmap         focus_pixmap,
                   focus_mask;
    char         * focus_filename;
} FL_BUTTON_SPEC;

#define FL_BUTTON_STRUCT FL_BUTTON_SPEC

typedef void ( * FL_DrawButton )( FL_OBJECT * );
typedef void ( * FL_CleanupButton )( FL_BUTTON_SPEC  * );

#define FL_DRAWBUTTON      FL_DrawButton
#define FL_CLEANUPBUTTON   FL_CleanupButton

/* normal button default */

#define FL_BUTTON_BOXTYPE           FL_UP_BOX
#define FL_BUTTON_COL1              FL_COL1
#define FL_BUTTON_COL2              FL_COL1
#define FL_BUTTON_LCOL              FL_LCOL
#define FL_BUTTON_ALIGN             FL_ALIGN_CENTER
#define FL_BUTTON_MCOL1             FL_MCOL
#define FL_BUTTON_MCOL2             FL_MCOL
#define FL_BUTTON_BW                FL_BOUND_WIDTH

/* light button defaults */

#define FL_LIGHTBUTTON_BOXTYPE      FL_UP_BOX
#define FL_LIGHTBUTTON_COL1         FL_COL1
#define FL_LIGHTBUTTON_COL2         FL_YELLOW
#define FL_LIGHTBUTTON_LCOL         FL_LCOL
#define FL_LIGHTBUTTON_ALIGN        ( FL_ALIGN_CENTER | FL_ALIGN_INSIDE )
#define FL_LIGHTBUTTON_TOPCOL       FL_COL1
#define FL_LIGHTBUTTON_MCOL         FL_MCOL
#define FL_LIGHTBUTTON_MINSIZE      ( ( FL_Coord ) 12 )

/* round button defaults */

#define FL_ROUNDBUTTON_BOXTYPE      FL_NO_BOX
#define FL_ROUNDBUTTON_COL1         FL_MCOL
#define FL_ROUNDBUTTON_COL2         FL_YELLOW
#define FL_ROUNDBUTTON_LCOL         FL_LCOL
#define FL_ROUNDBUTTON_ALIGN        FL_ALIGN_CENTER
#define FL_ROUNDBUTTON_TOPCOL       FL_COL1
#define FL_ROUNDBUTTON_MCOL         FL_MCOL

/* round3d button defaults */

#define FL_ROUND3DBUTTON_BOXTYPE    FL_NO_BOX
#define FL_ROUND3DBUTTON_COL1       FL_COL1
#define FL_ROUND3DBUTTON_COL2       FL_BLACK
#define FL_ROUND3DBUTTON_LCOL       FL_LCOL
#define FL_ROUND3DBUTTON_ALIGN      FL_ALIGN_CENTER
#define FL_ROUND3DBUTTON_TOPCOL     FL_COL1
#define FL_ROUND3DBUTTON_MCOL       FL_MCOL

/* check button defaults */

#define FL_CHECKBUTTON_BOXTYPE      FL_NO_BOX
#define FL_CHECKBUTTON_COL1         FL_COL1
#define FL_CHECKBUTTON_COL2         FL_YELLOW
#define FL_CHECKBUTTON_LCOL         FL_LCOL
#define FL_CHECKBUTTON_ALIGN        FL_ALIGN_CENTER

#define FL_CHECKBUTTON_TOPCOL       FL_COL1
#define FL_CHECKBUTTON_MCOL         FL_MCOL

/* bitmap button defaults */

#define FL_BITMAPBUTTON_BOXTYPE     FL_UP_BOX
#define FL_BITMAPBUTTON_COL1        FL_COL1         /* bitmap background  */
#define FL_BITMAPBUTTON_COL2        FL_BLUE         /* "focus" color       */
#define FL_BITMAPBUTTON_LCOL        FL_LCOL         /* bitmap foreground   */
#define FL_BITMAPBUTTON_ALIGN       FL_ALIGN_BOTTOM

/* bitmap button defaults */

#define FL_PIXMAPBUTTON_BOXTYPE     FL_UP_BOX
#define FL_PIXMAPBUTTON_COL1        FL_BUTTON_COL1
#define FL_PIXMAPBUTTON_COL2        FL_BUTTON_COL2
#define FL_PIXMAPBUTTON_LCOL        FL_BUTTON_LCOL
#define FL_PIXMAPBUTTON_MCOL1       FL_BUTTON_MCOL1
#define FL_PIXMAPBUTTON_MCOL2       FL_BUTTON_MCOL2
#define FL_PIXMAPBUTTON_ALIGN       FL_ALIGN_BOTTOM

/***** Routines *****/

extern  FL_OBJECT * fl_create_button( int          type,
                                        FL_Coord     x,
                                        FL_Coord     y,
                                        FL_Coord     w,
                                        FL_Coord     h,
                                        const char * label );

extern  FL_OBJECT * fl_create_roundbutton( int          type,
                                             FL_Coord     x,
                                             FL_Coord     y,
                                             FL_Coord     w,
                                             FL_Coord     h,
                                             const char * label );

extern  FL_OBJECT * fl_create_round3dbutton( int        type,
                                               FL_Coord   x,
                                               FL_Coord   y,
                                               FL_Coord   w,
                                               FL_Coord   h,
                                               const char * label );

extern  FL_OBJECT * fl_create_lightbutton( int          type,
                                             FL_Coord     x,
                                             FL_Coord     y,
                                             FL_Coord     w,
                                             FL_Coord     h,
                                             const char * label );

extern  FL_OBJECT * fl_create_checkbutton( int          type,
                                             FL_Coord     x,
                                             FL_Coord     y,
                                             FL_Coord     w,
                                             FL_Coord     h,
                                             const char * label );

extern  FL_OBJECT * fl_create_bitmapbutton( int          type,
                                              FL_Coord     x,
                                              FL_Coord     y,
                                              FL_Coord     w,
                                              FL_Coord     h,
                                              const char * label );

extern  FL_OBJECT * fl_create_pixmapbutton( int          type,
                                              FL_Coord     x,
                                              FL_Coord     y,
                                              FL_Coord     w,
                                              FL_Coord     h,
                                              const char * label );

extern  FL_OBJECT * fl_create_scrollbutton( int          type,
                                              FL_Coord     x,
                                              FL_Coord     y,
                                              FL_Coord     w,
                                              FL_Coord     h,
                                              const char * label );

extern  FL_OBJECT * fl_create_labelbutton( int           type,
                                             FL_Coord      x,
                                             FL_Coord      y,
                                             FL_Coord      w,
                                             FL_Coord      h,
                                             const char * label );

extern  FL_OBJECT *fl_add_roundbutton( int          type,
                                         FL_Coord     x,
                                         FL_Coord     y,
                                         FL_Coord     w,
                                         FL_Coord     h,
                                         const char * label );

extern  FL_OBJECT * fl_add_round3dbutton( int          type,
                                            FL_Coord     x,
                                            FL_Coord     y,
                                            FL_Coord     w,
                                            FL_Coord     h,
                                            const char * label );

extern  FL_OBJECT * fl_add_lightbutton( int         type,
                                          FL_Coord    x,
                                          FL_Coord    y,
                                          FL_Coord    w,
                                          FL_Coord    h,
                                          const char * label );

extern  FL_OBJECT * fl_add_checkbutton( int          type,
                                          FL_Coord     x,
                                          FL_Coord     y,
                                          FL_Coord     w,
                                          FL_Coord     h,
                                          const char * label );

extern  FL_OBJECT * fl_add_button( int          type,
                                     FL_Coord     x,
                                     FL_Coord     y,
                                     FL_Coord     w,
                                     FL_Coord     h,
                                     const char * label );

extern  FL_OBJECT * fl_add_bitmapbutton( int          type,
                                           FL_Coord     x,
                                           FL_Coord     y,
                                           FL_Coord     w,
                                           FL_Coord     h,
                                           const char * label );

extern  FL_OBJECT * fl_add_scrollbutton( int          type,
                                           FL_Coord     x,
                                           FL_Coord     y,
                                           FL_Coord     w,
                                           FL_Coord     h,
                                           const char * label );

extern  FL_OBJECT * fl_add_labelbutton( int          type,
                                          FL_Coord     x,
                                          FL_Coord     y,
                                          FL_Coord     w,
                                          FL_Coord     h,
                                          const char * label );

#define fl_set_bitmapbutton_file  fl_set_bitmap_file

extern  void fl_set_bitmapbutton_data( FL_OBJECT     * ob,
                                         int             w,
                                         int             h,
                                         unsigned char * bits );

#define fl_set_bitmapbutton_datafile  fl_set_bitmapbutton_file

extern  FL_OBJECT * fl_add_pixmapbutton( int          type,
                                           FL_Coord     x,
                                           FL_Coord     y,
                                           FL_Coord     w,
                                           FL_Coord     h,
                                           const char * label );

#define fl_set_pixmapbutton_data       fl_set_pixmap_data
#define fl_set_pixmapbutton_file       fl_set_pixmap_file
#define fl_set_pixmapbutton_pixmap     fl_set_pixmap_pixmap
#define fl_get_pixmapbutton_pixmap     fl_get_pixmap_pixmap
#define fl_set_pixmapbutton_align      fl_set_pixmap_align
#define fl_free_pixmapbutton_pixmap    fl_free_pixmap_pixmap
#define fl_set_pixmapbutton_datafile   fl_set_pixmapbutton_file
#define fl_set_pixmapbutton_show_focus fl_set_pixmapbutton_focus_outline


extern  void fl_set_pixmapbutton_focus_outline( FL_OBJECT * ob,
                                                  int         yes );

extern  void fl_set_pixmapbutton_focus_data( FL_OBJECT  * ob,
                                               char      ** bits );

extern  void fl_set_pixmapbutton_focus_file( FL_OBJECT  * ob,
                                               const char * fname );

extern  void fl_set_pixmapbutton_focus_pixmap( FL_OBJECT * ob,
                                                 Pixmap      id,
                                                 Pixmap      mask );

extern  int fl_get_button( FL_OBJECT * ob );

extern  void fl_set_button( FL_OBJECT * ob,
                              int         pushed );

extern  int fl_get_button_numb( FL_OBJECT * ob );

#define fl_set_button_shortcut  fl_set_object_shortcut

extern  FL_OBJECT * fl_create_generic_button( int          objclass,
                                                int          type,
                                                FL_Coord     x,
                                                FL_Coord     y,
                                                FL_Coord     w,
                                                FL_Coord     h,
                                                const char * label );

extern  void fl_add_button_class( int              bclass,
                                    FL_DrawButton    drawit,
                                    FL_CleanupButton cleanup );

extern  void fl_set_button_mouse_buttons( FL_OBJECT    * ob,
                                            unsigned int   buttons );

extern  void fl_get_button_mouse_buttons( FL_OBJECT    * ob,
                                            unsigned int * buttons );

/* ! defined FL_BUTTON_H */

/**
 * \file canvas.h
 *
 * Header for FL_CANVAS
 *
 */


#define FL_CANVAS_H_

typedef enum {
    FL_NORMAL_CANVAS,
    FL_SCROLLED_CANVAS
} FL_CANVAS_TYPE;

typedef int ( * FL_HANDLE_CANVAS )( FL_OBJECT *,
                                    Window,
                                    int,
                                    int,
                                    XEvent *,
                                    void * );

typedef int ( * FL_MODIFY_CANVAS_PROP )( FL_OBJECT * );

/******************** Default *********************/

#define FL_CANVAS_BOXTYPE   FL_DOWN_BOX     /* really the decoration frame */
#define FL_CANVAS_ALIGN     FL_ALIGN_TOP

/************ Interfaces    ************************/

extern  FL_OBJECT * fl_create_generic_canvas( int          canvas_class,
                                                int          type,
                                                FL_Coord     x,
                                                FL_Coord     y,
                                                FL_Coord     w,
                                                FL_Coord     h,
                                                const char * label );

extern  FL_OBJECT * fl_add_canvas( int          type,
                                     FL_Coord     x,
                                     FL_Coord     y,
                                     FL_Coord     w,
                                     FL_Coord     h,
                                     const char * label );

extern  FL_OBJECT * fl_create_canvas( int          type,
                                        FL_Coord     x,
                                        FL_Coord     y,
                                        FL_Coord     w,
                                        FL_Coord     h,
                                        const char * label );

/* backward compatibility */

#define fl_set_canvas_decoration fl_set_object_boxtype

extern  void fl_set_canvas_colormap( FL_OBJECT * ob,
                                       Colormap    colormap );

extern  void fl_set_canvas_visual( FL_OBJECT * obj,
                                     Visual    * vi );

extern  void fl_set_canvas_depth( FL_OBJECT * obj,
                                    int         depth );

extern  void fl_set_canvas_attributes( FL_OBJECT            * ob,
                                         unsigned int           mask,
                                         XSetWindowAttributes * xswa );

extern  FL_HANDLE_CANVAS fl_add_canvas_handler( FL_OBJECT        * ob,
                                                  int                ev,
                                                  FL_HANDLE_CANVAS   h,
                                                  void             * udata );

extern  Window fl_get_canvas_id( FL_OBJECT * ob );

extern  Colormap fl_get_canvas_colormap( FL_OBJECT * ob );

extern  int fl_get_canvas_depth( FL_OBJECT * obj );

extern  void fl_remove_canvas_handler( FL_OBJECT        * ob,
                                         int                ev,
                                         FL_HANDLE_CANVAS   h );

extern  void fl_share_canvas_colormap( FL_OBJECT * ob,
                                         Colormap    colormap );

extern  void fl_clear_canvas( FL_OBJECT * ob );

extern  void fl_modify_canvas_prop( FL_OBJECT             * obj,
                                      FL_MODIFY_CANVAS_PROP   init,
                                      FL_MODIFY_CANVAS_PROP   activate,
                                      FL_MODIFY_CANVAS_PROP   cleanup );

extern  void fl_canvas_yield_to_shortcut( FL_OBJECT * ob,
                                            int         yes );

/* This is an attempt to maintain some sort of backwards compatibility
 * with old code whilst also getting rid of the old, system-specific
 * hack. */





/* ! defined FL_CANVAS_H */

/**
 * \file chart.h
 *
 * Object Class: Chart
 *
 */


#define FL_CHART_H

typedef enum {
    FL_BAR_CHART,
    FL_HORBAR_CHART,
    FL_LINE_CHART,
    FL_FILL_CHART,
    FL_SPIKE_CHART,
    FL_PIE_CHART,
    FL_SPECIALPIE_CHART
} FL_CHART_TYPE;

#define FL_FILLED_CHART  FL_FILL_CHART  /* for backward compatibility */

/***** Defaults *****/

#define FL_CHART_BOXTYPE    FL_BORDER_BOX
#define FL_CHART_COL1       FL_COL1
#define FL_CHART_LCOL       FL_LCOL
#define FL_CHART_ALIGN      FL_ALIGN_BOTTOM

/***** Others   *****/

#define FL_CHART_MAX        2048

/***** Routines *****/

extern  FL_OBJECT * fl_create_chart( int          type,
                                       FL_Coord     x,
                                       FL_Coord     y,
                                       FL_Coord     w,
                                       FL_Coord     h,
                                       const char * label );

extern  FL_OBJECT * fl_add_chart( int          type,
                                    FL_Coord     x,
                                    FL_Coord     y,
                                    FL_Coord     w,
                                    FL_Coord     h,
                                    const char * label );

extern  void fl_clear_chart( FL_OBJECT * ob );

extern  void fl_add_chart_value( FL_OBJECT  * ob,
                                   double       val,
                                   const char * str,
                                   FL_COLOR     col );

extern  void fl_insert_chart_value( FL_OBJECT  * ob,
                                      int          indx,
                                      double       val,
                                      const char * str,
                                      FL_COLOR     col );

extern  void fl_replace_chart_value( FL_OBJECT  * ob,
                                       int          indx,
                                       double       val,
                                       const char * str,
                                       FL_COLOR     col );

extern  void fl_set_chart_bounds( FL_OBJECT * ob,
                                    double      min,
                                    double      max );

extern  void fl_get_chart_bounds( FL_OBJECT * ob,
                                    double    * min,
                                    double    * max );

extern  void fl_set_chart_maxnumb( FL_OBJECT * ob,
									 int         maxnumb );

extern  void fl_set_chart_autosize( FL_OBJECT * ob,
                                      int         autosize );

extern  void fl_set_chart_lstyle( FL_OBJECT * ob,
                                    int         lstyle );

extern  void fl_set_chart_lsize( FL_OBJECT * ob,
                                   int         lsize );

extern  void fl_set_chart_lcolor( FL_OBJECT * ob,
                                    FL_COLOR    lcol );

extern  void fl_set_chart_baseline( FL_OBJECT * ob,
                                      int         iYesNo );

#define fl_set_chart_lcol   fl_set_chart_lcolor

/* ! defined FL_CHART_H */

/**
 * \file choice.h
 *
 */


#define FL_CHOICE_H


typedef enum {
    FL_NORMAL_CHOICE,
    FL_NORMAL_CHOICE2,
    FL_DROPLIST_CHOICE,
    FL_BROWSER_CHOICE
} FL_CHOICE_TYPE;

#define  FL_SIMPLE_CHOICE  FL_NORMAL_CHOICE

/***** Defaults *****/

#define FL_CHOICE_BOXTYPE   FL_ROUNDED_BOX
#define FL_CHOICE_COL1      FL_COL1
#define FL_CHOICE_COL2      FL_LCOL
#define FL_CHOICE_LCOL      FL_LCOL
#define FL_CHOICE_ALIGN     FL_ALIGN_LEFT

/***** Others   *****/

#define FL_CHOICE_MCOL      FL_MCOL
#define FL_CHOICE_MAXITEMS  128

/***** Routines *****/

extern  FL_OBJECT * fl_create_choice( int          type,
                                        FL_Coord     x,
                                        FL_Coord     y,
                                        FL_Coord     w,
                                        FL_Coord     h,
                                        const char * label );

extern  FL_OBJECT * fl_add_choice( int          type,
                                     FL_Coord     x,
                                     FL_Coord     y,
                                     FL_Coord     w,
                                     FL_Coord     h,
                                     const char * label );

extern  void fl_clear_choice( FL_OBJECT * ob );

extern  int fl_addto_choice( FL_OBJECT  * ob,
                               const char * str );

extern  int fl_addto_choice_f( FL_OBJECT *  ob,
								 const char * fmt,
								 ... );

extern  void fl_replace_choice( FL_OBJECT  * ob,
                                  int          numb,
                                  const char * str );

extern  void fl_replace_choice_f( FL_OBJECT *  ob,
									int          numb,
									const char * fmt,
									... );

extern  void fl_delete_choice( FL_OBJECT * ob,
                                 int         numb );

extern  void fl_set_choice( FL_OBJECT * ob,
                              int         choice );

extern  void fl_set_choice_text( FL_OBJECT  * ob,
                                   const char * txt );

extern  void fl_set_choice_text_f( FL_OBJECT *  ob,
									 const char * fmt,
									 ... );

extern  int fl_get_choice( FL_OBJECT * ob );

extern  const char * fl_get_choice_item_text( FL_OBJECT * ob,
                                                int         n );

extern  int fl_get_choice_maxitems( FL_OBJECT * ob );

extern  const char * fl_get_choice_text( FL_OBJECT * ob );

extern  void fl_set_choice_fontsize( FL_OBJECT * ob,
                                       int         size );

extern  void fl_set_choice_fontstyle( FL_OBJECT * ob,
                                        int         style );

extern  void fl_set_choice_align( FL_OBJECT * ob,
                                    int         align );

extern  int fl_get_choice_item_mode( FL_OBJECT *  ob,
                                       int          item );

extern  void fl_set_choice_item_mode( FL_OBJECT    * ob,
                                        int            item,
                                        unsigned int   mode );

extern  void fl_set_choice_item_shortcut( FL_OBJECT  * ob,
                                            int          item,
                                            const char * sc );

extern  int fl_set_choice_entries( FL_OBJECT    * ob,
                                     FL_PUP_ENTRY * ent );

extern  int fl_set_choice_notitle( FL_OBJECT * ob,
                                     int         n );

extern  int fl_set_choice_align_bottom( FL_OBJECT * ob,
										  int         n );

/* ! defined FL_CHOICE_H */

/**
 * \file clipbd.h
 *
 * prototypes for clipboard stuff
 */


#define FL_CLIPBD_H

typedef Atom FL_CPTYPE;

typedef int ( * FL_LOSE_SELECTION_CB )( FL_OBJECT *, long );
typedef int ( * FL_SELECTION_CB )( FL_OBJECT *, long, const void *, long );

#define FL_SELECTION_CALLBACK        FL_SELECTION_CB
#define FL_LOSE_SELECTION_CALLBACK   FL_LOSE_SELECTION_CB

extern  int fl_stuff_clipboard( FL_OBJECT            * ob,
                                  long                   type,
                                  const void           * data,
                                  long                   size,
                                  FL_LOSE_SELECTION_CB   lose_callback );

extern  int fl_request_clipboard( FL_OBJECT       * ob,
                                    long              type,
                                    FL_SELECTION_CB   got_it_callback );

/* ! defined FL_CLIPBD_H */

/**
 * \file clock.h
 */


#define FL_CLOCK_H

enum {
    FL_ANALOG_CLOCK,
    FL_DIGITAL_CLOCK
};

#define FL_CLOCK_BOXTYPE   FL_UP_BOX
#define FL_CLOCK_COL1      FL_INACTIVE_COL
#define FL_CLOCK_COL2      FL_BOTTOM_BCOL
#define FL_CLOCK_LCOL      FL_BLACK
#define FL_CLOCK_ALIGN     FL_ALIGN_BOTTOM

#define FL_CLOCK_TOPCOL  FL_COL1

extern  FL_OBJECT * fl_create_clock( int          type,
                                       FL_Coord     x,
                                       FL_Coord     y,
                                       FL_Coord     w,
                                       FL_Coord     h,
                                       const char * s );

extern  FL_OBJECT * fl_add_clock( int          type,
                                    FL_Coord     x,
                                    FL_Coord     y,
                                    FL_Coord     w,
                                    FL_Coord     h,
                                    const char * s );

extern  void fl_get_clock( FL_OBJECT * ob,
                             int       * h,
                             int       * m,
                             int       * s );

extern  long fl_set_clock_adjustment( FL_OBJECT * ob,
                                        long        offset );

extern  void fl_set_clock_ampm( FL_OBJECT * ob,
                                  int         y );

/* ! defined FL_CLOCK_H */

/**
 * \file counter.h
 */


#define FL_COUNTER_H

typedef enum {
    FL_NORMAL_COUNTER,
    FL_SIMPLE_COUNTER
} FL_COUNTER_TYPE;

/***** Defaults *****/

#define FL_COUNTER_BOXTYPE  FL_UP_BOX
#define FL_COUNTER_COL1     FL_COL1
#define FL_COUNTER_COL2     FL_BLUE           /* ct label     */
#define FL_COUNTER_LCOL     FL_LCOL           /* ct reporting */
#define FL_COUNTER_ALIGN    FL_ALIGN_BOTTOM

/***** Others *****/

#define FL_COUNTER_BW       FL_BOUND_WIDTH

/***** Routines *****/

extern  FL_OBJECT * fl_create_counter( int          type,
                                         FL_Coord     x,
                                         FL_Coord     y,
                                         FL_Coord     w,
                                         FL_Coord     h,
                                         const char * label );

extern  FL_OBJECT * fl_add_counter( int          type,
                                      FL_Coord     x,
                                      FL_Coord     y,
                                      FL_Coord     w,
                                      FL_Coord     h,
                                      const char * label );

extern  void fl_set_counter_value( FL_OBJECT * ob,
                                     double      val );

extern  void fl_set_counter_bounds( FL_OBJECT * ob,
                                      double      min,
                                      double      max );

extern  void fl_set_counter_step( FL_OBJECT * ob,
                                    double      s,
                                    double      l );

extern  void fl_set_counter_precision( FL_OBJECT * ob,
                                         int         prec );

extern  int fl_get_counter_precision( FL_OBJECT * ob );

extern  void fl_set_counter_return( FL_OBJECT    * ob,
                                      unsigned int   how );

extern  double fl_get_counter_value( FL_OBJECT * ob );

extern  void fl_get_counter_bounds( FL_OBJECT * ob,
                                      double    * min,
                                      double    * max );

extern  void fl_get_counter_step( FL_OBJECT * ob,
                                    double    * s,
                                    double    * l );

extern  void fl_set_counter_filter( FL_OBJECT     * ob,
                                      FL_VAL_FILTER   filter );

/* Functions to set and get the timeout value used by the
 * counter code to control modification of the counter value. */

extern  int fl_get_counter_repeat( FL_OBJECT * ob );

extern  void fl_set_counter_repeat( FL_OBJECT * ob,
                                      int         millisec );

extern  int fl_get_counter_min_repeat( FL_OBJECT * ob );

extern  void fl_set_counter_min_repeat( FL_OBJECT * ob,
                                          int         millisec );

extern  int fl_get_counter_speedjump( FL_OBJECT * ob );

extern  void fl_set_counter_speedjump( FL_OBJECT * ob,
                                         int         yes_no );

/* ! defined FL_COUNTER_H */

/**
 * \file cursor.h
 *
 * Cursor defs and prototypes
 */


#define FL_CURSOR_H

#include <X11/cursorfont.h>
# 1 "/usr/include/X11/cursorfont.h" 1 3
/*

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/


#define _X11_CURSORFONT_H_

#define XC_num_glyphs 154
#define XC_X_cursor 0
#define XC_arrow 2
#define XC_based_arrow_down 4
#define XC_based_arrow_up 6
#define XC_boat 8
#define XC_bogosity 10
#define XC_bottom_left_corner 12
#define XC_bottom_right_corner 14
#define XC_bottom_side 16
#define XC_bottom_tee 18
#define XC_box_spiral 20
#define XC_center_ptr 22
#define XC_circle 24
#define XC_clock 26
#define XC_coffee_mug 28
#define XC_cross 30
#define XC_cross_reverse 32
#define XC_crosshair 34
#define XC_diamond_cross 36
#define XC_dot 38
#define XC_dotbox 40
#define XC_double_arrow 42
#define XC_draft_large 44
#define XC_draft_small 46
#define XC_draped_box 48
#define XC_exchange 50
#define XC_fleur 52
#define XC_gobbler 54
#define XC_gumby 56
#define XC_hand1 58
#define XC_hand2 60
#define XC_heart 62
#define XC_icon 64
#define XC_iron_cross 66
#define XC_left_ptr 68
#define XC_left_side 70
#define XC_left_tee 72
#define XC_leftbutton 74
#define XC_ll_angle 76
#define XC_lr_angle 78
#define XC_man 80
#define XC_middlebutton 82
#define XC_mouse 84
#define XC_pencil 86
#define XC_pirate 88
#define XC_plus 90
#define XC_question_arrow 92
#define XC_right_ptr 94
#define XC_right_side 96
#define XC_right_tee 98
#define XC_rightbutton 100
#define XC_rtl_logo 102
#define XC_sailboat 104
#define XC_sb_down_arrow 106
#define XC_sb_h_double_arrow 108
#define XC_sb_left_arrow 110
#define XC_sb_right_arrow 112
#define XC_sb_up_arrow 114
#define XC_sb_v_double_arrow 116
#define XC_shuttle 118
#define XC_sizing 120
#define XC_spider 122
#define XC_spraycan 124
#define XC_star 126
#define XC_target 128
#define XC_tcross 130
#define XC_top_left_arrow 132
#define XC_top_left_corner 134
#define XC_top_right_corner 136
#define XC_top_side 138
#define XC_top_tee 140
#define XC_trek 142
#define XC_ul_angle 144
#define XC_umbrella 146
#define XC_ur_angle 148
#define XC_watch 150
#define XC_xterm 152

/* _X11_CURSORFONT_H_ */
# 4041 "include/forms.h" 2


enum {
    FL_INVISIBLE_CURSOR = -2,
    FL_DEFAULT_CURSOR   = -1,
    FL_BUSY_CURSOR      = 150 ,
    FL_CROSSHAIR_CURSOR = 130 ,
    FL_KILL_CURSOR      = 88 ,
    FL_NWARROW_CURSOR   = 132 ,
    FL_NEARROW_CURSOR   = 2 
};


#define XC_invisible   FL_INVISIBLE_CURSOR


extern  void fl_set_cursor( Window win,
                              int    name );

extern  void fl_set_cursor_color( int      name,
                                    FL_COLOR fg,
                                    FL_COLOR bg );

extern  int fl_create_bitmap_cursor( const char * source,
                                       const char * mask,
                                       int          w,
                                       int          h,
                                       int          hotx,
                                       int          hoty );

extern  int fl_create_animated_cursor( int * cur_names,
                                         int   timeout );

#define fl_reset_cursor( win )   fl_set_cursor( win, FL_DEFAULT_CURSOR );

/* ! defined FL_CURSOR_H */

/**
 * \file dial.h
 */


#define FL_DIAL_H

typedef enum {
    FL_NORMAL_DIAL,
    FL_LINE_DIAL,
    FL_FILL_DIAL
} FL_DIAL_TYPE;

enum {
    FL_DIAL_CW,
    FL_DIAL_CCW
};

/***** Defaults *****/

#define FL_DIAL_BOXTYPE     FL_FLAT_BOX
#define FL_DIAL_COL1        FL_COL1
#define FL_DIAL_COL2        FL_RIGHT_BCOL
#define FL_DIAL_LCOL        FL_LCOL
#define FL_DIAL_ALIGN       FL_ALIGN_BOTTOM

/***** Others   *****/

#define FL_DIAL_TOPCOL      FL_COL1

/***** Routines *****/

extern  FL_OBJECT * fl_create_dial( int          type,
                                      FL_Coord     x,
                                      FL_Coord     y,
                                      FL_Coord     w,
                                      FL_Coord     h,
                                      const char * label );

extern  FL_OBJECT * fl_add_dial( int          type,
                                   FL_Coord     x,
                                   FL_Coord     y,
                                   FL_Coord     w,
                                   FL_Coord     h,
                                   const char * label );

extern  void fl_set_dial_value( FL_OBJECT * obj,
                                  double      val );

extern  double fl_get_dial_value( FL_OBJECT * obj );

extern  void fl_set_dial_bounds( FL_OBJECT * obj,
                                   double      min,
                                   double      max );

extern  void fl_get_dial_bounds( FL_OBJECT * obj,
                                   double    * min,
                                   double    * max );

extern  void fl_set_dial_step( FL_OBJECT * obj,
                                 double      value );

extern  double fl_get_dial_step( FL_OBJECT * obj );

extern  void fl_set_dial_return( FL_OBJECT    * obj,
                                   unsigned int   value );

extern  void fl_set_dial_angles( FL_OBJECT * obj,
                                   double      amin,
                                   double      amax );

extern  void fl_get_dial_angles( FL_OBJECT * obj,
                                   double    * amin,
                                   double    * amax );

extern  void fl_set_dial_cross( FL_OBJECT * obj,
                                  int         flag );

#define fl_set_dial_crossover  fl_set_dial_cross

extern  void fl_set_dial_direction( FL_OBJECT * obj,
                                      int         dir );

extern  int fl_get_dial_direction( FL_OBJECT * obj );


/* ! defined FL_DIAL_H */

/**
 * \file filesys.h
 *
 *  Convenience functions to read a directory
 */


#define FL_FILESYS_H

/*  File types */

enum {
    FT_FILE,
    FT_DIR,
    FT_LINK,
    FT_SOCK,
    FT_FIFO,
    FT_BLK,
    FT_CHR,
    FT_OTHER
};

typedef struct {
    char          * name;           /* entry name             */
    int             type;           /* FILE_TYPE              */
    long            dl_mtime;       /* file modification time */
    unsigned long   dl_size;        /* file size in bytes     */
} FL_Dirlist;

enum {
    FL_ALPHASORT = 1,       /* sort in alphabetic order           */
    FL_RALPHASORT,          /* sort in reverse alphabetic order   */
    FL_MTIMESORT,           /* sort according to modifcation time */
    FL_RMTIMESORT,          /* sort in reverse modificaiton time  */
    FL_SIZESORT,            /* sort in increasing size order      */
    FL_RSIZESORT,           /* sort in decreasing size order      */
    FL_CASEALPHASORT,       /* sort case insensitive              */
    FL_RCASEALPHASORT       /* sort case insensitive              */
};

typedef int ( * FL_DIRLIST_FILTER )( const char *, int );

/* read dir with pattern filtering. All dirs read might be cached.
 * Must not change dirlist in anyway. */

extern  const FL_Dirlist * fl_get_dirlist( const char * dir,
                                             const char * pattern,
                                             int        * n,
                                             int          rescan );

extern  FL_DIRLIST_FILTER fl_set_dirlist_filter( FL_DIRLIST_FILTER filter );

extern  int fl_set_dirlist_sort( int method );

extern  int fl_set_dirlist_filterdir( int yes );

extern  void fl_free_dirlist( FL_Dirlist * dl );

/* ! defined FL_FILESYS_H */

/**
 * \file flps.h
 */


#define FLPS_H

/* postscript stuff */

enum {
   FLPS_AUTO,                  /* switch to landscale if does not fit */
   FLPS_LANDSCAPE,             /* landscape always                    */
   FLPS_PORTRAIT,              /* portrait always                     */
   FLPS_BESTFIT                /* even margins/best fit               */
};

enum {
  FLPS_BW = -1,
  FLPS_GRAYSCALE,
  FLPS_COLOR
};

typedef struct {
    int          ps_color;
    int          orientation;
    int          auto_fit;
    int          drawbox;
    int          eps;
    float        xdpi,
                 ydpi;
    float        paper_w,
                 paper_h;
    float        gamma;
    const char * tmpdir;
    int          printer_dpi;
    float        hm,
                 vm;
    float        xscale,
                 yscale;
    int          scale_text;
    int          first_page_only;
    int          clip;
} FLPS_CONTROL;

extern  FLPS_CONTROL * flps_init( void );

extern  int fl_object_ps_dump( FL_OBJECT  * ob,
                                 const char * fname );

/* ! defined FLPS_H */

/**
 * \file formbrowser.h
 *
 */


#define FL_FORMBROWSER_H

enum {
    FL_NORMAL_FORMBROWSER
};

enum {
   FL_SMOOTH_SCROLL,
   FL_JUMP_SCROLL
};

#define   FL_FORMBROWSER_BOXTYPE  FL_DOWN_BOX
#define   FL_FORMBROWSER_COL1     FL_COL1
#define   FL_FORMBROWSER_ALIGN    FL_ALIGN_TOP

extern  int fl_addto_formbrowser( FL_OBJECT * ob,
                                    FL_FORM   * form );

extern  FL_FORM * fl_delete_formbrowser_bynumber( FL_OBJECT * ob,
                                                    int         num );

extern  int fl_delete_formbrowser( FL_OBJECT * ob,
                                     FL_FORM   * form );

extern  FL_FORM * fl_replace_formbrowser( FL_OBJECT * ob,
                                            int         num,
                                            FL_FORM   * form );

extern  int fl_insert_formbrowser( FL_OBJECT * ob,
                                     int         line,
                                     FL_FORM   * new_form );

extern  int fl_get_formbrowser_area( FL_OBJECT * ob,
                                       int       * x,
                                       int       * y,
                                       int       * w,
                                       int       * h );

extern  void fl_set_formbrowser_scroll( FL_OBJECT * ob,
                                          int         how );

extern  void fl_set_formbrowser_hscrollbar( FL_OBJECT * ob,
                                              int         how );

extern  void fl_set_formbrowser_vscrollbar( FL_OBJECT * ob,
                                              int         how );

extern  FL_FORM *fl_get_formbrowser_topform( FL_OBJECT * ob );

extern  int fl_set_formbrowser_topform( FL_OBJECT * ob,
                                          FL_FORM   * form );

extern  FL_FORM * fl_set_formbrowser_topform_bynumber( FL_OBJECT * ob,
                                                         int         n );

extern  int fl_set_formbrowser_xoffset( FL_OBJECT * ob,
                                          int         offset );

extern  int fl_set_formbrowser_yoffset( FL_OBJECT * ob,
                                          int         offset );

extern  int fl_get_formbrowser_xoffset( FL_OBJECT * ob );

extern  int fl_get_formbrowser_yoffset( FL_OBJECT * ob );

extern  int fl_find_formbrowser_form_number( FL_OBJECT * ob,
                                               FL_FORM   * form );

extern  FL_OBJECT * fl_add_formbrowser( int          type,
                                          FL_Coord     x,
                                          FL_Coord     y,
                                          FL_Coord     w,
                                          FL_Coord     h,
                                          const char * label );

extern  FL_OBJECT * fl_create_formbrowser( int          type,
                                             FL_Coord     x,
                                             FL_Coord     y,
                                             FL_Coord     w,
                                             FL_Coord     h,
                                             const char * label );

extern  int fl_get_formbrowser_numforms( FL_OBJECT * ob );

#define fl_get_formbrowser_forms  fl_get_formbrowser_numforms

extern  FL_FORM * fl_get_formbrowser_form( FL_OBJECT * ob,
                                             int         n );

/* ! defined FL_FORMBROWSER_H */

/**
 * \file frame.h
 */


#define FL_FRAME_H

/* types of frames */

enum {
    FL_NO_FRAME,
    FL_UP_FRAME,
    FL_DOWN_FRAME,
    FL_BORDER_FRAME,
    FL_SHADOW_FRAME,
    FL_ENGRAVED_FRAME,
    FL_ROUNDED_FRAME,
    FL_EMBOSSED_FRAME,
    FL_OVAL_FRAME
};

#define FL_FRAME_COL1   FL_BLACK   /* border color     */
#define FL_FRAME_COL2   FL_COL1    /* label background */
#define FL_FRAME_LCOL   FL_BLACK   /* label color      */

extern  FL_OBJECT * fl_create_frame( int          type,
                                       FL_Coord     x,
                                       FL_Coord     y,
                                       FL_Coord     w,
                                       FL_Coord     h,
                                       const char * label );

extern  FL_OBJECT * fl_add_frame( int          type,
                                    FL_Coord     x,
                                    FL_Coord     y,
                                    FL_Coord     w,
                                    FL_Coord     h,
                                    const char * label );

/* labeld frame */

extern  FL_OBJECT * fl_create_labelframe( int          type,
                                            FL_Coord     x,
                                            FL_Coord     y,
                                            FL_Coord     w,
                                            FL_Coord     h,
                                            const char * label );

extern  FL_OBJECT * fl_add_labelframe( int          type,
                                         FL_Coord     x,
                                         FL_Coord     y,
                                         FL_Coord     w,
                                         FL_Coord     h,
                                         const char * label );

/* ! defined FL_FRAME_H */

/**
 * \file free.h
 *
 *  Object Class: Free
 */


#define FL_FREE_H


typedef enum {
    FL_NORMAL_FREE,
    FL_INACTIVE_FREE,
    FL_INPUT_FREE,
    FL_CONTINUOUS_FREE,
    FL_ALL_FREE
} FL_FREE_TYPE;

#define FL_SLEEPING_FREE  FL_INACTIVE_FREE

extern  FL_OBJECT * fl_create_free( int            type,
                                      FL_Coord       x,
                                      FL_Coord       y,
                                      FL_Coord       w,
                                      FL_Coord       h,
                                      const char   * label,
                                      FL_HANDLEPTR   handle );

extern  FL_OBJECT * fl_add_free( int            type,
                                   FL_Coord       x,
                                   FL_Coord       y,
                                   FL_Coord       w,
                                   FL_Coord       h,
                                   const char   * label,
                                   FL_HANDLEPTR   handle );

/* ! defined FL_FREE_H */

/**
 * \file goodies.h
 */


#define FL_GOODIES_H

/***** Resources and misc. goodie routines ******/

#define FLAlertDismissLabel     "flAlert.dismiss.label"
#define FLAlertTitle            "flAlert.title"

#define FLQuestionYesLabel      "flQuestion.yes.label"
#define FLQuestionNoLabel       "flQuestion.no.label"
#define FLQuestionTitle         "flQuestion.title"

#define FLOKLabel               "flInput.ok.label"
#define FLInputClearLabel       "flInput.clear.label"
#define FLInputCancelLabel      "flInput.cancel.label"
#define FLInputTitle            "flInput.title"

#define FLChoiceTitle           "flChoice.title"

extern  void fl_set_goodies_font(
        int style,
        int size
        );

/*********** messages and questions **************/

extern  void fl_show_message( const char *,
                                const char *,
                                const char * );

extern  void fl_show_messages( const char * );

#define fl_show_msg fl_show_messages_f
extern  void fl_show_messages_f( const char *,
								   ... );

extern  void fl_hide_message( void );

#define fl_hide_msg       fl_hide_message
#define fl_hide_messages  fl_hide_message

extern  int fl_show_question( const char *,
                                int );

extern  void fl_hide_question( void );

extern  void fl_show_alert( const char *,
                              const char *,
                              const char *,
                              int );


#define fl_show_alert2  fl_show_alert_f
extern  void fl_show_alert_f( int          c,
								const char * fmt,
                               ... );

extern  void fl_hide_alert( void );

extern  const char * fl_show_input( const char *,
                                      const char * );

extern  void fl_hide_input( void );

extern  const char * fl_show_simple_input( const char *,
                                             const char * );

extern  int fl_show_colormap( int );

/********* choices *****************/

extern  int fl_show_choices( const char *,
                               int,
                               const char *,
                               const char *,
                               const char *,
                               int );

extern  int fl_show_choice( const char *,
                              const char *,
                              const char *,
                              int,
                              const char *,
                              const char *,
                              const char *,
                              int );

extern  void fl_hide_choice( void );

extern  void fl_set_choices_shortcut( const char *,
                                       const char *,
                                       const char * );

#define fl_set_choice_shortcut fl_set_choices_shortcut

/************ one liner ***************/

extern  void fl_show_oneliner( const char *,
                                 FL_Coord,
                                 FL_Coord );

extern  void fl_hide_oneliner( void );

extern  void fl_set_oneliner_font( int,
                                     int );

extern  void fl_set_oneliner_color( FL_COLOR,
                                      FL_COLOR );

extern  void fl_set_tooltip_font( int,
                                    int );

extern  void fl_set_tooltip_color( FL_COLOR,
                                     FL_COLOR );

extern  void fl_set_tooltip_boxtype( int );

extern  void fl_set_tooltip_lalign( int );

/************* command log **************/

typedef struct {
    FL_FORM   * form;
    void      * vdata;                  /* UNUSED, remove in later version */
    char      * cdata;                  /* UNUSED, remove in later version */
    long        ldata;                  /* UNUSED, remove in later version */
    FL_OBJECT * browser;
    FL_OBJECT * close_browser;
    FL_OBJECT * clear_browser;
} FD_CMDLOG;




#define FL_PID_T long


extern  long  fl_exe_command( const char *,
                                   int );

extern  int fl_end_command( long  );

extern  int fl_check_command( long  );

extern  FILE * fl_popen( const char *,
                           const char * );

extern  int fl_pclose( FILE * );

extern  int fl_end_all_command( void );

extern  void fl_show_command_log( int );

extern  void fl_hide_command_log( void );

extern  void fl_clear_command_log( void );

extern  void fl_addto_command_log( const char * );

extern  void fl_addto_command_log_f( const char *,
									   ...);

extern  void fl_set_command_log_position( int,
                                            int );

extern  FD_CMDLOG * fl_get_command_log_fdstruct( void );

/* Aliases */

#define fl_open_command    fl_exe_command
#define fl_close_command   fl_end_command

/******* File selector *****************/

#define FL_MAX_FSELECTOR  6

typedef struct {
    FL_FORM   * fselect;
    void      * vdata;
    void      * cdata;
    long        ldata;
    FL_OBJECT * browser,
              * input,
              * prompt,
              * resbutt;
    FL_OBJECT * patbutt,
              * dirbutt,
              * cancel,
              * ready;
    FL_OBJECT * dirlabel,
              * patlabel;
    FL_OBJECT * appbutt[ 3 ];
} FD_FSELECTOR;

extern  int fl_use_fselector( int );

extern  const char * fl_show_fselector( const char *,
                                          const char *,
                                          const char *,
                                          const char * );

extern  void fl_hide_fselector( void );

extern  void fl_set_fselector_fontsize( int );

extern  void fl_set_fselector_fontstyle( int );

extern  void fl_set_fselector_placement( int );

extern  void fl_set_fselector_border( int );

#define fl_set_fselector_transient( b )   \
            fl_set_fselector_border( ( b ) ? FL_TRANSIENT : FL_FULLBORDER )

extern  void fl_set_fselector_callback( FL_FSCB,
                                          void * );

extern  const char * fl_get_filename( void );

extern  const char * fl_get_directory( void );

extern  const char * fl_get_pattern( void );

extern  int fl_set_directory( const char * );

extern  void fl_set_pattern( const char * );

extern  void fl_refresh_fselector( void );

extern  void fl_add_fselector_appbutton( const char *,
                                           void ( * )( void * ),
                                           void * );

extern  void fl_remove_fselector_appbutton( const char * );

extern  void fl_disable_fselector_cache( int );

extern  void fl_invalidate_fselector_cache( void );

extern  FL_FORM * fl_get_fselector_form( void );

extern  FD_FSELECTOR * fl_get_fselector_fdstruct( void );

extern  void fl_hide_fselector( void );

extern  void fl_set_fselector_filetype_marker( int,
                                                 int,
                                                 int,
                                                 int,
                                                 int );

#define fl_show_file_selector     fl_show_fselector
#define fl_set_fselector_cb       fl_set_fselector_callback

#define fl_set_fselector_title( s )   \
        fl_set_form_title( fl_get_fselector_form( ), s )

extern  int fl_goodies_atclose( FL_FORM *,
                                  void * );

/* ! defined FL_GOODIES_H */

/**
 * \file input.h
 */


#define FL_INPUT_H


/***** Types    *****/

typedef enum {
    FL_NORMAL_INPUT,
    FL_FLOAT_INPUT,
    FL_INT_INPUT,
    FL_DATE_INPUT,
    FL_MULTILINE_INPUT,
    FL_HIDDEN_INPUT,
    FL_SECRET_INPUT
} FL_INPUT_TYPE;

/* for date input */

enum {
    FL_INPUT_MMDD,
    FL_INPUT_DDMM
};

enum {
    FL_NORMAL_INPUT_MODE,
    FL_DOS_INPUT_MODE
};

/***** Defaults *****/

#define FL_INPUT_BOXTYPE    FL_DOWN_BOX
#define FL_INPUT_COL1       FL_COL1
#define FL_INPUT_COL2       FL_MCOL
#define FL_INPUT_LCOL       FL_LCOL
#define FL_INPUT_ALIGN      FL_ALIGN_LEFT

/***** Others   *****/

#define FL_INPUT_TCOL       FL_LCOL
#define FL_INPUT_CCOL       FL_BLUE

#define FL_RINGBELL         ( 1 << 4 )

/***** Routines *****/

extern  FL_OBJECT * fl_create_input( int          type,
                                       FL_Coord     x,
                                       FL_Coord     y,
                                       FL_Coord     w,
                                       FL_Coord     h,
                                       const char * label );

extern  FL_OBJECT * fl_add_input( int          type,
                                    FL_Coord     x,
                                    FL_Coord     y,
                                    FL_Coord     w,
                                    FL_Coord     h,
                                    const char * label );

extern  void fl_set_input( FL_OBJECT  * ob,
                             const char * str );

extern  void fl_set_input_f( FL_OBJECT  * obj,
							   const char * fmt,
							   ... );

extern  void fl_set_input_return( FL_OBJECT    * ob,
                                    unsigned int   when );

extern  void fl_set_input_color( FL_OBJECT * ob,
                                   FL_COLOR    textcol,
                                   FL_COLOR    curscol );

extern  void fl_get_input_color( FL_OBJECT * ob,
                                   FL_COLOR  * textcol,
                                   FL_COLOR  * curscol );

extern  void fl_set_input_scroll( FL_OBJECT * ob,
                                    int         yes );

extern  void fl_set_input_cursorpos( FL_OBJECT * ob,
                                       int         xpos,
                                       int         ypos );

extern  void fl_set_input_selected( FL_OBJECT * ob,
                                      int         yes );

extern  void fl_set_input_selected_range( FL_OBJECT * ob,
                                            int         begin,
                                            int         end );

extern  const char *fl_get_input_selected_range( FL_OBJECT * ob,
                                                   int       * begin,
                                                   int       * end );

extern  void fl_set_input_maxchars( FL_OBJECT * ob,
                                      int         maxchars );

extern  void fl_set_input_format( FL_OBJECT * ob,
                                    int         fmt,
                                    int         sep );

extern  void fl_set_input_hscrollbar( FL_OBJECT * ob,
                                        int         pref );

extern  void fl_set_input_vscrollbar( FL_OBJECT * ob,
                                        int         pref );

extern  void fl_set_input_topline( FL_OBJECT * ob,
                                     int         top );

extern  void fl_set_input_scrollbarsize( FL_OBJECT * ob,
                                           int         hh,
                                           int         vw );

extern  void fl_get_input_scrollbarsize( FL_OBJECT * ob,
                                           int       * hh,
                                           int       * vw );

extern  void fl_set_input_xoffset( FL_OBJECT * ob,
                                     int         xoff );

extern  int fl_get_input_xoffset( FL_OBJECT * ob );

extern  int fl_set_input_fieldchar( FL_OBJECT * ob,
                                      int         fchar );

extern  int fl_get_input_topline( FL_OBJECT * ob );

extern  int fl_get_input_screenlines( FL_OBJECT * ob );

extern  int fl_get_input_cursorpos( FL_OBJECT * ob,
                                      int       * x,
                                      int       * y );

extern  void fl_set_input_cursor_visible( FL_OBJECT * ob,
                                            int         visible );

extern  int fl_get_input_numberoflines( FL_OBJECT * ob );

extern  void fl_get_input_format( FL_OBJECT * ob,
                                    int       * fmt,
                                    int       * sep );

extern  const char * fl_get_input( FL_OBJECT * ob );

typedef int ( * FL_INPUTVALIDATOR )(FL_OBJECT *,
                                    const char *,
                                    const char *,
                                    int );

extern  FL_INPUTVALIDATOR fl_set_input_filter( FL_OBJECT         * ob,
                                                 FL_INPUTVALIDATOR   validate );

extern  int fl_validate_input( FL_OBJECT *obj );

#define fl_set_input_shortcut   fl_set_object_shortcut

/* edit keys. */

typedef struct {
    /* basic editing */

    long del_prev_char;     /* delete previous char    */
    long del_next_char;     /* delete next char        */
    long del_prev_word;     /* delete previous word    */
    long del_next_word;     /* delete next word        */

    /* movement */

    long moveto_prev_line;  /* one line  up             */
    long moveto_next_line;  /* one line down            */
    long moveto_prev_char;  /* one char left            */
    long moveto_next_char;  /* one char right           */
    long moveto_prev_word;  /* one word left            */
    long moveto_next_word;  /* one word right           */
    long moveto_prev_page;  /* one page up              */
    long moveto_next_page;  /* one page down            */
    long moveto_bol;        /* move to begining of line */
    long moveto_eol;        /* move to end of line      */
    long moveto_bof;        /* move to begin of file    */
    long moveto_eof;        /* move to end of file      */

    /* misc. stuff */

    long transpose;         /* switch two char positions */
    long paste;             /* paste the edit buffer    */
    long backspace;         /* another  del_prev_char   */
    long del_to_bol;        /* cut to begining of line  */
    long del_to_eol;        /* cut to end of line       */
    long clear_field;       /* delete everything        */
    long del_to_eos;        /* not implemented          */
} FL_EditKeymap;

extern  void fl_set_input_editkeymap( const FL_EditKeymap * keymap );

extern  void fl_get_input_editkeymap( FL_EditKeymap * keymap );

extern  void fl_set_default_editkeymap( void );

extern  int fl_set_input_mode( int mode );

/* ! defined FL_INPUT_H */

/**
 * \file menu.h
 */


#define FL_MENU_H


/************   Object Class: Menu         ************/

typedef enum {
    FL_TOUCH_MENU,
    FL_PUSH_MENU,
    FL_PULLDOWN_MENU
} FL_MENU_TYPE;

/***** Defaults *****/

#define FL_MENU_BOXTYPE     FL_BORDER_BOX
#define FL_MENU_COL1        FL_COL1
#define FL_MENU_COL2        FL_MCOL
#define FL_MENU_LCOL        FL_LCOL
#define FL_MENU_ALIGN       FL_ALIGN_CENTER

/***** Others   *****/

#define FL_MENU_MAXITEMS    128
#define FL_MENU_MAXSTR      64        /* not used anymore! JTT */

/***** Routines *****/

extern  FL_OBJECT * fl_create_menu( int          type,
                                      FL_Coord     x,
                                      FL_Coord     y,
                                      FL_Coord     w,
                                      FL_Coord     h,
                                      const char * label );

extern  FL_OBJECT * fl_add_menu( int          type,
                                   FL_Coord     x,
                                   FL_Coord     y,
                                   FL_Coord     w,
                                   FL_Coord     h,
                                   const char * label );

extern  void fl_clear_menu( FL_OBJECT * ob );

extern  void fl_set_menu( FL_OBJECT  * ob,
                            const char * menustr ,
                            ... );

extern  int fl_addto_menu( FL_OBJECT  * ob,
                             const char * menustr,
                             ... );

extern  void fl_replace_menu_item( FL_OBJECT  * ob,
                                     int          numb,
                                     const char * str,
                                     ... );

extern  void fl_delete_menu_item( FL_OBJECT * ob,
                                    int         numb );

extern  FL_PUP_CB fl_set_menu_item_callback( FL_OBJECT *  ob,
                                               int          numb,
                                               FL_PUP_CB    cb );

extern  void fl_set_menu_item_shortcut( FL_OBJECT  * ob,
                                          int          numb,
                                          const char * str );

extern  void fl_set_menu_item_mode( FL_OBJECT    * ob,
                                      int            numb,
                                      unsigned int   mode );

extern  void fl_show_menu_symbol( FL_OBJECT * ob,
                                    int         show );

extern  void fl_set_menu_popup( FL_OBJECT * ob,
                                  int         pup );

extern  int fl_get_menu_popup( FL_OBJECT * ob );

extern  int fl_get_menu( FL_OBJECT * ob );

extern  const char * fl_get_menu_item_text( FL_OBJECT * ob,
                                              int         numb );

extern  int fl_get_menu_maxitems( FL_OBJECT * ob );

extern  unsigned int fl_get_menu_item_mode( FL_OBJECT * ob,
                                              int         numb );

extern  const char *fl_get_menu_text( FL_OBJECT * ob );

extern  int fl_set_menu_entries( FL_OBJECT    * ob,
                                   FL_PUP_ENTRY * ent );

extern  int fl_set_menu_notitle( FL_OBJECT * ob,
                                   int         off );

extern  int fl_set_menu_item_id( FL_OBJECT * ob,
                                   int         item,
                                   int         id );

/* ! defined FL_MENU_H */



#define FL_NMENU_H


/* Nmenu object types */

enum {
    FL_NORMAL_NMENU,
    FL_NORMAL_TOUCH_NMENU,
    FL_BUTTON_NMENU,
    FL_BUTTON_TOUCH_NMENU
};

extern  FL_OBJECT *fl_create_nmenu(
        int,
        FL_Coord,
        FL_Coord,
        FL_Coord,
        FL_Coord,
        const char *
        );

extern  FL_OBJECT *fl_add_nmenu(
        int,
        FL_Coord,
        FL_Coord,
        FL_Coord,
        FL_Coord,
        const char *
        );

extern  int fl_clear_nmenu(
        FL_OBJECT *
        );

extern  FL_POPUP_ENTRY *fl_add_nmenu_items(
        FL_OBJECT  *,
        const char *,
        ...
        );

extern  FL_POPUP_ENTRY *fl_insert_nmenu_items(
        FL_OBJECT *,
        FL_POPUP_ENTRY *,
        const char     *,
        ...
        );

extern  FL_POPUP_ENTRY *fl_replace_nmenu_item(
        FL_OBJECT *,
        FL_POPUP_ENTRY *,
        const char *,
        ...
        );

extern  int fl_delete_nmenu_item(
        FL_OBJECT *,
        FL_POPUP_ENTRY *
        );

extern  FL_POPUP_ENTRY *fl_set_nmenu_items(
        FL_OBJECT *,
        FL_POPUP_ITEM *
        );

extern  FL_POPUP_ENTRY *fl_add_nmenu_items2(
		FL_OBJECT *,
		FL_POPUP_ITEM * );

extern  FL_POPUP_ENTRY *fl_insert_nmenu_items2(
		FL_OBJECT *,
		FL_POPUP_ENTRY *,
		FL_POPUP_ITEM  * );

extern  FL_POPUP_ENTRY *fl_replace_nmenu_items2(
		FL_OBJECT *,
		FL_POPUP_ENTRY *,
		FL_POPUP_ITEM * );

extern  FL_POPUP *fl_get_nmenu_popup(
        FL_OBJECT *
        );

extern  int fl_set_nmenu_popup(
        FL_OBJECT *,
        FL_POPUP  *
        );

extern  FL_POPUP_RETURN *fl_get_nmenu_item(
        FL_OBJECT *
        );

extern  FL_POPUP_ENTRY *fl_get_nmenu_item_by_value(
        FL_OBJECT *,
        long int
        );

extern  FL_POPUP_ENTRY *fl_get_nmenu_item_by_label(
        FL_OBJECT *,
        const char *
        );

extern  FL_POPUP_ENTRY *fl_get_nmenu_item_by_text(
        FL_OBJECT *,
        const char *
        );

extern  int fl_set_nmenu_policy(
        FL_OBJECT *,
        int
        );

extern  FL_COLOR fl_set_nmenu_hl_text_color(
        FL_OBJECT *,
        FL_COLOR
        );

/* ! defined FL_NMENU_H */

/**
 * \file positioner.h
 */


#define FL_POSITIONER_H


#define FL_NORMAL_POSITIONER      0
#define FL_OVERLAY_POSITIONER     1
#define FL_INVISIBLE_POSITIONER   2

/***** Defaults *****/

#define FL_POSITIONER_BOXTYPE   FL_DOWN_BOX
#define FL_POSITIONER_COL1      FL_COL1
#define FL_POSITIONER_COL2      FL_RED
#define FL_POSITIONER_LCOL      FL_LCOL
#define FL_POSITIONER_ALIGN     FL_ALIGN_BOTTOM

/***** Routines *****/

extern  FL_OBJECT * fl_create_positioner( int          type,
                                            FL_Coord     x,
                                            FL_Coord     y,
                                            FL_Coord     w,
                                            FL_Coord     h,
                                            const char * label );

extern  FL_OBJECT * fl_add_positioner( int          type,
                                         FL_Coord     x,
                                         FL_Coord     y,
                                         FL_Coord     w,
                                         FL_Coord     h,
                                         const char * label );

extern  void fl_set_positioner_xvalue( FL_OBJECT * ob,
                                         double      val );

extern  double fl_get_positioner_xvalue( FL_OBJECT * ob );

extern  void fl_set_positioner_xbounds( FL_OBJECT * ob,
                                          double      min,
                                          double      max );

extern  void fl_get_positioner_xbounds( FL_OBJECT * ob,
                                          double    * min,
                                          double    * max );

extern  void fl_set_positioner_yvalue( FL_OBJECT * ob,
                                         double      val );

extern  double fl_get_positioner_yvalue( FL_OBJECT * ob );

extern  void fl_set_positioner_ybounds( FL_OBJECT * ob,
                                          double      min,
                                          double      max );

extern  void fl_get_positioner_ybounds( FL_OBJECT * ob,
                                          double    * min,
                                          double    * max );

extern  void fl_set_positioner_xstep( FL_OBJECT * ob,
                                        double      value );

extern  void fl_set_positioner_ystep( FL_OBJECT * ob,
                                        double      value );

extern  void fl_set_positioner_return( FL_OBJECT    * ob,
                                         unsigned int   when );

extern  void fl_set_positioner_mouse_buttons( FL_OBJECT    * obj,
												unsigned int   mouse_buttons );

extern  void fl_get_positioner_mouse_buttons( FL_OBJECT    * obj,
												unsigned int * mouse_buttons );

extern  int fl_get_positioner_numb( FL_OBJECT * obj );


/* ! defined FL_POSITIONER_H */



#define FL_SCROLLBAR_H

enum {
    FL_VERT_SCROLLBAR,
    FL_HOR_SCROLLBAR,

    FL_VERT_THIN_SCROLLBAR,
    FL_HOR_THIN_SCROLLBAR,

    FL_VERT_NICE_SCROLLBAR,
    FL_HOR_NICE_SCROLLBAR,

    FL_VERT_PLAIN_SCROLLBAR,
    FL_HOR_PLAIN_SCROLLBAR,

    FL_HOR_BASIC_SCROLLBAR  = FL_HOR_PLAIN_SCROLLBAR,
    FL_VERT_BASIC_SCROLLBAR = FL_VERT_PLAIN_SCROLLBAR
};

enum {
	FL_NORMAL_SCROLLBAR,
	FL_THIN_SCROLLBAR,
	FL_NICE_SCROLLBAR,
	FL_PLAIN_SCROLLBAR
};

#define FL_SCROLLBAR_ALIGN   FL_ALIGN_BOTTOM


extern  FL_OBJECT * fl_create_scrollbar( int          type,
                                           FL_Coord     x,
                                           FL_Coord     y,
                                           FL_Coord     w,
                                           FL_Coord     h,
                                           const char * label );

extern  FL_OBJECT * fl_add_scrollbar( int          type,
                                        FL_Coord     x,
                                        FL_Coord     y,
                                        FL_Coord     w,
                                        FL_Coord     h,
                                        const char * label );

extern  double fl_get_scrollbar_value( FL_OBJECT * ob );

extern  void fl_set_scrollbar_value( FL_OBJECT * ob,
                                       double      val );

extern  void fl_set_scrollbar_size( FL_OBJECT * ob,
                                      double      val );

extern  double fl_get_scrollbar_size( FL_OBJECT * obj );

extern  void fl_set_scrollbar_increment( FL_OBJECT * ob,
                                           double      l,
                                           double      r );

extern  void fl_get_scrollbar_increment( FL_OBJECT * ob,
                                           double    * a,
                                           double    * b );

extern  void fl_set_scrollbar_bounds( FL_OBJECT * ob,
                                        double      b1,
                                        double      b2 );

extern  void fl_get_scrollbar_bounds( FL_OBJECT * ob,
                                        double    * b1,
                                        double    * b2 );

extern  void fl_set_scrollbar_return( FL_OBJECT    * ob,
                                        unsigned int   when );

extern  void fl_set_scrollbar_step( FL_OBJECT * ob,
                                      double      step );

/* ! defined FL_SCROLLBAR_H */

/**
 * \file select.h
 */


#define FL_SELECT_H


/* Select object types */

enum {
    FL_NORMAL_SELECT,
    FL_MENU_SELECT,
    FL_DROPLIST_SELECT
};

/* Defaults */

#define FL_SELECT_COL1          FL_COL1
#define FL_SELECT_COL2          FL_MCOL
#define FL_SELECT_LCOL          FL_LCOL
#define FL_SELECT_ALIGN         FL_ALIGN_LEFT

extern  FL_OBJECT *fl_create_select( int,
                                       FL_Coord,
                                       FL_Coord,
                                       FL_Coord,
                                       FL_Coord,
                                       const char * );

extern  FL_OBJECT *fl_add_select( int,
                                    FL_Coord,
                                    FL_Coord,
                                    FL_Coord,
                                    FL_Coord,
                                    const char * );

extern  int fl_clear_select( FL_OBJECT * );

extern  FL_POPUP_ENTRY *fl_add_select_items( FL_OBJECT  *,
                                               const char *,
                                               ... );

extern  FL_POPUP_ENTRY *fl_insert_select_items( FL_OBJECT *,
                                                  FL_POPUP_ENTRY *,
                                                  const char     *,
                                                  ... );

extern  FL_POPUP_ENTRY *fl_replace_select_item( FL_OBJECT *,
                                                  FL_POPUP_ENTRY *,
                                                  const char *,
                                                  ... );

extern  int fl_delete_select_item( FL_OBJECT *,
                                     FL_POPUP_ENTRY * );

extern  long fl_set_select_items( FL_OBJECT *,
                                    FL_POPUP_ITEM * );

extern  FL_POPUP *fl_get_select_popup( FL_OBJECT * );

extern  int fl_set_select_popup( FL_OBJECT *,
                                   FL_POPUP  * );

extern  FL_POPUP_RETURN *fl_get_select_item( FL_OBJECT * );

extern  FL_POPUP_RETURN *fl_set_select_item( FL_OBJECT *,
                                               FL_POPUP_ENTRY * );

extern  FL_POPUP_ENTRY *fl_get_select_item_by_value( FL_OBJECT *,
                                                       long );

extern  FL_POPUP_ENTRY *fl_get_select_item_by_label( FL_OBJECT *,
                                                       const char * );

extern  FL_POPUP_ENTRY * fl_get_select_item_by_label_f( FL_OBJECT  *,
														  const char *,
														  ... );

extern  FL_POPUP_ENTRY * fl_get_select_item_by_text_f( FL_OBJECT  * obj,
														 const char * fmt,
														 ... );

extern  FL_POPUP_ENTRY *fl_get_select_item_by_text( FL_OBJECT *,
                                                      const char * );

extern  FL_COLOR fl_get_select_text_color( FL_OBJECT * );

extern  FL_COLOR fl_set_select_text_color( FL_OBJECT *,
                                             FL_COLOR );

extern  int fl_get_select_text_font( FL_OBJECT *,
                                       int *,
                                       int * );

extern  int fl_set_select_text_font( FL_OBJECT *,
                                       int,
                                       int );

extern  int fl_get_select_text_align( FL_OBJECT * );

extern  int fl_set_select_text_align( FL_OBJECT *,
                                        int );

extern  int fl_set_select_policy( FL_OBJECT *,
                                    int );

/* ! defined FL_SELECT_H */

/**
 * \file slider.h
 *
 * Object Class: Slider
 */


#define FL_SLIDER_H


#define FL_HOR_FLAG     1
#define FL_SCROLL_FLAG  16

typedef enum {
    FL_VERT_SLIDER           = 0,
    FL_HOR_SLIDER            = FL_VERT_SLIDER          | 1 ,

    FL_VERT_FILL_SLIDER      = 2,
    FL_HOR_FILL_SLIDER       = FL_VERT_FILL_SLIDER     | 1 ,

    FL_VERT_NICE_SLIDER      = 4,
    FL_HOR_NICE_SLIDER       = FL_VERT_NICE_SLIDER     | 1 ,

    FL_VERT_BROWSER_SLIDER   = 6,
    FL_HOR_BROWSER_SLIDER    = FL_VERT_BROWSER_SLIDER  | 1 ,

	FL_VERT_PROGRESS_BAR     = 8,
	FL_HOR_PROGRESS_BAR      = FL_VERT_PROGRESS_BAR    | 1 ,

    /* The following are for use with scrollbars only! */

    /* For FL_VERT_SCROLLBAR and FL_HOR_SCROLLBAR */

    FL_VERT_BROWSER_SLIDER2   = FL_VERT_SLIDER         | 16 ,
    FL_HOR_BROWSER_SLIDER2    = FL_HOR_SLIDER          | 16 ,

    /* for FL_VERT_THIN_SCROLLBAR and FL_VERT_THIN_SCROLLBAR */

    FL_VERT_THIN_SLIDER       = FL_VERT_FILL_SLIDER    | 16 ,
    FL_HOR_THIN_SLIDER        = FL_HOR_FILL_SLIDER     | 16 ,

    /* For FL_VERT_NICE_SCROLLBAR and FL_HOR_NICE_SCROLLBAR */

    FL_VERT_NICE_SLIDER2      = FL_VERT_NICE_SLIDER    | 16 ,
    FL_HOR_NICE_SLIDER2       = FL_HOR_NICE_SLIDER     | 16 ,

    /* for use as FL_VERT_PLAIN_SCROLLBAR and FL_VERT_PLAIN_SCROLLBAR */

    FL_VERT_BASIC_SLIDER      = FL_VERT_BROWSER_SLIDER | 16 ,
    FL_HOR_BASIC_SLIDER       = FL_HOR_BROWSER_SLIDER  | 16 
} FL_SLIDER_TYPE;

/***** Defaults *****/

#define FL_SLIDER_BW1       FL_BOUND_WIDTH
#define FL_SLIDER_BW2       FL_abs( FL_BOUND_WIDTH )
#define FL_SLIDER_BOXTYPE   FL_DOWN_BOX
#define FL_SLIDER_COL1      FL_COL1
#define FL_SLIDER_COL2      FL_COL1
#define FL_SLIDER_LCOL      FL_LCOL
#define FL_SLIDER_ALIGN     FL_ALIGN_BOTTOM

/***** Others   *****/

#define FL_SLIDER_FINE      0.25
#define FL_SLIDER_WIDTH     0.10

#define FL_SLIDER_MAX_PREC  10

/***** Routines *****/

extern  FL_OBJECT * fl_create_slider( int          type,
                                        FL_Coord     x,
                                        FL_Coord     y,
                                        FL_Coord     w,
                                        FL_Coord     h,
                                        const char * label );

extern  FL_OBJECT * fl_add_slider( int          type,
                                     FL_Coord     x,
                                     FL_Coord     y,
                                     FL_Coord     w,
                                     FL_Coord     h,
                                     const char * label );

extern  FL_OBJECT * fl_create_valslider( int          type,
                                           FL_Coord     x,
                                           FL_Coord     y,
                                           FL_Coord     w,
                                           FL_Coord     h,
                                           const char * label );

extern  FL_OBJECT * fl_add_valslider( int          type,
                                        FL_Coord     x,
                                        FL_Coord     y,
                                        FL_Coord     w,
                                        FL_Coord     h,
                                        const char * label );

extern  void fl_set_slider_value( FL_OBJECT * ob,
                                    double      val );

extern  double fl_get_slider_value( FL_OBJECT * ob );

extern  void fl_set_slider_bounds( FL_OBJECT * ob,
                                     double      min,
                                     double      max );

extern  void fl_get_slider_bounds( FL_OBJECT * ob,
                                     double    * min,
                                     double    * max );

extern  void fl_set_slider_return( FL_OBJECT    * ob,
                                     unsigned int   value );

extern  void fl_set_slider_step( FL_OBJECT * ob,
                                   double      value );

extern  void fl_set_slider_increment( FL_OBJECT * ob,
                                        double      l,
                                        double      r );

extern  void fl_get_slider_increment( FL_OBJECT * ob,
                                        double    * l,
                                        double    * r );

extern  void fl_set_slider_size( FL_OBJECT * ob,
                                   double      size );

extern  double fl_get_slider_size( FL_OBJECT * obj );

extern  void fl_set_slider_precision( FL_OBJECT * ob,
                                        int         prec );

extern  void fl_set_slider_filter( FL_OBJECT     * ob,
                                     FL_VAL_FILTER   filter );

extern  int fl_get_slider_repeat( FL_OBJECT * );

extern  void fl_set_slider_repeat( FL_OBJECT *,
									 int );

/* ! defined FL_SLIDER_H */


#define FL_SPINNER_H

typedef enum {
    FL_INT_SPINNER,
    FL_FLOAT_SPINNER
} FL_SPINNER_TYPE;

extern  FL_OBJECT * fl_create_spinner( int            type,
                                         FL_Coord       x,
                                         FL_Coord       y,
                                         FL_Coord       w,
                                         FL_Coord       h,
                                         const char * label );

extern  FL_OBJECT * fl_add_spinner( int            type,
                                      FL_Coord   x,
                                      FL_Coord   y,
                                      FL_Coord   w,
                                      FL_Coord   h,
                                      const char * label );

extern  double fl_get_spinner_value( FL_OBJECT * obj );

extern  double fl_set_spinner_value( FL_OBJECT * obj,
                                       double      val );

extern  void fl_set_spinner_bounds( FL_OBJECT * obj,
                                      double      min,
                                      double      max );

extern  void fl_get_spinner_bounds( FL_OBJECT * obj,
                                      double    * min,
                                      double    * max );

extern  void fl_set_spinner_step( FL_OBJECT * obj,
                                    double      step );

extern  double fl_get_spinner_step( FL_OBJECT * obj );

extern  void fl_set_spinner_precision( FL_OBJECT * obj,
                                         int         prec );

extern  int fl_get_spinner_precision( FL_OBJECT * obj );

extern  FL_OBJECT * fl_get_spinner_input( FL_OBJECT * obj );

extern  FL_OBJECT * fl_get_spinner_up_button( FL_OBJECT * obj );

extern  FL_OBJECT * fl_get_spinner_down_button( FL_OBJECT * obj );


/* ! defined FL_SPINNER_H */

/**
 * \file tabfolder.h
 */


#define FL_FOLDER_H

enum {
    FL_TOP_TABFOLDER,       /* tab on top */
    FL_BOTTOM_TABFOLDER,
    FL_LEFT_TABFOLDER,
    FL_RIGHT_TABFOLDER,
    FL_NORMAL_TABFOLDER = FL_TOP_TABFOLDER
};

enum {
    FL_NO,
    FL_FIT,
    FL_ENLARGE_ONLY
};

extern  FL_OBJECT * fl_create_tabfolder( int          type,
                                           FL_Coord     x,
                                           FL_Coord     y,
                                           FL_Coord     w,
                                           FL_Coord     h,
                                           const char * label );

extern  FL_OBJECT * fl_add_tabfolder( int          type,
                                        FL_Coord     x,
                                        FL_Coord     y,
                                        FL_Coord     w,
                                        FL_Coord     h,
                                        const char * label );

extern  FL_OBJECT * fl_addto_tabfolder( FL_OBJECT  * ob,
                                          const char * title,
                                          FL_FORM    * form );

extern  FL_FORM * fl_get_tabfolder_folder_bynumber( FL_OBJECT * ob,
                                                      int         num );

extern  FL_FORM * fl_get_tabfolder_folder_byname( FL_OBJECT  * ob,
                                                    const char * name );

extern  FL_FORM * fl_get_tabfolder_folder_byname_f( FL_OBJECT  * ob,
													  const char * fmt,
													  ...);

extern  void fl_delete_folder( FL_OBJECT * ob,
                                 FL_FORM   * form );

extern  void fl_delete_folder_bynumber( FL_OBJECT * ob,
                                          int         num );

extern  void fl_delete_folder_byname( FL_OBJECT  * ob,
                                        const char * name );

extern  void fl_delete_folder_byname_f( FL_OBJECT  * ob,
										  const char * fmt,
										  ... );

extern  void fl_set_folder( FL_OBJECT * ob,
                              FL_FORM   * form );

extern  void fl_set_folder_byname( FL_OBJECT  * ob,
                                     const char * name );

extern  void fl_set_folder_byname_f( FL_OBJECT  * ob,
									   const char * fmt,
									   ... );

extern  void fl_set_folder_bynumber( FL_OBJECT * ob,
                                       int         num );

extern  FL_FORM * fl_get_folder( FL_OBJECT * ob );

extern  int fl_get_folder_number( FL_OBJECT * ob );

extern  const char * fl_get_folder_name( FL_OBJECT * ob );

extern  int fl_get_tabfolder_numfolders( FL_OBJECT * ob );

extern  FL_FORM * fl_get_active_folder( FL_OBJECT * ob );

extern  int fl_get_active_folder_number( FL_OBJECT * ob );

extern  const char * fl_get_active_folder_name( FL_OBJECT * ob );


extern  void fl_get_folder_area( FL_OBJECT * ob,
                                   FL_Coord  * x,
                                   FL_Coord  * y,
                                   FL_Coord  * w,
                                   FL_Coord  * h );

extern  void fl_replace_folder_bynumber( FL_OBJECT * ob,
                                           int         num,
                                           FL_FORM   * form );

extern  int fl_set_tabfolder_autofit( FL_OBJECT * ob,
                                        int         y );

extern  int fl_set_default_tabfolder_corner( int n );

extern  int fl_set_tabfolder_offset( FL_OBJECT * obj,
                                       int         offset );

extern  int fl_get_tabfolder_offset( FL_OBJECT * obj );

/* ! defined FL_FOLDER_H */

/**
 * \file text.h
 */


#define FL_TEXT_H

enum {
    FL_NORMAL_TEXT
};

#define FL_TEXT_BOXTYPE    FL_FLAT_BOX
#define FL_TEXT_COL1       FL_COL1
#define FL_TEXT_COL2       FL_MCOL
#define FL_TEXT_LCOL       FL_LCOL
#define FL_TEXT_ALIGN      ( FL_ALIGN_LEFT | FL_ALIGN_INSIDE )

extern  FL_OBJECT * fl_create_text( int          type,
                                      FL_Coord     x,
                                      FL_Coord     y,
                                      FL_Coord     w,
                                      FL_Coord     h,
                                      const char * label );

extern  FL_OBJECT * fl_add_text( int          type,
                                   FL_Coord     x,
                                   FL_Coord     y,
                                   FL_Coord     w,
                                   FL_Coord     h,
                                   const char * label );

/* ! defined FL_TEXT_H */

/**
 * \file thumbwheel.h
 */


#define FL_THUMBWHEEL_H


enum {
    FL_VERT_THUMBWHEEL,
    FL_HOR_THUMBWHEEL
};

/* defaults */

#define FL_THUMBWHEEL_COL1      FL_COL1
#define FL_THUMBWHEEL_COL2      FL_COL1
#define FL_THUMBWHEEL_LCOL      FL_BLACK
#define FL_THUMBWHEEL_BOXTYPE   FL_BORDER_BOX
#define FL_THUMBWHEEL_ALIGN     FL_ALIGN_BOTTOM

extern  double fl_get_thumbwheel_value( FL_OBJECT * ob );

extern  double fl_set_thumbwheel_value( FL_OBJECT * ob,
                                          double      value );

extern  double fl_get_thumbwheel_step( FL_OBJECT * ob );

extern  double fl_set_thumbwheel_step( FL_OBJECT * ob,
                                         double      step );

extern  int fl_set_thumbwheel_return( FL_OBJECT    * ob,
                                        unsigned int   when );

extern  int fl_set_thumbwheel_crossover( FL_OBJECT * ob,
                                           int         flag );

extern  void fl_set_thumbwheel_bounds( FL_OBJECT * ob,
                                         double      min,
                                         double      max );

extern  void fl_get_thumbwheel_bounds( FL_OBJECT * ob,
                                         double    * min,
                                         double    * max );

extern  FL_OBJECT * fl_create_thumbwheel( int          type,
                                            FL_Coord     x,
                                            FL_Coord     y,
                                            FL_Coord     w,
                                            FL_Coord     h,
                                            const char * label );

extern  FL_OBJECT * fl_add_thumbwheel( int          type,
                                         FL_Coord     x,
                                         FL_Coord     y,
                                         FL_Coord     w,
                                         FL_Coord     h,
                                         const char * label );

/* ! defined FL_THUMBWHEEL_H */

/**
 * \file timer.h
 *
 *  Object Class: Timer
 */


#define FL_TIMER_H


typedef enum {
    FL_NORMAL_TIMER,
    FL_VALUE_TIMER,
    FL_HIDDEN_TIMER
} FL_TIMER_TYPE;

/***** Defaults *****/

#define FL_TIMER_BOXTYPE    FL_DOWN_BOX
#define FL_TIMER_COL1       FL_COL1
#define FL_TIMER_COL2       FL_RED
#define FL_TIMER_LCOL       FL_LCOL
#define FL_TIMER_ALIGN      FL_ALIGN_CENTER

/***** Others   *****/

#define FL_TIMER_BLINKRATE  0.2

/***** Routines *****/

typedef char * ( * FL_TIMER_FILTER )( FL_OBJECT *, double );

extern  FL_OBJECT * fl_create_timer( int          type,
                                       FL_Coord     x,
                                       FL_Coord     y,
                                       FL_Coord     w,
                                       FL_Coord     h,
                                       const char * label );

extern  FL_OBJECT * fl_add_timer( int          type,
                                    FL_Coord     x,
                                    FL_Coord     y,
                                    FL_Coord     w,
                                    FL_Coord     h,
                                    const char * label );

extern  void fl_set_timer( FL_OBJECT * ob,
                             double      total );

extern  double fl_get_timer( FL_OBJECT * ob );

extern  void fl_set_timer_countup( FL_OBJECT * ob,
                                     int         yes );

extern  FL_TIMER_FILTER fl_set_timer_filter( FL_OBJECT       * ob,
                                               FL_TIMER_FILTER   filter );

extern  void fl_suspend_timer( FL_OBJECT * ob );

extern  void fl_resume_timer( FL_OBJECT * ob );

/* ! defined FL_TIMER_H */

/**
 * \file xpopup.h
 *
 *  Prototypes for xpop-up menus
 */


#define FL_XPOPUP_H


#define FL_MAXPUPI     128  /* max item each pup        */
#define FL_PUP_PADH    4    /* space between each items */

typedef void ( * FL_PUP_ENTERCB )( int, void * );   /* call back prototype  */
typedef void ( * FL_PUP_LEAVECB )( int, void * );   /* call back prototype  */

extern  int fl_setpup_entries( int            nm,
                                 FL_PUP_ENTRY * entries );

extern  int fl_newpup( Window win );

extern  int fl_defpup( Window       win,
                         const char * str,
                         ... );

extern  int fl_addtopup( int          n,
                           const char * str,
                           ... );

extern  int fl_setpup_mode( int          nm,
                              int          ni,
                              unsigned int mode );

extern  void fl_freepup( int n );

extern  int fl_dopup( int n );


extern  Cursor fl_setpup_default_cursor( int cursor );

extern  void fl_setpup_default_color( FL_COLOR fg,
										FL_COLOR bg );

extern  void fl_setpup_default_pup_checked_color( FL_COLOR col );

extern  int fl_setpup_default_fontsize( int size );

extern  int fl_setpup_default_fontstyle( int style );

#define fl_setpup_fontsize            fl_setpup_default_fontsize    
#define fl_setpup_fontstyle           fl_setpup_default_fontstyle   
#define fl_setpup_color               fl_setpup_default_color       
#define fl_setpup_default_checkcolor  fl_setpup_default_pup_checked_color
#define fl_setpup_checkcolor          fl_setpup_default_pup_checked_color

extern  int fl_setpup_default_bw( int bw );

extern  void fl_setpup_shortcut( int          nm,
                                   int          ni,
                                   const char * sc );

extern  void fl_setpup_position( int x,
                                   int y );

extern  void fl_setpup_align_bottom( void );

extern  void fl_setpup_selection( int nm,
                                    int ni );

extern  void fl_setpup_shadow( int n,
                                 int y );

extern  void fl_setpup_softedge( int n,
                                   int y );

extern  void fl_setpup_bw( int n,
                             int bw );

extern  void fl_setpup_title( int          nm,
                                const char * title );

extern  void fl_setpup_title_f( int          nm,
								  const char * fmt,
								  ... );

extern  FL_PUP_ENTERCB fl_setpup_entercb( int              nm,
                                            FL_PUP_ENTERCB   cb,
                                            void           * data );

extern  FL_PUP_LEAVECB fl_setpup_leavecb( int              nm,
                                            FL_PUP_LEAVECB   cb,
                                            void           * data );

extern  void fl_setpup_pad( int n,
                              int padw,
                              int padh );

extern  Cursor fl_setpup_cursor( int nm,
                                   int cursor );

extern  int fl_setpup_maxpup( int n );

extern  unsigned int fl_getpup_mode( int nm,
                                       int ni );

extern  const char * fl_getpup_text( int nm,
                                       int ni );

extern  void fl_showpup( int n );

extern  void fl_hidepup( int n );

extern  int fl_getpup_items( int n );

extern  int fl_current_pup( void );

#define fl_setpup_hotkey    fl_setpup_shortcut

extern  FL_PUP_CB fl_setpup_itemcb( int        nm,
                                      int       ni,
                                      FL_PUP_CB cb );

extern  FL_PUP_CB fl_setpup_menucb( int       nm,
                                      FL_PUP_CB cb );

extern  void fl_setpup_submenu( int m,
                                  int i,
                                  int subm );

#define fl_setpup    fl_setpup_mode

/* ! defined FL_XPOPUP_H */

/**
 * \file xyplot.h
 */


#define FL_XYPLOT_H

/*  Class FL_XYPLOT */

typedef enum {
    FL_NORMAL_XYPLOT,       /* solid line                        */
    FL_SQUARE_XYPLOT,       /* with added square                 */
    FL_CIRCLE_XYPLOT,       /* with added circle                 */
    FL_FILL_XYPLOT,         /* fill completely                   */
    FL_POINTS_XYPLOT,       /* only data points                  */
    FL_DASHED_XYPLOT,       /* dashed line                       */
    FL_IMPULSE_XYPLOT,
    FL_ACTIVE_XYPLOT,       /* accepts interactive manipulations */
    FL_EMPTY_XYPLOT,
    FL_DOTTED_XYPLOT,
    FL_DOTDASHED_XYPLOT,
    FL_LONGDASHED_XYPLOT,
    FL_LINEPOINTS_XYPLOT    /* line & points                     */
} FL_XYPLOT_TYPE;

enum {
    FL_LINEAR,
    FL_LOG
};

enum {
    FL_GRID_NONE  = 0,
    FL_GRID_MAJOR = 1,
    FL_GRID_MINOR = 2
};

/***** Defaults *****/

#define FL_XYPLOT_BOXTYPE       FL_FLAT_BOX
#define FL_XYPLOT_COL1          FL_COL1
#define FL_XYPLOT_LCOL          FL_LCOL
#define FL_XYPLOT_ALIGN         FL_ALIGN_BOTTOM
#define FL_MAX_XYPLOTOVERLAY    32

/***** Others   *****/

extern  FL_OBJECT * fl_create_xyplot( int          t,
                                        FL_Coord     x,
                                        FL_Coord     y,
                                        FL_Coord     w,
                                        FL_Coord     h,
                                        const char * label );

extern  FL_OBJECT * fl_add_xyplot( int          t,
                                     FL_Coord     x,
                                     FL_Coord     y,
                                     FL_Coord     w,
                                     FL_Coord     h,
                                     const char * label );

extern  void fl_set_xyplot_data( FL_OBJECT  * ob,
                                   float      * x,
                                   float      * y,
                                   int          n,
                                   const char * title,
                                   const char * xlabel,
                                   const char * ylabel );

extern  void fl_set_xyplot_data_double( FL_OBJECT  * ob,
                                          double     * x,
                                          double     * y,
                                          int          n,
                                          const char * title,
                                          const char * xlabel,
                                          const char * ylabel );

extern  int fl_set_xyplot_file( FL_OBJECT  * ob,
                                  const char * f,
                                  const char * title,
                                  const char * xl,
                                  const char * yl );

extern  void fl_insert_xyplot_data( FL_OBJECT * ob,
                                      int         id,
                                      int         n,
                                      double      x,
                                      double      y );

#define fl_set_xyplot_datafile   fl_set_xyplot_file

extern  void fl_add_xyplot_text( FL_OBJECT  * ob,
                                   double       x,
                                   double       y,
                                   const char * text,
                                   int          al,
                                   FL_COLOR     col );

extern  void fl_delete_xyplot_text( FL_OBJECT  * ob,
                                      const char * text );

extern  int fl_set_xyplot_maxoverlays( FL_OBJECT * ob,
                                         int         maxover );

extern  void fl_add_xyplot_overlay( FL_OBJECT * ob,
                                      int         id,
                                      float     * x,
                                      float     * y,
                                      int         n,
                                      FL_COLOR    col );

extern  int fl_add_xyplot_overlay_file( FL_OBJECT  * ob,
                                          int          id,
                                          const char * f,
                                          FL_COLOR     c );

extern  void fl_set_xyplot_return( FL_OBJECT    * ob,
                                     unsigned int   when );

extern  void fl_set_xyplot_xtics( FL_OBJECT * ob,
                                    int         major,
                                    int         minor );

extern  void fl_set_xyplot_ytics( FL_OBJECT * ob,
                                    int         major,
                                    int         minor );

extern  void fl_set_xyplot_xbounds( FL_OBJECT * ob,
                                      double      xmin,
                                      double      xmax );

extern  void fl_set_xyplot_ybounds( FL_OBJECT * ob,
                                      double      ymin,
                                      double      ymax );

extern  void fl_get_xyplot_xbounds( FL_OBJECT * ob,
                                      float     * xmin,
                                      float     * xmax );

extern  void fl_get_xyplot_ybounds( FL_OBJECT * ob,
                                      float     * ymin,
                                      float     * ymax );

extern  void fl_get_xyplot( FL_OBJECT * ob,
                              float     * x,
                              float     * y,
                              int       * i );

extern  int fl_get_xyplot_data_size( FL_OBJECT * obj );

extern  void fl_get_xyplot_data( FL_OBJECT * ob,
                                   float     * x,
                                   float     * y,
                                   int       * n );

extern  void fl_get_xyplot_data_pointer( FL_OBJECT  * ob,
                                           int          id,
                                           float     ** x,
                                           float     ** y,
                                           int        *n );

extern  void fl_get_xyplot_overlay_data( FL_OBJECT * ob,
                                           int         id,
                                           float     * x,
                                           float     * y,
                                           int       * n );

extern  void fl_set_xyplot_overlay_type( FL_OBJECT * ob,
                                           int         id,
                                           int         type );

extern  void fl_delete_xyplot_overlay( FL_OBJECT * ob,
                                         int         id );

extern  void fl_set_xyplot_interpolate( FL_OBJECT * ob,
                                          int         id,
                                          int         deg,
                                          double      grid );

extern  void fl_set_xyplot_inspect( FL_OBJECT * ob,
                                      int         yes );

extern  void fl_set_xyplot_symbolsize( FL_OBJECT * ob,
                                         int         n );

extern  void fl_replace_xyplot_point( FL_OBJECT * ob,
                                        int         i,
                                        double      x,
                                        double      y );

/* Replace the value of a particular point in dataset setID,
 * where setID=0 is the first data set.
 * This routine is an extension of fl_replace_xyplot_point
 * which acts on the first dataset only. */

extern  void fl_replace_xyplot_point_in_overlay( FL_OBJECT * ob,
                                                   int         i,
                                                   int         setID,
                                                   double      x,
                                                   double      y );

extern  void fl_get_xyplot_xmapping( FL_OBJECT * ob,
                                       float     * a,
                                       float     * b );

extern  void fl_get_xyplot_ymapping( FL_OBJECT * ob,
                                       float     * a,
                                       float     * b );

extern  void fl_set_xyplot_keys( FL_OBJECT  * ob,
                                   char      ** keys,
                                   float         x,
                                   float         y,
                                   int           align );

extern  void fl_set_xyplot_key( FL_OBJECT  * ob,
                                  int          id,
                                  const char * key );

extern  void fl_set_xyplot_key_position( FL_OBJECT * ob,
                                           float       x,
                                           float       y,
                                           int         align );

extern  void fl_set_xyplot_key_font( FL_OBJECT * ob,
                                       int         style,
                                       int         size );

extern  int fl_get_xyplot_numdata( FL_OBJECT * ob,
                                     int         id );

/* The following two functions will be removed.
 * Use fl_set_object_l[size|style] for the functionalities */

extern  void fl_set_xyplot_fontsize( FL_OBJECT * ob,
                                       int         size );

extern  void fl_set_xyplot_fontstyle( FL_OBJECT * ob,
                                        int         style );

extern  void fl_xyplot_s2w( FL_OBJECT * ob,
                              double      sx,
                              double      sy,
                              float     * wx,
                              float     * wy );

extern  void fl_xyplot_w2s( FL_OBJECT * ob,
                              double      wx,
                              double      wy,
                              float     * sx,
                              float     * sy );

extern  void fl_set_xyplot_xscale( FL_OBJECT * ob,
                                     int         scale,
                                     double      base );

extern  void fl_set_xyplot_yscale( FL_OBJECT * ob,
                                     int         scale,
                                     double      base );

extern  void fl_clear_xyplot( FL_OBJECT * ob );

extern  void fl_set_xyplot_linewidth( FL_OBJECT * ob,
                                        int         id,
                                        int         lw );

extern  void fl_set_xyplot_xgrid( FL_OBJECT * ob,
                                    int         xgrid );

extern  void fl_set_xyplot_ygrid( FL_OBJECT * ob,
                                    int         ygrid );

extern  int fl_set_xyplot_grid_linestyle( FL_OBJECT * ob,
                                            int         style );

extern  void fl_set_xyplot_alphaxtics( FL_OBJECT  * ob,
                                         const char * m,
                                         const char * s );

extern  void fl_set_xyplot_alphaytics( FL_OBJECT  * ob,
                                         const char * m,
                                         const char * s );

extern  void fl_set_xyplot_fixed_xaxis( FL_OBJECT  * ob,
                                          const char * lm,
                                          const char * rm );

extern  void fl_set_xyplot_fixed_yaxis( FL_OBJECT  * ob,
                                          const char * bm,
                                          const char * tm );

extern  int fl_interpolate( const float * wx,
                              const float * wy,
                              int           nin,
                              float       * x,
                              float       * y,
                              double        grid,
                              int           ndeg );

typedef void ( * FL_XYPLOT_SYMBOL )( FL_OBJECT *,
                                     int,
                                     FL_POINT *,
                                     int,
                                     int,
                                     int );

extern  FL_XYPLOT_SYMBOL fl_set_xyplot_symbol( FL_OBJECT        * ob,
                                                 int                id,
                                                 FL_XYPLOT_SYMBOL   symbol );

extern  int fl_set_xyplot_mark_active( FL_OBJECT * ob,
                                         int         y );

extern  void fl_get_xyplot_screen_area( FL_OBJECT * obj,
										  FL_Coord   * llx,
										  FL_Coord   * lly,
										  FL_Coord   * urx,
										  FL_Coord   * ury );

extern  void fl_get_xyplot_world_area( FL_OBJECT * obj,
										 float     * llx,
										 float     * lly,
										 float     * urx,
										 float     * ury );

extern  int fl_set_xyplot_log_minor_xtics( FL_OBJECT * obj,
											 int         yesno );

extern  int fl_set_xyplot_log_minor_ytics( FL_OBJECT * obj,
											 int         yesno );


/* ! defined FL_XYPLOT_H */

/* the following (fl_fheight) etc. were never documented and were
   removed from V0.89, but apparently this broke some applications that
   were using them. Put them back in 10/22/00 */

#define fl_textgc      fl_textgc_( )
#define fl_gc          fl_gc_( )
#define fl_cur_win     fl_cur_win_( )
#define fl_fheight     fl_fheight_( )
#define fl_fdesc       fl_fdesc_( )
#define fl_cur_fs      fl_cur_fs_( )

extern  GC fl_gc_( void );
extern  GC fl_textgc_( void );
extern  int fl_fheight_( void );
extern  int fl_fdesc_( void );
extern  Window fl_cur_win_( void );
extern  XFontStruct * fl_cur_fs_( void );
extern  Display * fl_display_( void );


#define FL_FALSE        0
#define FL_TRUE         ( ! FL_FALSE )






/* FL_FORMS_H */
# 34 "forms.c" 2

#include "flinternal.h"
# 1 "flinternal.h" 1
/*
 *  This file is part of the XForms library package.
 *
 *  XForms is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation; either version 2.1, or
 *  (at your option) any later version.
 *
 *  XForms is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with XForms. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 *  \file flinternal.h
 *
 *  This file is part of the XForms library package.
 *  Copyright (c) 1996-1998  T.C. Zhao and Mark Overmars
 *  All rights reserved.
 *
 * Internal routines used by the Forms Library. An application should
 * not use any of this since there is no guarantee that exactly some
 * thing will exist in future versions of XForms.
 */


#define FLINTERNAL_H

#include <stdlib.h>
# 1 "/usr/include/stdlib.h" 1 3
/* Copyright (C) 1991-2007, 2009, 2010, 2011 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.20 General utilities	<stdlib.h>
 */



#include <features.h>

/* Get size_t, wchar_t and NULL from <stddef.h>.  */
#define		__need_size_t

#define	__need_wchar_t
#define	__need_NULL

#include <stddef.h>
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004, 2009
   Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3



/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
/* defined(_ANSI_H_) || defined(_MACHINE_ANSI_H_) || defined(_X86_64_ANSI_H_) || defined(_I386_ANSI_H_) */
# 93 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */













/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* in case <sys/types.h> has defined it. *//* _PTRDIFF_T */
# 158 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* If this symbol has done its job, get rid of it.  */
#undef	__need_ptrdiff_t

/* _STDDEF_H or __need_ptrdiff_t.  */

/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* BeOS *//* __size_t__ */
# 233 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3

#undef	__need_size_t
/* _STDDEF_H or __need_size_t.  */


/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* BeOS *//* __wchar_t__ */
# 342 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3

#undef	__need_wchar_t
/* _STDDEF_H or __need_wchar_t.  */

# 356 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
/* _ANSI_H_ || _MACHINE_ANSI_H_ || _X86_64_ANSI_H_ || _I386_ANSI_H_ */
# 390 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* __sys_stdtypes_h */

/* A null pointer constant.  */


#undef NULL		/* in case <stdio.h> has defined it. */
/* G++ */



#define NULL ((void *)0)
/* C++ *//* C++ */


/* G++ */
/* NULL not defined and <stddef.h> or need NULL.  */
#undef	__need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)

/* _STDDEF_H was defined this time */

/* !_STDDEF_H && !_STDDEF_H_ && !_ANSI_STDDEF_H && !__STDDEF_H__
	  || __need_XXX was not defined before */
# 33 "/usr/include/stdlib.h" 2 3


 


#define	_STDLIB_H	1


/* XPG requires a few symbols from <sys/wait.h> being defined.  */
#include <bits/waitflags.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3
/* Definitions of flag bits for `waitpid' et al.
   Copyright (C) 1992,1996,1997,2000,2004,2005 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */






/* Bits in the third argument to `waitpid'.  */
#define	WNOHANG		1	/* Don't block waiting.  */
#define	WUNTRACED	2	/* Report status of stopped children.  */

/* Bits in the fourth argument to `waitid'.  */
#define WSTOPPED	2	/* Report stopped child (same as WUNTRACED). */
#define WEXITED		4	/* Report dead child.  */
#define WCONTINUED	8	/* Report continued child.  */
#define WNOWAIT		0x01000000 /* Don't reap, just poll status.  */

#define __WNOTHREAD     0x20000000 /* Don't wait on children of other threads
				      in this group */
#define __WALL		0x40000000 /* Wait for any child.  */
#define __WCLONE	0x80000000 /* Wait for cloned process.  */
# 42 "/usr/include/stdlib.h" 2 3

#include <bits/waitstatus.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3
/* Definitions of status bits for `wait' et al.
   Copyright (C) 1992,1994,1996,1997,2000,2004 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */






/* Everything extant so far uses these same bits.  */


/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */
#define	__WEXITSTATUS(status)	(((status) & 0xff00) >> 8)

/* If WIFSIGNALED(STATUS), the terminating signal.  */
#define	__WTERMSIG(status)	((status) & 0x7f)

/* If WIFSTOPPED(STATUS), the signal that stopped the child.  */
#define	__WSTOPSIG(status)	__WEXITSTATUS(status)

/* Nonzero if STATUS indicates normal termination.  */
#define	__WIFEXITED(status)	(__WTERMSIG(status) == 0)

/* Nonzero if STATUS indicates termination by a signal.  */
#define __WIFSIGNALED(status) \
  (((signed char) (((status) & 0x7f) + 1) >> 1) > 0)

/* Nonzero if STATUS indicates the child is stopped.  */
#define	__WIFSTOPPED(status)	(((status) & 0xff) == 0x7f)

/* Nonzero if STATUS indicates the child continued after a stop.  We only
   define this if <bits/waitflags.h> provides the WCONTINUED flag bit.  */

#define __WIFCONTINUED(status)	((status) == __W_CONTINUED)


/* Nonzero if STATUS indicates the child dumped core.  */
#define	__WCOREDUMP(status)	((status) & __WCOREFLAG)

/* Macros for constructing status values.  */
#define	__W_EXITCODE(ret, sig)	((ret) << 8 | (sig))
#define	__W_STOPCODE(sig)	((sig) << 8 | 0x7f)
#define __W_CONTINUED		0xffff
#define	__WCOREFLAG		0x80




#include <endian.h>

union wait
  {
    int w_status;
    struct
      {

	unsigned int __w_termsig:7; /* Terminating signal.  */
	unsigned int __w_coredump:1; /* Set if dumped core.  */
	unsigned int __w_retcode:8; /* Return code if exited normally.  */
	unsigned int:16;
/* Little endian.  */
/* Big endian.  */





      } __wait_terminated;
    struct
      {

	unsigned int __w_stopval:8; /* W_STOPPED if stopped.  */
	unsigned int __w_stopsig:8; /* Stopping signal.  */
	unsigned int:16;
/* Little endian.  */
/* Big endian.  */




      } __wait_stopped;
  };

#define w_termsig	__wait_terminated.__w_termsig
#define w_coredump	__wait_terminated.__w_coredump
#define w_retcode	__wait_terminated.__w_retcode
#define w_stopsig	__wait_stopped.__w_stopsig
#define w_stopval	__wait_stopped.__w_stopval

/* Use BSD.  */
# 43 "/usr/include/stdlib.h" 2 3




/* Lots of hair to allow traditional BSD use of `union wait'
   as well as POSIX.1 use of `int' for the status word.  */


#define __WAIT_INT(status) \
  (__extension__ (((union { __typeof(status) __in; int __i; }) \
		   { .__in = (status) }).__i))




/* This is the type of the argument to `wait'.  The funky union
   causes redeclarations with either `int *' or `union wait *' to be
   allowed without complaint.  __WAIT_STATUS_DEFN is the type used in
   the actual function definitions.  */





/* This works in GCC 2.6.1 and later.  */
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
#define __WAIT_STATUS_DEFN	int *


/* Don't use BSD.  *//* Use BSD.  */







/* Define the macros <sys/wait.h> also would define this way.  */
#define WEXITSTATUS(status)	__WEXITSTATUS (__WAIT_INT (status))
#define WTERMSIG(status)	__WTERMSIG (__WAIT_INT (status))
#define WSTOPSIG(status)	__WSTOPSIG (__WAIT_INT (status))
#define WIFEXITED(status)	__WIFEXITED (__WAIT_INT (status))
#define WIFSIGNALED(status)	__WIFSIGNALED (__WAIT_INT (status))
#define WIFSTOPPED(status)	__WIFSTOPPED (__WAIT_INT (status))

#define WIFCONTINUED(status)	__WIFCONTINUED (__WAIT_INT (status))

/* X/Open or XPG7 and <sys/wait.h> not included.  */

 
/* Returned by `div'.  */
typedef struct
  {
    int quot;			/* Quotient.  */
    int rem;			/* Remainder.  */
  } div_t;

/* Returned by `ldiv'.  */

typedef struct
  {
    long int quot;		/* Quotient.  */
    long int rem;		/* Remainder.  */
  } ldiv_t;
#define __ldiv_t_defined	1

 


 
/* Returned by `lldiv'.  */
__extension__ typedef struct
  {
    long long int quot;		/* Quotient.  */
    long long int rem;		/* Remainder.  */
  } lldiv_t;
#define __lldiv_t_defined	1
 



/* The largest number rand will return (same as INT_MAX).  */
#define	RAND_MAX	2147483647


/* We define these the same for all machines.
   Changes from this to the outside world should be done in `_exit'.  */
#define	EXIT_FAILURE	1	/* Failing exit status.  */
#define	EXIT_SUCCESS	0	/* Successful exit status.  */


/* Maximum length of a multibyte character in the current locale.  */
#define	MB_CUR_MAX	(__ctype_get_mb_cur_max ())
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__ ))   ;


 
/* Convert a string to a floating-point number.  */
extern double atof (__const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1) ))   ;
/* Convert a string to an integer.  */
extern int atoi (__const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1) ))   ;
/* Convert a string to a long integer.  */
extern long int atol (__const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1) ))   ;
 


 
/* Convert a string to a long long integer.  */
__extension__ extern long long int atoll (__const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1) ))   ;
 


 
/* Convert a string to a floating-point number.  */
extern double strtod (__const char *__restrict __nptr,
		      char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;
 


 
/* Likewise for `float' and `long double' sizes of floating-point numbers.  */
extern float strtof (__const char *__restrict __nptr,
		     char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;

extern long double strtold (__const char *__restrict __nptr,
			    char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;
 


 
/* Convert a string to a long integer.  */
extern long int strtol (__const char *__restrict __nptr,
			char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;
/* Convert a string to an unsigned long integer.  */
extern unsigned long int strtoul (__const char *__restrict __nptr,
				  char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;
 


/* Convert a string to a quadword integer.  */
__extension__
extern long long int strtoq (__const char *__restrict __nptr,
			     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;
/* Convert a string to an unsigned quadword integer.  */
__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
				       char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;
/* GCC and use BSD.  */


 
/* Convert a string to a quadword integer.  */
__extension__
extern long long int strtoll (__const char *__restrict __nptr,
			      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;
/* Convert a string to an unsigned quadword integer.  */
__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
					char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;
 
/* ISO C99 or GCC and use MISC.  */


/* GNU */
# 273 "/usr/include/stdlib.h" 3



/* Optimizing and Inlining.  */
# 304 "/usr/include/stdlib.h" 3




/* Convert N to base 64 using the digits "./0-9A-Za-z", least-significant
   digit first.  Returns a pointer to static storage overwritten by the
   next call.  */
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__ ))   ;

/* Read a number from a string S in base 64 as above.  */
extern long int a64l (__const char *__s)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__pure__))  __attribute__ ((__nonnull__  (1) ))   ;

/* Use SVID || extended X/Open.  */


#include <sys/types.h>	/* we need int32_t... */

/* These are the functions that actually do things.  The `random', `srandom',
   `initstate' and `setstate' functions are those from BSD Unices.
   The `rand' and `srand' functions are required by the ANSI standard.
   We provide both interfaces to the same random number generator.  */
/* Return a random long integer between 0 and RAND_MAX inclusive.  */
extern long int random (void) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Seed the random number generator with the given number.  */
extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Initialize the random number generator to use state buffer STATEBUF,
   of length STATELEN, and seed it with SEED.  Optimal lengths are 8, 16,
   32, 64, 128 and 256, the bigger the better; values less than 8 will
   cause an error and values greater than 256 will be rounded down.  */
extern char *initstate (unsigned int __seed, char *__statebuf,
			size_t __statelen) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (2) )) ;

/* Switch the random number generator to state buffer STATEBUF,
   which should have been previously initialized by `initstate'.  */
extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;



/* Reentrant versions of the `random' family of functions.
   These functions all use the following data structure to contain
   state, rather than global state variables.  */

struct random_data
  {
    int32_t *fptr;		/* Front pointer.  */
    int32_t *rptr;		/* Rear pointer.  */
    int32_t *state;		/* Array of state values.  */
    int rand_type;		/* Type of random number generator.  */
    int rand_deg;		/* Degree of random number generator.  */
    int rand_sep;		/* Distance between front and rear.  */
    int32_t *end_ptr;		/* Pointer behind state table.  */
  };

extern int random_r (struct random_data *__restrict __buf,
		     int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (2) )) ;

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
			size_t __statelen,
			struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (2, 4) )) ;

extern int setstate_r (char *__restrict __statebuf,
		       struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;
/* Use misc.  */
/* Use SVID || extended X/Open || BSD. */


 
/* Return a random integer between 0 and RAND_MAX inclusive.  */
extern int rand (void) __attribute__ ((__nothrow__ , __leaf__ )) ;
/* Seed the random number generator with the given number.  */
extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__ )) ;
 


/* Reentrant interface according to POSIX.1.  */
extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__ )) ;




/* System V style 48-bit random number generator functions.  */

/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__ )) ;
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;

/* Return non-negative, long integer in [0,2^31).  */
extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__ )) ;
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;

/* Return signed, long integers in [-2^31,2^31).  */
extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__ )) ;
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;

/* Seed random number generator.  */
extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__ )) ;
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;


/* Data structure for communication with thread safe versions.  This
   type is to be regarded as opaque.  It's only exported because users
   have to allocate objects of this type.  */
struct drand48_data
  {
    unsigned short int __x[3];	/* Current state.  */
    unsigned short int __old_x[3]; /* Old state.  */
    unsigned short int __c;	/* Additive const. in congruential formula.  */
    unsigned short int __init;	/* Flag for initializing.  */
    unsigned long long int __a;	/* Factor in congruential formula.  */
  };

/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
extern int drand48_r (struct drand48_data *__restrict __buffer,
		      double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;
extern int erand48_r (unsigned short int __xsubi[3],
		      struct drand48_data *__restrict __buffer,
		      double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;

/* Return non-negative, long integer in [0,2^31).  */
extern int lrand48_r (struct drand48_data *__restrict __buffer,
		      long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;
extern int nrand48_r (unsigned short int __xsubi[3],
		      struct drand48_data *__restrict __buffer,
		      long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;

/* Return signed, long integers in [-2^31,2^31).  */
extern int mrand48_r (struct drand48_data *__restrict __buffer,
		      long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;
extern int jrand48_r (unsigned short int __xsubi[3],
		      struct drand48_data *__restrict __buffer,
		      long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;

/* Seed random number generator.  */
extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (2) )) ;

extern int seed48_r (unsigned short int __seed16v[3],
		     struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;

extern int lcong48_r (unsigned short int __param[7],
		      struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;
/* Use misc.  */
/* Use SVID or X/Open.  */

/* don't just need malloc and calloc */


#define __malloc_and_calloc_defined
 
/* Allocate SIZE bytes of memory.  */
extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__malloc__))   ;
/* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */
extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__malloc__))   ;
 



 
/* Re-allocate the previously allocated block
   in PTR, making the new block SIZE bytes long.  */
/* __attribute_malloc__ is not used, because if realloc returns
   the same pointer that was passed to it, aliasing needs to be allowed
   between objects pointed by the old and new pointers.  */
extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__warn_unused_result__)) ;
/* Free a block allocated by `malloc', `realloc' or `calloc'.  */
extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__ )) ;
 


/* Free a block.  An alias for `free'.	(Sun Unices).  */
extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__ )) ;
/* Use misc.  */


#include <alloca.h>
# 1 "/usr/include/alloca.h" 1 3
/* Copyright (C) 1992, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */


#define	_ALLOCA_H	1

#include <features.h>

#define	__need_size_t
#include <stddef.h>
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004, 2009
   Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3



/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
/* defined(_ANSI_H_) || defined(_MACHINE_ANSI_H_) || defined(_X86_64_ANSI_H_) || defined(_I386_ANSI_H_) */
# 93 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */













/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* in case <sys/types.h> has defined it. *//* _PTRDIFF_T */
# 158 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* If this symbol has done its job, get rid of it.  */
#undef	__need_ptrdiff_t

/* _STDDEF_H or __need_ptrdiff_t.  */

/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* BeOS *//* __size_t__ */
# 233 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3

#undef	__need_size_t
/* _STDDEF_H or __need_size_t.  */


/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* BeOS *//* __wchar_t__ */
# 342 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3

#undef	__need_wchar_t
/* _STDDEF_H or __need_wchar_t.  */

# 356 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
/* _ANSI_H_ || _MACHINE_ANSI_H_ || _X86_64_ANSI_H_ || _I386_ANSI_H_ */
# 390 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* __sys_stdtypes_h */

/* A null pointer constant.  */


#undef NULL		/* in case <stdio.h> has defined it. */
/* G++ */



#define NULL ((void *)0)
/* C++ *//* C++ */


/* G++ */
/* NULL not defined and <stddef.h> or need NULL.  */
#undef	__need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)

/* _STDDEF_H was defined this time */

/* !_STDDEF_H && !_STDDEF_H_ && !_ANSI_STDDEF_H && !__STDDEF_H__
	  || __need_XXX was not defined before */
# 25 "/usr/include/alloca.h" 2 3


 

/* Remove any previous definitions.  */
#undef	alloca

/* Allocate a block that will be freed when the calling function exits.  */
extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__ )) ;


#define alloca(size)	__builtin_alloca (size)
/* GCC.  */

 

/* alloca.h */
# 497 "/usr/include/stdlib.h" 2 3

/* Use GNU, BSD, or misc.  */



/* Allocate SIZE bytes on a page boundary.  The storage cannot be freed.  */
extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__malloc__))   ;



/* Allocate memory of SIZE bytes with an alignment of ALIGNMENT.  */
extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;


 
/* Abort execution and generate a core-dump.  */
extern void abort (void) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__noreturn__));


/* Register a function to be called when `exit' is called.  */
extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;

# 530 "/usr/include/stdlib.h" 3

 


/* Register a function to be called with the status
   given to `exit' and the given argument.  */
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;


 
/* Call all functions registered with `atexit' and `on_exit',
   in the reverse of the order in which they were registered,
   perform stdio cleanup, and terminate program execution with STATUS.  */
extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__noreturn__));









 


 
/* Terminate the program with STATUS without calling any of the
   functions registered with `atexit' or `on_exit'.  */
extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__noreturn__));
 



 
/* Return the value of envariable NAME, or NULL if it doesn't exist.  */
extern char *getenv (__const char *__name) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;
 

/* This function is similar to the above but returns NULL if the
   programs is running with SUID or SGID enabled.  */
extern char *__secure_getenv (__const char *__name)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;


/* The SVID says this is in <stdio.h>, but this seems a better place.	*/
/* Put STRING, which is of the form "NAME=VALUE", in the environment.
   If there is no `=', remove NAME from the environment.  */
extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;



/* Set NAME to VALUE in the environment.
   If REPLACE is nonzero, overwrite an existing value.  */
extern int setenv (__const char *__name, __const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (2) )) ;

/* Remove the variable NAME from the environment.  */
extern int unsetenv (__const char *__name) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;



/* The `clearenv' was planned to be added to POSIX.1 but probably
   never made it.  Nevertheless the POSIX.9 standard (POSIX bindings
   for Fortran 77) requires this function.  */
extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__ )) ;





/* Generate a unique temporary file name from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the file name unique.
   Returns TEMPLATE, or a null pointer if it cannot get a unique file name.  */
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;




/* Generate a unique temporary file name from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the filename unique.
   Returns a file descriptor open on the file for reading and writing,
   or -1 if it cannot create a uniquely-named file.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int mkstemp (char *__template) __attribute__ ((__nonnull__  (1) ))   ;














/* Similar to mkstemp, but the template can have a suffix after the
   XXXXXX.  The length of the suffix is specified in the second
   parameter.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */

extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__  (1) ))   ;















/* Create a unique temporary directory from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the directory name unique.
   Returns TEMPLATE, or a null pointer if it cannot get a unique name.
   The directory is created mode 700.  */
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;


# 709 "/usr/include/stdlib.h" 3



 
/* Execute the given line as a shell command.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int system (__const char *__command)  ;
 










/* Return the canonical absolute name of file NAME.  If RESOLVED is
   null, the result is malloc'd; otherwise, if the canonical name is
   PATH_MAX chars or more, returns null with `errno' set to
   ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,
   returns the name in RESOLVED.  */
extern char *realpath (__const char *__restrict __name,
		       char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__ ))   ;



/* Shorthand for type of comparison functions.  */

#define __COMPAR_FN_T
typedef int (*__compar_fn_t) (__const void *, __const void *);









 
/* Do a binary search for KEY in BASE, which consists of NMEMB elements
   of SIZE bytes each, using COMPAR to perform the comparisons.  */
extern void *bsearch (__const void *__key, __const void *__base,
		      size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__  (1, 2, 5) ))   ;

/* Sort NMEMB elements of BASE, of SIZE bytes each,
   using COMPAR to perform the comparisons.  */
extern void qsort (void *__base, size_t __nmemb, size_t __size,
		   __compar_fn_t __compar) __attribute__ ((__nonnull__  (1, 4) )) ;







/* Return the absolute value of X.  */
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__const__))  ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__const__))  ;
 


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__const__))  ;



 
/* Return the `div_t', `ldiv_t' or `lldiv_t' representation
   of the value of NUMER over DENOM. */
/* GCC may have built-ins for these someday.  */
extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__const__))  ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__const__))  ;
 


 
__extension__ extern lldiv_t lldiv (long long int __numer,
				    long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__const__))  ;
 





/* Convert floating point numbers to strings.  The returned values are
   valid only until another call to the same function.  */

/* Convert VALUE to a string with NDIGIT digits and return a pointer to
   this.  Set *DECPT with the position of the decimal character and *SIGN
   with the sign of the number.  */
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
		   int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (3, 4) ))   ;

/* Convert VALUE to a string rounded to NDIGIT decimal digits.  Set *DECPT
   with the position of the decimal character and *SIGN with the sign of
   the number.  */
extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
		   int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (3, 4) ))   ;

/* If possible convert VALUE to a string with NDIGIT significant digits.
   Otherwise use exponential representation.  The resulting string will
   be written to BUF.  */
extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (3) ))   ;



/* Long double versions of above functions.  */
extern char *qecvt (long double __value, int __ndigit,
		    int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (3, 4) ))   ;
extern char *qfcvt (long double __value, int __ndigit,
		    int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (3, 4) ))   ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (3) ))   ;


/* Reentrant version of the functions above which provide their own
   buffers.  */
extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
		   int *__restrict __sign, char *__restrict __buf,
		   size_t __len) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (3, 4, 5) )) ;
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
		   int *__restrict __sign, char *__restrict __buf,
		   size_t __len) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (3, 4, 5) )) ;

extern int qecvt_r (long double __value, int __ndigit,
		    int *__restrict __decpt, int *__restrict __sign,
		    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (3, 4, 5) )) ;
extern int qfcvt_r (long double __value, int __ndigit,
		    int *__restrict __decpt, int *__restrict __sign,
		    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (3, 4, 5) )) ;
/* misc */
/* use MISC || use X/Open Unix */


 
/* Return the length of the multibyte character
   in S, which is no longer than N.  */
extern int mblen (__const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__ ))   ;
/* Return the length of the given multibyte character,
   putting its `wchar_t' representation in *PWC.  */
extern int mbtowc (wchar_t *__restrict __pwc,
		   __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__ ))   ;
/* Put the multibyte character represented
   by WCHAR in S, returning its length.  */
extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__ ))   ;


/* Convert a multibyte string to a wide char string.  */
extern size_t mbstowcs (wchar_t *__restrict  __pwcs,
			__const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__ )) ;
/* Convert a wide char string to multibyte string.  */
extern size_t wcstombs (char *__restrict __s,
			__const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__ )) ;
 



/* Determine whether the string value of RESPONSE matches the affirmation
   or negative response expression as specified by the LC_MESSAGES category
   in the program's current locale.  Returns 1 if affirmative, 0 if
   negative, and -1 if not matching.  */
extern int rpmatch (__const char *__response) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;




/* Parse comma separated suboption from *OPTIONP and match against
   strings in TOKENS.  If found return index and set *VALUEP to
   optional value introduced by an equal sign.  If the suboption is
   not part of TOKENS return in *VALUEP beginning of unknown
   suboption.  On exit *OPTIONP is set to the beginning of the next
   token or at the terminating NUL character.  */
extern int getsubopt (char **__restrict __optionp,
		      char *__const *__restrict __tokens,
		      char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2, 3) ))   ;









/* X/Open pseudo terminal handling.  */






# 931 "/usr/include/stdlib.h" 3


# 942 "/usr/include/stdlib.h" 3



/* Put the 1 minute, 5 minute and 15 minute load averages into the first
   NELEM elements of LOADAVG.  Return the number written (never more than
   three, but may be less than NELEM), or -1 if an error occurred.  */
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;



/* Define some macros helping to catch buffer overflows.  */







/* don't just need malloc and calloc */
#undef __need_malloc_and_calloc

 

/* stdlib.h  */
# 33 "flinternal.h" 2

#include <signal.h>
# 1 "/usr/include/signal.h" 1 3
/* Copyright (C) 1991-2004, 2007, 2009, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.14 Signal handling <signal.h>
 */




#define _SIGNAL_H


#include <features.h>

 

#include <bits/sigset.h>		/* __sigset_t, __sig_atomic_t.  */
# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3
/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.
   Copyright (C) 1991, 1992, 1994, 1996, 1997, 2007
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

# 34 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3



/* We only want to define these functions if <signal.h> was actually
   included; otherwise we were included just to define the types.  Since we
   are namespace-clean, it wouldn't hurt to define extra macros.  But
   trouble can be caused by functions being defined (e.g., any global
   register vars declared later will cause compilation errors).  */


#define _SIGSET_H_fns 1


#define _EXTERN_INLINE __extern_inline


/* Return a mask that includes the bit for SIG only.  */
#define __sigmask(sig) \
  (((unsigned long int) 1) << (((sig) - 1) % (8 * sizeof (unsigned long int))))

/* Return the word index for SIG.  */
#define __sigword(sig)	(((sig) - 1) / (8 * sizeof (unsigned long int)))


#define __sigemptyset(set) \
  (__extension__ ({ int __cnt = _SIGSET_NWORDS;				      \
		    sigset_t *__set = (set);				      \
		    while (--__cnt >= 0) __set->__val[__cnt] = 0;	      \
		    0; }))
#define __sigfillset(set) \
  (__extension__ ({ int __cnt = _SIGSET_NWORDS;				      \
		    sigset_t *__set = (set);				      \
		    while (--__cnt >= 0) __set->__val[__cnt] = ~0UL;	      \
		    0; }))

# 98 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3



/* These functions needn't check for a bogus signal number -- error
   checking is done in the non __ versions.  */

extern int __sigismember (__const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);

# 123 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3



/* ! _SIGSET_H_fns.  */
# 33 "/usr/include/signal.h" 2 3


/* An integral type that can be modified atomically, without the
   possibility of a signal arriving in the middle of the operation.  */


#define __sig_atomic_t_defined
 
typedef __sig_atomic_t sig_atomic_t;
 

#undef __need_sig_atomic_t







#undef __need_sigset_t




#include <bits/types.h>
#include <bits/signum.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/signum.h" 1 3
/* Signal number definitions.  Linux version.
   Copyright (C) 1995,1996,1997,1998,1999,2003 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */



/* Fake signal functions.  */
#define SIG_ERR	((__sighandler_t) -1)		/* Error return.  */
#define SIG_DFL	((__sighandler_t) 0)		/* Default action.  */
#define SIG_IGN	((__sighandler_t) 1)		/* Ignore signal.  */






/* Signals.  */
#define	SIGHUP		1	/* Hangup (POSIX).  */
#define	SIGINT		2	/* Interrupt (ANSI).  */
#define	SIGQUIT		3	/* Quit (POSIX).  */
#define	SIGILL		4	/* Illegal instruction (ANSI).  */
#define	SIGTRAP		5	/* Trace trap (POSIX).  */
#define	SIGABRT		6	/* Abort (ANSI).  */
#define	SIGIOT		6	/* IOT trap (4.2 BSD).  */
#define	SIGBUS		7	/* BUS error (4.2 BSD).  */
#define	SIGFPE		8	/* Floating-point exception (ANSI).  */
#define	SIGKILL		9	/* Kill, unblockable (POSIX).  */
#define	SIGUSR1		10	/* User-defined signal 1 (POSIX).  */
#define	SIGSEGV		11	/* Segmentation violation (ANSI).  */
#define	SIGUSR2		12	/* User-defined signal 2 (POSIX).  */
#define	SIGPIPE		13	/* Broken pipe (POSIX).  */
#define	SIGALRM		14	/* Alarm clock (POSIX).  */
#define	SIGTERM		15	/* Termination (ANSI).  */
#define	SIGSTKFLT	16	/* Stack fault.  */
#define	SIGCLD		SIGCHLD	/* Same as SIGCHLD (System V).  */
#define	SIGCHLD		17	/* Child status has changed (POSIX).  */
#define	SIGCONT		18	/* Continue (POSIX).  */
#define	SIGSTOP		19	/* Stop, unblockable (POSIX).  */
#define	SIGTSTP		20	/* Keyboard stop (POSIX).  */
#define	SIGTTIN		21	/* Background read from tty (POSIX).  */
#define	SIGTTOU		22	/* Background write to tty (POSIX).  */
#define	SIGURG		23	/* Urgent condition on socket (4.2 BSD).  */
#define	SIGXCPU		24	/* CPU limit exceeded (4.2 BSD).  */
#define	SIGXFSZ		25	/* File size limit exceeded (4.2 BSD).  */
#define	SIGVTALRM	26	/* Virtual alarm clock (4.2 BSD).  */
#define	SIGPROF		27	/* Profiling alarm clock (4.2 BSD).  */
#define	SIGWINCH	28	/* Window size change (4.3 BSD, Sun).  */
#define	SIGPOLL		SIGIO	/* Pollable event occurred (System V).  */
#define	SIGIO		29	/* I/O now possible (4.2 BSD).  */
#define	SIGPWR		30	/* Power failure restart (System V).  */
#define SIGSYS		31	/* Bad system call.  */
#define SIGUNUSED	31

#define	_NSIG		65	/* Biggest signal number + 1
				   (including real-time signals).  */

#define SIGRTMIN        (__libc_current_sigrtmin ())
#define SIGRTMAX        (__libc_current_sigrtmax ())

/* These are the hard limits of the kernel.  These values should not be
   used directly at user level.  */
#define __SIGRTMIN	32
#define __SIGRTMAX	(_NSIG - 1)

/* <signal.h> included.  */
# 58 "/usr/include/signal.h" 2 3













/* Unix98 */


/* We need `struct timespec' later on.  */
#define __need_timespec
#include <time.h>
# 1 "/usr/include/time.h" 1 3
/* Copyright (C) 1991-2003,2006,2009,2011 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */












/* <time.h> included.  */
# 51 "/usr/include/time.h" 3


/* clock_t not defined and <time.h> or need clock_t.  */
# 66 "/usr/include/time.h" 3

#undef	__need_clock_t

/* time_t not defined and <time.h> or need time_t.  */
# 82 "/usr/include/time.h" 3

#undef	__need_time_t

/* clockid_t not defined and <time.h> or need clockid_t.  */
# 94 "/usr/include/time.h" 3

#undef	__clockid_time_t

/* timer_t not defined and <time.h> or need timer_t.  */
# 106 "/usr/include/time.h" 3

#undef	__need_timer_t


/* timespec not defined and <time.h> or need timespec.  */
# 126 "/usr/include/time.h" 3

#undef	__need_timespec


/* <time.h> included.  */
# 419 "/usr/include/time.h" 3


/* <time.h> not already included.  */
# 76 "/usr/include/signal.h" 2 3


/* Get the `siginfo_t' type plus the needed symbols.  */
#include <bits/siginfo.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 1 3
/* siginfo_t, sigevent and constants.  Linux version.
   Copyright (C) 1997-2002, 2003, 2011 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */






#include <bits/wordsize.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3
/* Determine the wordsize from the preprocessor defines.  */


#define __WORDSIZE	64
#define __WORDSIZE_COMPAT32	1



# 25 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 2 3





#define __have_sigval_t	1

/* Type for data associated with a signal.  */
typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;




#define __have_siginfo_t	1

#define __SI_MAX_SIZE     128

#define __SI_PAD_SIZE     ((__SI_MAX_SIZE / sizeof (int)) - 4)




typedef struct siginfo
  {
    int si_signo;		/* Signal number.  */
    int si_errno;		/* If non-zero, an errno value associated with
				   this signal, as defined in <errno.h>.  */
    int si_code;		/* Signal code.  */

    union
      {
	int _pad[((128  / sizeof (int)) - 4) ];

	 /* kill().  */
	struct
	  {
	    __pid_t si_pid;	/* Sending process ID.  */
	    __uid_t si_uid;	/* Real user ID of sending process.  */
	  } _kill;

	/* POSIX.1b timers.  */
	struct
	  {
	    int si_tid;		/* Timer ID.  */
	    int si_overrun;	/* Overrun count.  */
	    sigval_t si_sigval;	/* Signal value.  */
	  } _timer;

	/* POSIX.1b signals.  */
	struct
	  {
	    __pid_t si_pid;	/* Sending process ID.  */
	    __uid_t si_uid;	/* Real user ID of sending process.  */
	    sigval_t si_sigval;	/* Signal value.  */
	  } _rt;

	/* SIGCHLD.  */
	struct
	  {
	    __pid_t si_pid;	/* Which child.  */
	    __uid_t si_uid;	/* Real user ID of sending process.  */
	    int si_status;	/* Exit value or signal.  */
	    __clock_t si_utime;
	    __clock_t si_stime;
	  } _sigchld;

	/* SIGILL, SIGFPE, SIGSEGV, SIGBUS.  */
	struct
	  {
	    void *si_addr;	/* Faulting insn/memory ref.  */
	  } _sigfault;

	/* SIGPOLL.  */
	struct
	  {
	    long int si_band;	/* Band event for SIGPOLL.  */
	    int si_fd;
	  } _sigpoll;
      } _sifields;
  } siginfo_t;


/* X/Open requires some more fields with fixed names.  */
#define si_pid		_sifields._kill.si_pid
#define si_uid		_sifields._kill.si_uid
#define si_timerid	_sifields._timer.si_tid
#define si_overrun	_sifields._timer.si_overrun
#define si_status	_sifields._sigchld.si_status
#define si_utime	_sifields._sigchld.si_utime
#define si_stime	_sifields._sigchld.si_stime
#define si_value	_sifields._rt.si_sigval
#define si_int		_sifields._rt.si_sigval.sival_int
#define si_ptr		_sifields._rt.si_sigval.sival_ptr
#define si_addr	_sifields._sigfault.si_addr
#define si_band	_sifields._sigpoll.si_band
#define si_fd		_sifields._sigpoll.si_fd


/* Values for `si_code'.  Positive values are reserved for kernel-generated
   signals.  */
enum
{
  SI_ASYNCNL = -60,		/* Sent by asynch name lookup completion.  */
#define SI_ASYNCNL	SI_ASYNCNL
  SI_TKILL = -6,		/* Sent by tkill.  */
#define SI_TKILL	SI_TKILL
  SI_SIGIO,			/* Sent by queued SIGIO. */
#define SI_SIGIO	SI_SIGIO
  SI_ASYNCIO,			/* Sent by AIO completion.  */
#define SI_ASYNCIO	SI_ASYNCIO
  SI_MESGQ,			/* Sent by real time mesq state change.  */
#define SI_MESGQ	SI_MESGQ
  SI_TIMER,			/* Sent by timer expiration.  */
#define SI_TIMER	SI_TIMER
  SI_QUEUE,			/* Sent by sigqueue.  */
#define SI_QUEUE	SI_QUEUE
  SI_USER,			/* Sent by kill, sigsend.  */
#define SI_USER	SI_USER
  SI_KERNEL = 0x80		/* Send by kernel.  */
#define SI_KERNEL	SI_KERNEL
};


/* `si_code' values for SIGILL signal.  */
enum
{
  ILL_ILLOPC = 1,		/* Illegal opcode.  */
#define ILL_ILLOPC	ILL_ILLOPC
  ILL_ILLOPN,			/* Illegal operand.  */
#define ILL_ILLOPN	ILL_ILLOPN
  ILL_ILLADR,			/* Illegal addressing mode.  */
#define ILL_ILLADR	ILL_ILLADR
  ILL_ILLTRP,			/* Illegal trap. */
#define ILL_ILLTRP	ILL_ILLTRP
  ILL_PRVOPC,			/* Privileged opcode.  */
#define ILL_PRVOPC	ILL_PRVOPC
  ILL_PRVREG,			/* Privileged register.  */
#define ILL_PRVREG	ILL_PRVREG
  ILL_COPROC,			/* Coprocessor error.  */
#define ILL_COPROC	ILL_COPROC
  ILL_BADSTK			/* Internal stack error.  */
#define ILL_BADSTK	ILL_BADSTK
};

/* `si_code' values for SIGFPE signal.  */
enum
{
  FPE_INTDIV = 1,		/* Integer divide by zero.  */
#define FPE_INTDIV	FPE_INTDIV
  FPE_INTOVF,			/* Integer overflow.  */
#define FPE_INTOVF	FPE_INTOVF
  FPE_FLTDIV,			/* Floating point divide by zero.  */
#define FPE_FLTDIV	FPE_FLTDIV
  FPE_FLTOVF,			/* Floating point overflow.  */
#define FPE_FLTOVF	FPE_FLTOVF
  FPE_FLTUND,			/* Floating point underflow.  */
#define FPE_FLTUND	FPE_FLTUND
  FPE_FLTRES,			/* Floating point inexact result.  */
#define FPE_FLTRES	FPE_FLTRES
  FPE_FLTINV,			/* Floating point invalid operation.  */
#define FPE_FLTINV	FPE_FLTINV
  FPE_FLTSUB			/* Subscript out of range.  */
#define FPE_FLTSUB	FPE_FLTSUB
};

/* `si_code' values for SIGSEGV signal.  */
enum
{
  SEGV_MAPERR = 1,		/* Address not mapped to object.  */
#define SEGV_MAPERR	SEGV_MAPERR
  SEGV_ACCERR			/* Invalid permissions for mapped object.  */
#define SEGV_ACCERR	SEGV_ACCERR
};

/* `si_code' values for SIGBUS signal.  */
enum
{
  BUS_ADRALN = 1,		/* Invalid address alignment.  */
#define BUS_ADRALN	BUS_ADRALN
  BUS_ADRERR,			/* Non-existant physical address.  */
#define BUS_ADRERR	BUS_ADRERR
  BUS_OBJERR			/* Object specific hardware error.  */
#define BUS_OBJERR	BUS_OBJERR
};

/* `si_code' values for SIGTRAP signal.  */
enum
{
  TRAP_BRKPT = 1,		/* Process breakpoint.  */
#define TRAP_BRKPT	TRAP_BRKPT
  TRAP_TRACE			/* Process trace trap.  */
#define TRAP_TRACE	TRAP_TRACE
};

/* `si_code' values for SIGCHLD signal.  */
enum
{
  CLD_EXITED = 1,		/* Child has exited.  */
#define CLD_EXITED	CLD_EXITED
  CLD_KILLED,			/* Child was killed.  */
#define CLD_KILLED	CLD_KILLED
  CLD_DUMPED,			/* Child terminated abnormally.  */
#define CLD_DUMPED	CLD_DUMPED
  CLD_TRAPPED,			/* Traced child has trapped.  */
#define CLD_TRAPPED	CLD_TRAPPED
  CLD_STOPPED,			/* Child has stopped.  */
#define CLD_STOPPED	CLD_STOPPED
  CLD_CONTINUED			/* Stopped child has continued.  */
#define CLD_CONTINUED	CLD_CONTINUED
};

/* `si_code' values for SIGPOLL signal.  */
enum
{
  POLL_IN = 1,			/* Data input available.  */
#define POLL_IN	POLL_IN
  POLL_OUT,			/* Output buffers available.  */
#define POLL_OUT	POLL_OUT
  POLL_MSG,			/* Input message available.   */
#define POLL_MSG	POLL_MSG
  POLL_ERR,			/* I/O error.  */
#define POLL_ERR	POLL_ERR
  POLL_PRI,			/* High priority input available.  */
#define POLL_PRI	POLL_PRI
  POLL_HUP			/* Device disconnected.  */
#define POLL_HUP	POLL_HUP
};

#undef __need_siginfo_t
/* !have siginfo_t && (have _SIGNAL_H || need siginfo_t).  */




#define __have_sigevent_t	1

/* Structure to transport application-defined values with signals.  */
#define __SIGEV_MAX_SIZE	64

#define __SIGEV_PAD_SIZE	((__SIGEV_MAX_SIZE / sizeof (int)) - 4)




typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
	int _pad[((64  / sizeof (int)) - 4) ];

	/* When SIGEV_SIGNAL and SIGEV_THREAD_ID set, LWP ID of the
	   thread to receive the signal.  */
	__pid_t _tid;

	struct
	  {
	    void (*_function) (sigval_t);	/* Function to start.  */
	    void *_attribute;			/* Really pthread_attr_t.  */
	  } _sigev_thread;
      } _sigev_un;
  } sigevent_t;

/* POSIX names to access some of the members.  */
#define sigev_notify_function   _sigev_un._sigev_thread._function
#define sigev_notify_attributes _sigev_un._sigev_thread._attribute

/* `sigev_notify' values.  */
enum
{
  SIGEV_SIGNAL = 0,		/* Notify via signal.  */
#define SIGEV_SIGNAL	SIGEV_SIGNAL
  SIGEV_NONE,			/* Other notification: meaningless.  */
#define SIGEV_NONE	SIGEV_NONE
  SIGEV_THREAD,			/* Deliver via thread creation.  */
#define SIGEV_THREAD	SIGEV_THREAD

  SIGEV_THREAD_ID = 4		/* Send signal to specific thread.  */
#define SIGEV_THREAD_ID	SIGEV_THREAD_ID
};

/* have _SIGNAL_H.  */
# 79 "/usr/include/signal.h" 2 3




/* Type of a signal handler.  */
typedef void (*__sighandler_t) (int);

/* The X/Open definition of `signal' specifies the SVID semantic.  Use
   the additional function `sysv_signal' when X/Open compatibility is
   requested.  */
extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__ )) ;





/* Set the handler for the signal SIG to HANDLER, returning the old
   handler, or SIG_ERR on error.
   By default `signal' has the BSD semantic.  */
 

extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__ )) ;
# 112 "/usr/include/signal.h" 3

 








/* Send signal SIG to process number PID.  If PID is zero,
   send SIG to all processes in the current process's process group.
   If PID is < -1, send SIG to all processes in process group - PID.  */

extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__ , __leaf__ )) ;
/* Use POSIX.  */


/* Send SIG to all processes in process group PGRP.
   If PGRP is zero, send SIG to all processes in
   the current process's process group.  */
extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__ , __leaf__ )) ;
/* Use BSD || X/Open Unix.  */

 
/* Raise signal SIG, i.e., send SIG to yourself.  */
extern int raise (int __sig) __attribute__ ((__nothrow__ , __leaf__ )) ;
 


/* SVID names for the same things.  */
extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__ )) ;
extern int gsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__ )) ;
/* Use SVID.  */


/* Print a message describing the meaning of the given signal number.  */
extern void psignal (int __sig, __const char *__s);
/* Use misc or POSIX 2008.  */


/* Print a message describing the meaning of the given signal information.  */
extern void psiginfo (__const siginfo_t *__pinfo, __const char *__s);
/* POSIX 2008.  */



/* The `sigpause' function has two different interfaces.  The original
   BSD definition defines the argument as a mask of the signal, while
   the more modern interface in X/Open defines it as the signal
   number.  We go with the BSD version unless the user explicitly
   selects the X/Open version.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int __sigpause (int __sig_or_mask, int __is_sig);


















/* None of the following functions should be used anymore.  They are here
   only for compatibility.  A single word (`int') is not guaranteed to be
   enough to hold a complete signal mask and therefore these functions
   simply do not work in many situations.  Use `sigprocmask' instead.  */

/* Compute mask for signal SIG.  */
#define sigmask(sig)	__sigmask(sig)

/* Block signals in MASK, returning the old mask.  */
extern int sigblock (int __mask) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__deprecated__)) ;

/* Set the mask of blocked signals to MASK, returning the old mask.  */
extern int sigsetmask (int __mask) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__deprecated__)) ;

/* Return currently selected signal mask.  */
extern int siggetmask (void) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__deprecated__)) ;
/* Use BSD.  */



#define NSIG	_NSIG






/* 4.4 BSD uses the name `sig_t' for this.  */

typedef __sighandler_t sig_t;




/* Clear all signals from SET.  */
extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;

/* Set all signals in SET.  */
extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;

/* Add SIGNO to SET.  */
extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;

/* Remove SIGNO from SET.  */
extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;

/* Return 1 if SIGNO is in SET, 0 if not.  */
extern int sigismember (__const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;

/* GNU */
# 248 "/usr/include/signal.h" 3


/* Get the system-specific definitions of `struct sigaction'
   and the `SA_*' and `SIG_*'. constants.  */
#include <bits/sigaction.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 1 3
/* The proper definitions for Linux's sigaction.
   Copyright (C) 1993-1999, 2000, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */





/* Structure describing the action to be taken when a signal arrives.  */
struct sigaction
  {
    /* Signal handler.  */

    union
      {
	/* Used if SA_SIGINFO is not set.  */
	__sighandler_t sa_handler;
	/* Used if SA_SIGINFO is set.  */
	void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;
#define sa_handler	__sigaction_handler.sa_handler
#define sa_sigaction	__sigaction_handler.sa_sigaction




    /* Additional set of signals to be blocked.  */
    __sigset_t sa_mask;

    /* Special flags.  */
    int sa_flags;

    /* Restore handler.  */
    void (*sa_restorer) (void);
  };

/* Bits in `sa_flags'.  */
#define	SA_NOCLDSTOP  1		 /* Don't send SIGCHLD when children stop.  */
#define SA_NOCLDWAIT  2		 /* Don't create zombie on child death.  */
#define SA_SIGINFO    4		 /* Invoke signal-catching function with
				    three arguments instead of one.  */

#define SA_ONSTACK   0x08000000 /* Use signal stack by using `sa_restorer'. */


#define SA_RESTART   0x10000000 /* Restart syscall on signal return.  */
#define SA_NODEFER   0x40000000 /* Don't automatically block the signal when
				    its handler is being executed.  */
#define SA_RESETHAND 0x80000000 /* Reset to SIG_DFL on entry to handler.  */


#define SA_INTERRUPT 0x20000000 /* Historical no-op.  */

/* Some aliases for the SA_ constants.  */
#define SA_NOMASK    SA_NODEFER
#define SA_ONESHOT   SA_RESETHAND
#define SA_STACK     SA_ONSTACK


/* Values for the HOW argument to `sigprocmask'.  */
#define	SIG_BLOCK     0		 /* Block signals.  */
#define	SIG_UNBLOCK   1		 /* Unblock signals.  */
#define	SIG_SETMASK   2		 /* Set the set of blocked signals.  */
# 252 "/usr/include/signal.h" 2 3


/* Get and/or change the set of blocked signals.  */
extern int sigprocmask (int __how, __const sigset_t *__restrict __set,
			sigset_t *__restrict __oset) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Change the set of blocked signals to SET,
   wait until a signal arrives, and restore the set of blocked signals.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sigsuspend (__const sigset_t *__set) __attribute__ ((__nonnull__  (1) )) ;

/* Get and/or set the action for signal SIG.  */
extern int sigaction (int __sig, __const struct sigaction *__restrict __act,
		      struct sigaction *__restrict __oact) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Put in SET all signals that are blocked and waiting to be delivered.  */
extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;


/* Select any of pending signals from SET or wait for any to arrive.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sigwait (__const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__  (1, 2) )) ;


/* Select any of pending signals from SET and place information in INFO.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sigwaitinfo (__const sigset_t *__restrict __set,
			siginfo_t *__restrict __info) __attribute__ ((__nonnull__  (1) )) ;

/* Select any of pending signals from SET and place information in INFO.
   Wait the time specified by TIMEOUT if no signal is pending.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int sigtimedwait (__const sigset_t *__restrict __set,
			 siginfo_t *__restrict __info,
			 __const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__  (1) )) ;

/* Send signal SIG to the process PID.  Associate data in VAL with the
   signal.  */
extern int sigqueue (__pid_t __pid, int __sig, __const union sigval __val)
     __attribute__ ((__nothrow__ , __leaf__ )) ;
/* Use POSIX 199306.  */

/* Use POSIX.  */



/* Names of the signals.  This variable exists only for compatibility.
   Use `strsignal' instead (see <string.h>).  */
extern __const char *__const _sys_siglist[65 ];
extern __const char *__const sys_siglist[65 ];

/* Structure passed to `sigvec'.  */
struct sigvec
  {
    __sighandler_t sv_handler;	/* Signal handler.  */
    int sv_mask;		/* Mask of signals to be blocked.  */

    int sv_flags;		/* Flags (see below).  */
#define sv_onstack	sv_flags /* 4.2 BSD compatibility.  */
  };

/* Bits in `sv_flags'.  */
#define SV_ONSTACK	(1 << 0)/* Take the signal on the signal stack.  */
#define SV_INTERRUPT	(1 << 1)/* Do not restart system calls.  */
#define SV_RESETHAND	(1 << 2)/* Reset handler to SIG_DFL on receipt.  */


/* If VEC is non-NULL, set the handler for SIG to the `sv_handler' member
   of VEC.  The signals in `sv_mask' will be blocked while the handler runs.
   If the SV_RESETHAND bit is set in `sv_flags', the handler for SIG will be
   reset to SIG_DFL before `sv_handler' is entered.  If OVEC is non-NULL,
   it is filled in with the old information for SIG.  */
extern int sigvec (int __sig, __const struct sigvec *__vec,
		   struct sigvec *__ovec) __attribute__ ((__nothrow__ , __leaf__ )) ;


/* Get machine-dependent `struct sigcontext' and signal subcodes.  */
#include <bits/sigcontext.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 1 3
/* Copyright (C) 2002 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */


#define _BITS_SIGCONTEXT_H  1





#include <bits/wordsize.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3
/* Determine the wordsize from the preprocessor defines.  */


#define __WORDSIZE	64
#define __WORDSIZE_COMPAT32	1



# 26 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 2 3


struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short padding[3];
};

struct _xmmreg
{
  __uint32_t	element[4];
};



/* __WORDSIZE == 64 */
# 107 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3


struct _fpstate
{
  /* FPU environment matching the 64-bit FXSAVE layout.  */
  __uint16_t		cwd;
  __uint16_t		swd;
  __uint16_t		ftw;
  __uint16_t		fop;
  __uint64_t		rip;
  __uint64_t		rdp;
  __uint32_t		mxcsr;
  __uint32_t		mxcr_mask;
  struct _fpxreg	_st[8];
  struct _xmmreg	_xmm[16];
  __uint32_t		padding[24];
};

struct sigcontext
{
  unsigned long r8;
  unsigned long r9;
  unsigned long r10;
  unsigned long r11;
  unsigned long r12;
  unsigned long r13;
  unsigned long r14;
  unsigned long r15;
  unsigned long rdi;
  unsigned long rsi;
  unsigned long rbp;
  unsigned long rbx;
  unsigned long rdx;
  unsigned long rax;
  unsigned long rcx;
  unsigned long rsp;
  unsigned long rip;
  unsigned long eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  unsigned long err;
  unsigned long trapno;
  unsigned long oldmask;
  unsigned long cr2;
  struct _fpstate * fpstate;
  unsigned long __reserved1 [8];
};

/* __WORDSIZE == 64 */

/* _BITS_SIGCONTEXT_H */
# 339 "/usr/include/signal.h" 2 3


/* Restore the state saved in SCP.  */
extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__ , __leaf__ )) ;

/*  use BSD.  */



#define __need_size_t
#include <stddef.h>
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004, 2009
   Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3



/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
/* defined(_ANSI_H_) || defined(_MACHINE_ANSI_H_) || defined(_X86_64_ANSI_H_) || defined(_I386_ANSI_H_) */
# 93 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */













/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* in case <sys/types.h> has defined it. *//* _PTRDIFF_T */
# 158 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* If this symbol has done its job, get rid of it.  */
#undef	__need_ptrdiff_t

/* _STDDEF_H or __need_ptrdiff_t.  */

/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* BeOS *//* __size_t__ */
# 233 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3

#undef	__need_size_t
/* _STDDEF_H or __need_size_t.  */


/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* BeOS *//* __wchar_t__ */
# 342 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3

#undef	__need_wchar_t
/* _STDDEF_H or __need_wchar_t.  */

# 356 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
/* _ANSI_H_ || _MACHINE_ANSI_H_ || _X86_64_ANSI_H_ || _I386_ANSI_H_ */
# 390 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* __sys_stdtypes_h */

/* A null pointer constant.  */


#undef NULL		/* in case <stdio.h> has defined it. */
/* G++ */



#define NULL ((void *)0)
/* C++ *//* C++ */


/* G++ */
/* NULL not defined and <stddef.h> or need NULL.  */
#undef	__need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)

/* _STDDEF_H was defined this time */

/* !_STDDEF_H && !_STDDEF_H_ && !_ANSI_STDDEF_H && !__STDDEF_H__
	  || __need_XXX was not defined before */
# 349 "/usr/include/signal.h" 2 3


/* If INTERRUPT is nonzero, make signal SIG interrupt system calls
   (causing them to fail with EINTR); if INTERRUPT is zero, make system
   calls be restarted after signal SIG.  */
extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__ , __leaf__ )) ;

#include <bits/sigstack.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/sigstack.h" 1 3
/* sigstack, sigaltstack definitions.
   Copyright (C) 1998, 1999 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */






/* Structure describing a signal stack (obsolete).  */
struct sigstack
  {
    void *ss_sp;		/* Signal stack pointer.  */
    int ss_onstack;		/* Nonzero if executing on this stack.  */
  };


/* Possible values for `ss_flags.'.  */
enum
{
  SS_ONSTACK = 1,
#define SS_ONSTACK	SS_ONSTACK
  SS_DISABLE
#define SS_DISABLE	SS_DISABLE
};

/* Minimum stack size for a signal handler.  */
#define MINSIGSTKSZ	2048

/* System default stack size.  */
#define SIGSTKSZ	8192


/* Alternate, preferred interface.  */
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 356 "/usr/include/signal.h" 2 3


/* This will define `ucontext_t' and `mcontext_t'.  */
#include <sys/ucontext.h>
# 1 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 1 3
/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */


#define _SYS_UCONTEXT_H	1

#include <features.h>
#include <signal.h>
# 1 "/usr/include/signal.h" 1 3
/* Copyright (C) 1991-2004, 2007, 2009, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.14 Signal handling <signal.h>
 */

/* not signal.h */
# 410 "/usr/include/signal.h" 3

# 23 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 2 3

#include <bits/wordsize.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3
/* Determine the wordsize from the preprocessor defines.  */


#define __WORDSIZE	64
#define __WORDSIZE_COMPAT32	1



# 24 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 2 3


/* We need the signal context definitions even if they are not used
   included in <signal.h>.  */
#include <bits/sigcontext.h>



/* Type for general register.  */
typedef long int greg_t;

/* Number of general registers.  */
#define NGREG	23

/* Container for all general registers.  */
typedef greg_t gregset_t[23 ];

# 92 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3


struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int padding[3];
};

struct _libc_xmmreg
{
  __uint32_t	element[4];
};

struct _libc_fpstate
{
  /* 64-bit FXSAVE format.  */
  __uint16_t		cwd;
  __uint16_t		swd;
  __uint16_t		ftw;
  __uint16_t		fop;
  __uint64_t		rip;
  __uint64_t		rdp;
  __uint32_t		mxcsr;
  __uint32_t		mxcr_mask;
  struct _libc_fpxreg	_st[8];
  struct _libc_xmmreg	_xmm[16];
  __uint32_t		padding[24];
};

/* Structure to describe FPU registers.  */
typedef struct _libc_fpstate *fpregset_t;

/* Context to describe whole processor state.  */
typedef struct
  {
    gregset_t gregs;
    /* Note that fpregs is a pointer.  */
    fpregset_t fpregs;
    unsigned long __reserved1 [8];
} mcontext_t;

/* Userlevel context.  */
typedef struct ucontext
  {
    unsigned long int uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;

/* __WORDSIZE == 32 *//* __WORDSIZE == 32 */
# 246 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3


/* sys/ucontext.h */
# 359 "/usr/include/signal.h" 2 3



/* Run signals handlers on the stack specified by SS (if not NULL).
   If OSS is not NULL, it is filled in with the old signal stack status.
   This interface is obsolete and on many platform not implemented.  */
extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__deprecated__)) ;

/* Alternate signal handler stack interface.
   This interface should always be preferred over `sigstack'.  */
extern int sigaltstack (__const struct sigaltstack *__restrict __ss,
			struct sigaltstack *__restrict __oss) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* use BSD or X/Open Unix.  */

# 389 "/usr/include/signal.h" 3



/* Some of the functions for handling signals in threaded programs must
   be defined here.  */
#include <bits/pthreadtypes.h>
#include <bits/sigthread.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 1 3
/* Signal handling function for threaded programs.
   Copyright (C) 1998, 1999, 2000, 2002, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */


#define _BITS_SIGTHREAD_H	1





/* Functions for handling signals. */

/* Modify the signal mask for the calling thread.  The arguments have
   the same meaning as for sigprocmask(2). */
extern int pthread_sigmask (int __how,
			    __const __sigset_t *__restrict __newmask,
			    __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__ , __leaf__ )) ;

/* Send signal SIGNO to the given thread. */
extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__ , __leaf__ )) ;







/* bits/sigthread.h */
# 395 "/usr/include/signal.h" 2 3

/* use Unix98 */

/* The following functions are used internally in the C library and in
   other code which need deep insights.  */

/* Return number of available real-time signal with highest priority.  */
extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__ , __leaf__ )) ;
/* Return number of available real-time signal with lowest priority.  */
extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* signal.h  */

 

/* not signal.h */
# 34 "flinternal.h" 2

#include "local.h"
# 1 "local.h" 1
/*
 *
 *  This file is part of the XForms library package.
 *
 * XForms is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1, or
 * (at your option) any later version.
 *
 * XForms is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with XForms. If not, see <http://www.gnu.org/licenses/>.
 */


/**
 * \file local.h
 *
 *  This file is part of the XForms library package.
 *  Copyright (c) 1996-1998  T.C. Zhao and Mark Overmars
 *  All rights reserved.
 *
 *  Some machine specific stuff.
 */


#define FL_LOCAL_H


#include <unistd.h>
# 1 "/usr/include/unistd.h" 1 3
/* Copyright (C) 1991-2009, 2010, 2011 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	POSIX Standard: 2.10 Symbolic Constants		<unistd.h>
 */


#define	_UNISTD_H	1

#include <features.h>

 

/* These may be used to determine what facilities are present at compile time.
   Their values can be obtained at run time from `sysconf'.  */


/* POSIX Standard approved as ISO/IEC 9945-1 as of September 2008.  */
#define _POSIX_VERSION	200809L
# 48 "/usr/include/unistd.h" 3


/* These are not #ifdef __USE_POSIX2 because they are
   in the theoretically application-owned namespace.  */


#define __POSIX2_THIS_VERSION	200809L
/* The utilities on GNU systems also correspond to this version.  */
# 65 "/usr/include/unistd.h" 3


/* The utilities on GNU systems also correspond to this version.  */
#define _POSIX2_VERSION	__POSIX2_THIS_VERSION

/* If defined, the implementation supports the
   C Language Bindings Option.  */
#define	_POSIX2_C_BIND	__POSIX2_THIS_VERSION

/* If defined, the implementation supports the
   C Language Development Utilities Option.  */
#define	_POSIX2_C_DEV	__POSIX2_THIS_VERSION

/* If defined, the implementation supports the
   Software Development Utilities Option.  */
#define	_POSIX2_SW_DEV	__POSIX2_THIS_VERSION

/* If defined, the implementation supports the
   creation of locales with the localedef utility.  */
#define _POSIX2_LOCALEDEF       __POSIX2_THIS_VERSION

/* X/Open version number to which the library conforms.  It is selectable.  */

#define _XOPEN_VERSION	700








/* Commands and utilities from XPG4 are available.  */
#define _XOPEN_XCU_VERSION	4

/* We are compatible with the old published standards as well.  */
#define _XOPEN_XPG2	1
#define _XOPEN_XPG3	1
#define _XOPEN_XPG4	1

/* The X/Open Unix extensions are available.  */
#define _XOPEN_UNIX	1

/* Encryption is present.  */
#define	_XOPEN_CRYPT	1

/* The enhanced internationalization capabilities according to XPG4.2
   are present.  */
#define	_XOPEN_ENH_I18N	1

/* The legacy interfaces are also available.  */
#define _XOPEN_LEGACY	1


/* Get values of POSIX options:

   If these symbols are defined, the corresponding features are
   always available.  If not, they may be available sometimes.
   The current values can be obtained with `sysconf'.

   _POSIX_JOB_CONTROL		Job control is supported.
   _POSIX_SAVED_IDS		Processes have a saved set-user-ID
				and a saved set-group-ID.
   _POSIX_REALTIME_SIGNALS	Real-time, queued signals are supported.
   _POSIX_PRIORITY_SCHEDULING	Priority scheduling is supported.
   _POSIX_TIMERS		POSIX.4 clocks and timers are supported.
   _POSIX_ASYNCHRONOUS_IO	Asynchronous I/O is supported.
   _POSIX_PRIORITIZED_IO	Prioritized asynchronous I/O is supported.
   _POSIX_SYNCHRONIZED_IO	Synchronizing file data is supported.
   _POSIX_FSYNC			The fsync function is present.
   _POSIX_MAPPED_FILES		Mapping of files to memory is supported.
   _POSIX_MEMLOCK		Locking of all memory is supported.
   _POSIX_MEMLOCK_RANGE		Locking of ranges of memory is supported.
   _POSIX_MEMORY_PROTECTION	Setting of memory protections is supported.
   _POSIX_MESSAGE_PASSING	POSIX.4 message queues are supported.
   _POSIX_SEMAPHORES		POSIX.4 counting semaphores are supported.
   _POSIX_SHARED_MEMORY_OBJECTS	POSIX.4 shared memory objects are supported.
   _POSIX_THREADS		POSIX.1c pthreads are supported.
   _POSIX_THREAD_ATTR_STACKADDR	Thread stack address attribute option supported.
   _POSIX_THREAD_ATTR_STACKSIZE	Thread stack size attribute option supported.
   _POSIX_THREAD_SAFE_FUNCTIONS	Thread-safe functions are supported.
   _POSIX_THREAD_PRIORITY_SCHEDULING
				POSIX.1c thread execution scheduling supported.
   _POSIX_THREAD_PRIO_INHERIT	Thread priority inheritance option supported.
   _POSIX_THREAD_PRIO_PROTECT	Thread priority protection option supported.
   _POSIX_THREAD_PROCESS_SHARED	Process-shared synchronization supported.
   _POSIX_PII			Protocol-independent interfaces are supported.
   _POSIX_PII_XTI		XTI protocol-indep. interfaces are supported.
   _POSIX_PII_SOCKET		Socket protocol-indep. interfaces are supported.
   _POSIX_PII_INTERNET		Internet family of protocols supported.
   _POSIX_PII_INTERNET_STREAM	Connection-mode Internet protocol supported.
   _POSIX_PII_INTERNET_DGRAM	Connectionless Internet protocol supported.
   _POSIX_PII_OSI		ISO/OSI family of protocols supported.
   _POSIX_PII_OSI_COTS		Connection-mode ISO/OSI service supported.
   _POSIX_PII_OSI_CLTS		Connectionless ISO/OSI service supported.
   _POSIX_POLL			Implementation supports `poll' function.
   _POSIX_SELECT		Implementation supports `select' and `pselect'.

   _XOPEN_REALTIME		X/Open realtime support is available.
   _XOPEN_REALTIME_THREADS	X/Open realtime thread support is available.
   _XOPEN_SHM			Shared memory interface according to XPG4.2.

   _XBS5_ILP32_OFF32		Implementation provides environment with 32-bit
				int, long, pointer, and off_t types.
   _XBS5_ILP32_OFFBIG		Implementation provides environment with 32-bit
				int, long, and pointer and off_t with at least
				64 bits.
   _XBS5_LP64_OFF64		Implementation provides environment with 32-bit
				int, and 64-bit long, pointer, and off_t types.
   _XBS5_LPBIG_OFFBIG		Implementation provides environment with at
				least 32 bits int and long, pointer, and off_t
				with at least 64 bits.

   If any of these symbols is defined as -1, the corresponding option is not
   true for any file.  If any is defined as other than -1, the corresponding
   option is true for all files.  If a symbol is not defined at all, the value
   for a specific file can be obtained from `pathconf' and `fpathconf'.

   _POSIX_CHOWN_RESTRICTED	Only the super user can use `chown' to change
				the owner of a file.  `chown' can only be used
				to change the group ID of a file to a group of
				which the calling process is a member.
   _POSIX_NO_TRUNC		Pathname components longer than
				NAME_MAX generate an error.
   _POSIX_VDISABLE		If defined, if the value of an element of the
				`c_cc' member of `struct termios' is
				_POSIX_VDISABLE, no character will have the
				effect associated with that element.
   _POSIX_SYNC_IO		Synchronous I/O may be performed.
   _POSIX_ASYNC_IO		Asynchronous I/O may be performed.
   _POSIX_PRIO_IO		Prioritized Asynchronous I/O may be performed.

   Support for the Large File Support interface is not generally available.
   If it is available the following constants are defined to one.
   _LFS64_LARGEFILE		Low-level I/O supports large files.
   _LFS64_STDIO			Standard I/O supports large files.
   */

#include <bits/posix_opt.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3
/* Define POSIX options for Linux.
   Copyright (C) 1996-2004, 2006, 2008, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */


#define	_BITS_POSIX_OPT_H	1

/* Job control is supported.  */
#define	_POSIX_JOB_CONTROL	1

/* Processes have a saved set-user-ID and a saved set-group-ID.  */
#define	_POSIX_SAVED_IDS	1

/* Priority scheduling is supported.  */
#define	_POSIX_PRIORITY_SCHEDULING	200809L

/* Synchronizing file data is supported.  */
#define	_POSIX_SYNCHRONIZED_IO	200809L

/* The fsync function is present.  */
#define	_POSIX_FSYNC	200809L

/* Mapping of files to memory is supported.  */
#define	_POSIX_MAPPED_FILES	200809L

/* Locking of all memory is supported.  */
#define	_POSIX_MEMLOCK	200809L

/* Locking of ranges of memory is supported.  */
#define	_POSIX_MEMLOCK_RANGE	200809L

/* Setting of memory protections is supported.  */
#define	_POSIX_MEMORY_PROTECTION	200809L

/* Some filesystems allow all users to change file ownership.  */
#define	_POSIX_CHOWN_RESTRICTED	0

/* `c_cc' member of 'struct termios' structure can be disabled by
   using the value _POSIX_VDISABLE.  */
#define	_POSIX_VDISABLE	'\0'

/* Filenames are not silently truncated.  */
#define	_POSIX_NO_TRUNC	1

/* X/Open realtime support is available.  */
#define _XOPEN_REALTIME	1

/* X/Open thread realtime support is available.  */
#define _XOPEN_REALTIME_THREADS	1

/* XPG4.2 shared memory is supported.  */
#define	_XOPEN_SHM	1

/* Tell we have POSIX threads.  */
#define _POSIX_THREADS	200809L

/* We have the reentrant functions described in POSIX.  */
#define _POSIX_REENTRANT_FUNCTIONS      1
#define _POSIX_THREAD_SAFE_FUNCTIONS	200809L

/* We provide priority scheduling for threads.  */
#define _POSIX_THREAD_PRIORITY_SCHEDULING	200809L

/* We support user-defined stack sizes.  */
#define _POSIX_THREAD_ATTR_STACKSIZE	200809L

/* We support user-defined stacks.  */
#define _POSIX_THREAD_ATTR_STACKADDR	200809L

/* We support priority inheritence.  */
#define _POSIX_THREAD_PRIO_INHERIT	200809L

/* We support priority protection, though only for non-robust
   mutexes.  */
#define _POSIX_THREAD_PRIO_PROTECT	200809L


/* We support priority inheritence for robust mutexes.  */
#define _POSIX_THREAD_ROBUST_PRIO_INHERIT	200809L

/* We do not support priority protection for robust mutexes.  */
#define _POSIX_THREAD_ROBUST_PRIO_PROTECT	-1


/* We support POSIX.1b semaphores.  */
#define _POSIX_SEMAPHORES	200809L

/* Real-time signals are supported.  */
#define _POSIX_REALTIME_SIGNALS	200809L

/* We support asynchronous I/O.  */
#define _POSIX_ASYNCHRONOUS_IO	200809L
#define _POSIX_ASYNC_IO		1
/* Alternative name for Unix98.  */
#define _LFS_ASYNCHRONOUS_IO	1
/* Support for prioritization is also available.  */
#define _POSIX_PRIORITIZED_IO	200809L

/* The LFS support in asynchronous I/O is also available.  */
#define _LFS64_ASYNCHRONOUS_IO	1

/* The rest of the LFS is also available.  */
#define _LFS_LARGEFILE		1
#define _LFS64_LARGEFILE	1
#define _LFS64_STDIO		1

/* POSIX shared memory objects are implemented.  */
#define _POSIX_SHARED_MEMORY_OBJECTS	200809L

/* CPU-time clocks support needs to be checked at runtime.  */
#define _POSIX_CPUTIME	0

/* Clock support in threads must be also checked at runtime.  */
#define _POSIX_THREAD_CPUTIME	0

/* GNU libc provides regular expression handling.  */
#define _POSIX_REGEXP	1

/* Reader/Writer locks are available.  */
#define _POSIX_READER_WRITER_LOCKS	200809L

/* We have a POSIX shell.  */
#define _POSIX_SHELL	1

/* We support the Timeouts option.  */
#define _POSIX_TIMEOUTS	200809L

/* We support spinlocks.  */
#define _POSIX_SPIN_LOCKS	200809L

/* The `spawn' function family is supported.  */
#define _POSIX_SPAWN	200809L

/* We have POSIX timers.  */
#define _POSIX_TIMERS	200809L

/* The barrier functions are available.  */
#define _POSIX_BARRIERS	200809L

/* POSIX message queues are available.  */
#define	_POSIX_MESSAGE_PASSING	200809L

/* Thread process-shared synchronization is supported.  */
#define _POSIX_THREAD_PROCESS_SHARED	200809L

/* The monotonic clock might be available.  */
#define _POSIX_MONOTONIC_CLOCK	0

/* The clock selection interfaces are available.  */
#define _POSIX_CLOCK_SELECTION	200809L

/* Advisory information interfaces are available.  */
#define _POSIX_ADVISORY_INFO	200809L

/* IPv6 support is available.  */
#define _POSIX_IPV6	200809L

/* Raw socket support is available.  */
#define _POSIX_RAW_SOCKETS	200809L

/* We have at least one terminal.  */
#define _POSIX2_CHAR_TERM	200809L

/* Neither process nor thread sporadic server interfaces is available.  */
#define _POSIX_SPORADIC_SERVER	-1
#define _POSIX_THREAD_SPORADIC_SERVER	-1

/* trace.h is not available.  */
#define _POSIX_TRACE	-1
#define _POSIX_TRACE_EVENT_FILTER	-1
#define _POSIX_TRACE_INHERIT	-1
#define _POSIX_TRACE_LOG	-1

/* Typed memory objects are not available.  */
#define _POSIX_TYPED_MEMORY_OBJECTS	-1

/* bits/posix_opt.h */
# 203 "/usr/include/unistd.h" 2 3


/* Get the environment definitions from Unix98.  */

#include <bits/environments.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3
/* Copyright (C) 1999, 2001, 2004, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */





#include <bits/wordsize.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3
/* Determine the wordsize from the preprocessor defines.  */


#define __WORDSIZE	64
#define __WORDSIZE_COMPAT32	1



# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3


/* This header should define the following symbols under the described
   situations.  A value `1' means that the model is always supported,
   `-1' means it is never supported.  Undefined means it cannot be
   statically decided.

   _POSIX_V7_ILP32_OFF32   32bit int, long, pointers, and off_t type
   _POSIX_V7_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type

   _POSIX_V7_LP64_OFF32	   64bit long and pointers and 32bit off_t type
   _POSIX_V7_LPBIG_OFFBIG  64bit long and pointers and large off_t type

   The macros _POSIX_V6_ILP32_OFF32, _POSIX_V6_ILP32_OFFBIG,
   _POSIX_V6_LP64_OFF32, _POSIX_V6_LPBIG_OFFBIG, _XBS5_ILP32_OFF32,
   _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and _XBS5_LPBIG_OFFBIG were
   used in previous versions of the Unix standard and are available
   only for compatibility.
*/



/* Environments with 32-bit wide pointers are optionally provided.
   Therefore following macros aren't defined:
   # undef _POSIX_V7_ILP32_OFF32
   # undef _POSIX_V7_ILP32_OFFBIG
   # undef _POSIX_V6_ILP32_OFF32
   # undef _POSIX_V6_ILP32_OFFBIG
   # undef _XBS5_ILP32_OFF32
   # undef _XBS5_ILP32_OFFBIG
   and users need to check at runtime.  */

/* We also have no use (for now) for an environment with bigger pointers
   and offsets.  */
#define _POSIX_V7_LPBIG_OFFBIG	-1
#define _POSIX_V6_LPBIG_OFFBIG	-1
#define _XBS5_LPBIG_OFFBIG	-1

/* By default we have 64-bit wide `long int', pointers and `off_t'.  */
#define _POSIX_V7_LP64_OFF64	1
#define _POSIX_V6_LP64_OFF64	1
#define _XBS5_LP64_OFF64	1

/* __WORDSIZE == 32 *//* __WORDSIZE == 32 */
# 90 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3


#define __ILP32_OFF32_CFLAGS	"-m32"
#define __ILP32_OFFBIG_CFLAGS	"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"
#define __ILP32_OFF32_LDFLAGS	"-m32"
#define __ILP32_OFFBIG_LDFLAGS	"-m32"
#define __LP64_OFF64_CFLAGS	"-m64"
#define __LP64_OFF64_LDFLAGS	"-m64"
# 207 "/usr/include/unistd.h" 2 3



/* Standard file descriptors.  */
#define	STDIN_FILENO	0	/* Standard input.  */
#define	STDOUT_FILENO	1	/* Standard output.  */
#define	STDERR_FILENO	2	/* Standard error output.  */


/* All functions that are not declared anywhere else.  */

#include <bits/types.h>






#define	__need_size_t
#define __need_NULL
#include <stddef.h>
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 1 3
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004, 2009
   Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3



/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
/* defined(_ANSI_H_) || defined(_MACHINE_ANSI_H_) || defined(_X86_64_ANSI_H_) || defined(_I386_ANSI_H_) */
# 93 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */













/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* in case <sys/types.h> has defined it. *//* _PTRDIFF_T */
# 158 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* If this symbol has done its job, get rid of it.  */
#undef	__need_ptrdiff_t

/* _STDDEF_H or __need_ptrdiff_t.  */

/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* BeOS *//* __size_t__ */
# 233 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3

#undef	__need_size_t
/* _STDDEF_H or __need_size_t.  */


/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */

/* BeOS *//* __wchar_t__ */
# 342 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3

#undef	__need_wchar_t
/* _STDDEF_H or __need_wchar_t.  */

# 356 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
/* _ANSI_H_ || _MACHINE_ANSI_H_ || _X86_64_ANSI_H_ || _I386_ANSI_H_ */
# 390 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h" 3


/* __sys_stdtypes_h */

/* A null pointer constant.  */


#undef NULL		/* in case <stdio.h> has defined it. */
/* G++ */



#define NULL ((void *)0)
/* C++ *//* C++ */


/* G++ */
/* NULL not defined and <stddef.h> or need NULL.  */
#undef	__need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)

/* _STDDEF_H was defined this time */

/* !_STDDEF_H && !_STDDEF_H_ && !_ANSI_STDDEF_H && !__STDDEF_H__
	  || __need_XXX was not defined before */
# 227 "/usr/include/unistd.h" 2 3



/* The Single Unix specification says that some more types are
   available here.  */
























typedef __useconds_t useconds_t;
#define __useconds_t_defined






/* X/Open */



typedef __intptr_t intptr_t;
#define __intptr_t_defined





typedef __socklen_t socklen_t;
#define __socklen_t_defined



/* Values for the second argument to access.
   These may be OR'd together.  */
#define	R_OK	4		/* Test for read permission.  */
#define	W_OK	2		/* Test for write permission.  */
#define	X_OK	1		/* Test for execute permission.  */
#define	F_OK	0		/* Test for existence.  */

/* Test for access to NAME using the real UID and real GID.  */
extern int access (__const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;

# 299 "/usr/include/unistd.h" 3



/* Test for access to FILE relative to the directory FD is open on.
   If AT_EACCESS is set in FLAG, then use effective IDs like `eaccess',
   otherwise use real IDs like `access'.  */
extern int faccessat (int __fd, __const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (2) ))   ;
/* Use GNU.  */


/* Values for the WHENCE argument to lseek.  */
/* <stdio.h> has the same definitions.  */
# 319 "/usr/include/unistd.h" 3



/* Old BSD names for the same constants; just for compatibility.  */
#define L_SET		SEEK_SET
#define L_INCR		SEEK_CUR
#define L_XTND		SEEK_END



/* Move FD's file position to OFFSET bytes from the
   beginning of the file (if WHENCE is SEEK_SET),
   the current position (if WHENCE is SEEK_CUR),
   or the end of the file (if WHENCE is SEEK_END).
   Return the new file position.  */

extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__ )) ;
# 344 "/usr/include/unistd.h" 3






/* Close the file descriptor FD.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int close (int __fd);

/* Read NBYTES into BUF from FD.  Return the
   number read, -1 for errors or 0 for EOF.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t read (int __fd, void *__buf, size_t __nbytes)  ;

/* Write N bytes of BUF to FD.  Return the number written, or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t write (int __fd, __const void *__buf, size_t __n)  ;



/* Read NBYTES into BUF from FD at the given position OFFSET without
   changing the file pointer.  Return the number read, -1 for errors
   or 0 for EOF.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
		      __off_t __offset)  ;

/* Write N bytes of BUF to FD at the given position OFFSET without
   changing the file pointer.  Return the number written, or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern ssize_t pwrite (int __fd, __const void *__buf, size_t __n,
		       __off_t __offset)  ;
# 399 "/usr/include/unistd.h" 3


# 411 "/usr/include/unistd.h" 3



/* Create a one-way communication channel (pipe).
   If successful, two file descriptors are stored in PIPEDES;
   bytes written on PIPEDES[1] can be read from PIPEDES[0].
   Returns 0 if successful, -1 if not.  */
extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__ ))   ;







/* Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.
   If SECONDS is zero, any currently scheduled alarm will be cancelled.
   The function returns the number of seconds remaining until the last
   alarm scheduled would have signaled, or zero if there wasn't one.
   There is no return value to indicate an error, but you can set `errno'
   to 0 and check its value after calling `alarm', and this might tell you.
   The signal may come late due to processor scheduling.  */
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Make the process sleep for SECONDS seconds, or until a signal arrives
   and is not ignored.  The function returns the number of seconds less
   than SECONDS which it actually slept (thus zero if it slept the full time).
   If a signal handler does a `longjmp' or modifies the handling of the
   SIGALRM signal while inside `sleep' call, the handling of the SIGALRM
   signal afterwards is undefined.  There is no return value to indicate
   error, but if `sleep' returns SECONDS, it probably didn't work.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern unsigned int sleep (unsigned int __seconds);



/* Set an alarm to go off (generating a SIGALRM signal) in VALUE
   microseconds.  If INTERVAL is nonzero, when the alarm goes off, the
   timer is reset to go off every INTERVAL microseconds thereafter.
   Returns the number of microseconds remaining before the alarm.  */
extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Sleep USECONDS microseconds, or until a signal arrives that is not blocked
   or ignored.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int usleep (__useconds_t __useconds);



/* Suspend the process until a signal arrives.
   This always returns -1 and sets `errno' to EINTR.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int pause (void);


/* Change the owner and group of FILE.  */
extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;


/* Change the owner and group of the file that FD is open on.  */
extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__ ))   ;


/* Change owner and group of FILE, if it is a symbolic
   link the ownership of the symbolic link is changed.  */
extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;

/* Use BSD || X/Open Unix.  */


/* Change the owner and group of FILE relative to the directory FD is open
   on.  */
extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
		     __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (2) ))   ;
/* Use GNU.  */

/* Change the process's working directory to PATH.  */
extern int chdir (__const char *__path) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;


/* Change the process's working directory to the one FD is open on.  */
extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__ ))   ;


/* Get the pathname of the current working directory,
   and put it in SIZE bytes of BUF.  Returns NULL if the
   directory couldn't be determined or SIZE was too small.
   If successful, returns BUF.  In GNU, if BUF is NULL,
   an array is allocated with `malloc'; the array is SIZE
   bytes long, unless SIZE == 0, in which case it is as
   big as necessary.  */
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__ ))   ;










/* Put the absolute pathname of the current working directory in BUF.
   If successful, return BUF.  If not, put an error message in
   BUF and return NULL.  BUF should be at least PATH_MAX bytes long.  */
extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))  __attribute__ ((__deprecated__))   ;



/* Duplicate FD, returning a new file descriptor on the same file.  */
extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__ ))   ;

/* Duplicate FD to FD2, closing FD2 and making it open on the same file.  */
extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__ )) ;







/* NULL-terminated array of "NAME=VALUE" environment variables.  */
extern char **__environ;





/* Replace the current process, executing PATH with arguments ARGV and
   environment ENVP.  ARGV and ENVP are terminated by NULL pointers.  */
extern int execve (__const char *__path, char *__const __argv[],
		   char *__const __envp[]) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;


/* Execute the file FD refers to, overlaying the running program image.
   ARGV and ENVP are passed to the new program, as for `execve'.  */
extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (2) )) ;



/* Execute PATH with arguments ARGV and environment from `environ'.  */
extern int execv (__const char *__path, char *__const __argv[])
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;

/* Execute PATH with all arguments after PATH until a NULL pointer,
   and the argument after that for environment.  */
extern int execle (__const char *__path, __const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;

/* Execute PATH with all arguments after PATH until
   a NULL pointer and environment from `environ'.  */
extern int execl (__const char *__path, __const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;

/* Execute FILE, searching in the `PATH' environment variable if it contains
   no slashes, with arguments ARGV and environment from `environ'.  */
extern int execvp (__const char *__file, char *__const __argv[])
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;

/* Execute FILE, searching in the `PATH' environment variable if
   it contains no slashes, with all arguments after FILE until a
   NULL pointer and environment from `environ'.  */
extern int execlp (__const char *__file, __const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) )) ;











/* Add INC to priority of the current process.  */
extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__ ))   ;



/* Terminate program execution with the low-order 8 bits of STATUS.  */
extern void _exit (int __status) __attribute__ ((__noreturn__));


/* Get the `_PC_*' symbols for the NAME argument to `pathconf' and `fpathconf';
   the `_SC_*' symbols for the NAME argument to `sysconf';
   and the `_CS_*' symbols for the NAME argument to `confstr'.  */
#include <bits/confname.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3
/* `sysconf', `pathconf', and `confstr' NAME values.  Generic version.
   Copyright (C) 1993,1995-1998,2000,2001,2003,2004,2007,2009,2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */





/* Values for the NAME argument to `pathconf' and `fpathconf'.  */
enum
  {
    _PC_LINK_MAX,
#define	_PC_LINK_MAX			_PC_LINK_MAX
    _PC_MAX_CANON,
#define	_PC_MAX_CANON			_PC_MAX_CANON
    _PC_MAX_INPUT,
#define	_PC_MAX_INPUT			_PC_MAX_INPUT
    _PC_NAME_MAX,
#define	_PC_NAME_MAX			_PC_NAME_MAX
    _PC_PATH_MAX,
#define	_PC_PATH_MAX			_PC_PATH_MAX
    _PC_PIPE_BUF,
#define	_PC_PIPE_BUF			_PC_PIPE_BUF
    _PC_CHOWN_RESTRICTED,
#define	_PC_CHOWN_RESTRICTED		_PC_CHOWN_RESTRICTED
    _PC_NO_TRUNC,
#define	_PC_NO_TRUNC			_PC_NO_TRUNC
    _PC_VDISABLE,
#define _PC_VDISABLE			_PC_VDISABLE
    _PC_SYNC_IO,
#define	_PC_SYNC_IO			_PC_SYNC_IO
    _PC_ASYNC_IO,
#define	_PC_ASYNC_IO			_PC_ASYNC_IO
    _PC_PRIO_IO,
#define	_PC_PRIO_IO			_PC_PRIO_IO
    _PC_SOCK_MAXBUF,
#define	_PC_SOCK_MAXBUF			_PC_SOCK_MAXBUF
    _PC_FILESIZEBITS,
#define _PC_FILESIZEBITS		_PC_FILESIZEBITS
    _PC_REC_INCR_XFER_SIZE,
#define _PC_REC_INCR_XFER_SIZE		_PC_REC_INCR_XFER_SIZE
    _PC_REC_MAX_XFER_SIZE,
#define _PC_REC_MAX_XFER_SIZE		_PC_REC_MAX_XFER_SIZE
    _PC_REC_MIN_XFER_SIZE,
#define _PC_REC_MIN_XFER_SIZE		_PC_REC_MIN_XFER_SIZE
    _PC_REC_XFER_ALIGN,
#define _PC_REC_XFER_ALIGN		_PC_REC_XFER_ALIGN
    _PC_ALLOC_SIZE_MIN,
#define _PC_ALLOC_SIZE_MIN		_PC_ALLOC_SIZE_MIN
    _PC_SYMLINK_MAX,
#define _PC_SYMLINK_MAX			_PC_SYMLINK_MAX
    _PC_2_SYMLINKS
#define _PC_2_SYMLINKS			_PC_2_SYMLINKS
  };

/* Values for the argument to `sysconf'.  */
enum
  {
    _SC_ARG_MAX,
#define	_SC_ARG_MAX			_SC_ARG_MAX
    _SC_CHILD_MAX,
#define	_SC_CHILD_MAX			_SC_CHILD_MAX
    _SC_CLK_TCK,
#define	_SC_CLK_TCK			_SC_CLK_TCK
    _SC_NGROUPS_MAX,
#define	_SC_NGROUPS_MAX			_SC_NGROUPS_MAX
    _SC_OPEN_MAX,
#define	_SC_OPEN_MAX			_SC_OPEN_MAX
    _SC_STREAM_MAX,
#define	_SC_STREAM_MAX			_SC_STREAM_MAX
    _SC_TZNAME_MAX,
#define	_SC_TZNAME_MAX			_SC_TZNAME_MAX
    _SC_JOB_CONTROL,
#define	_SC_JOB_CONTROL			_SC_JOB_CONTROL
    _SC_SAVED_IDS,
#define	_SC_SAVED_IDS			_SC_SAVED_IDS
    _SC_REALTIME_SIGNALS,
#define	_SC_REALTIME_SIGNALS		_SC_REALTIME_SIGNALS
    _SC_PRIORITY_SCHEDULING,
#define	_SC_PRIORITY_SCHEDULING		_SC_PRIORITY_SCHEDULING
    _SC_TIMERS,
#define	_SC_TIMERS			_SC_TIMERS
    _SC_ASYNCHRONOUS_IO,
#define	_SC_ASYNCHRONOUS_IO		_SC_ASYNCHRONOUS_IO
    _SC_PRIORITIZED_IO,
#define	_SC_PRIORITIZED_IO		_SC_PRIORITIZED_IO
    _SC_SYNCHRONIZED_IO,
#define	_SC_SYNCHRONIZED_IO		_SC_SYNCHRONIZED_IO
    _SC_FSYNC,
#define	_SC_FSYNC			_SC_FSYNC
    _SC_MAPPED_FILES,
#define	_SC_MAPPED_FILES		_SC_MAPPED_FILES
    _SC_MEMLOCK,
#define	_SC_MEMLOCK			_SC_MEMLOCK
    _SC_MEMLOCK_RANGE,
#define	_SC_MEMLOCK_RANGE		_SC_MEMLOCK_RANGE
    _SC_MEMORY_PROTECTION,
#define	_SC_MEMORY_PROTECTION		_SC_MEMORY_PROTECTION
    _SC_MESSAGE_PASSING,
#define	_SC_MESSAGE_PASSING		_SC_MESSAGE_PASSING
    _SC_SEMAPHORES,
#define	_SC_SEMAPHORES			_SC_SEMAPHORES
    _SC_SHARED_MEMORY_OBJECTS,
#define	_SC_SHARED_MEMORY_OBJECTS	_SC_SHARED_MEMORY_OBJECTS
    _SC_AIO_LISTIO_MAX,
#define	_SC_AIO_LISTIO_MAX		_SC_AIO_LISTIO_MAX
    _SC_AIO_MAX,
#define	_SC_AIO_MAX			_SC_AIO_MAX
    _SC_AIO_PRIO_DELTA_MAX,
#define	_SC_AIO_PRIO_DELTA_MAX		_SC_AIO_PRIO_DELTA_MAX
    _SC_DELAYTIMER_MAX,
#define	_SC_DELAYTIMER_MAX		_SC_DELAYTIMER_MAX
    _SC_MQ_OPEN_MAX,
#define	_SC_MQ_OPEN_MAX			_SC_MQ_OPEN_MAX
    _SC_MQ_PRIO_MAX,
#define	_SC_MQ_PRIO_MAX			_SC_MQ_PRIO_MAX
    _SC_VERSION,
#define	_SC_VERSION			_SC_VERSION
    _SC_PAGESIZE,
#define	_SC_PAGESIZE			_SC_PAGESIZE
#define	_SC_PAGE_SIZE			_SC_PAGESIZE
    _SC_RTSIG_MAX,
#define	_SC_RTSIG_MAX			_SC_RTSIG_MAX
    _SC_SEM_NSEMS_MAX,
#define	_SC_SEM_NSEMS_MAX		_SC_SEM_NSEMS_MAX
    _SC_SEM_VALUE_MAX,
#define	_SC_SEM_VALUE_MAX		_SC_SEM_VALUE_MAX
    _SC_SIGQUEUE_MAX,
#define	_SC_SIGQUEUE_MAX		_SC_SIGQUEUE_MAX
    _SC_TIMER_MAX,
#define	_SC_TIMER_MAX			_SC_TIMER_MAX

    /* Values for the argument to `sysconf'
       corresponding to _POSIX2_* symbols.  */
    _SC_BC_BASE_MAX,
#define	_SC_BC_BASE_MAX			_SC_BC_BASE_MAX
    _SC_BC_DIM_MAX,
#define	_SC_BC_DIM_MAX			_SC_BC_DIM_MAX
    _SC_BC_SCALE_MAX,
#define	_SC_BC_SCALE_MAX		_SC_BC_SCALE_MAX
    _SC_BC_STRING_MAX,
#define	_SC_BC_STRING_MAX		_SC_BC_STRING_MAX
    _SC_COLL_WEIGHTS_MAX,
#define	_SC_COLL_WEIGHTS_MAX		_SC_COLL_WEIGHTS_MAX
    _SC_EQUIV_CLASS_MAX,
#define	_SC_EQUIV_CLASS_MAX		_SC_EQUIV_CLASS_MAX
    _SC_EXPR_NEST_MAX,
#define	_SC_EXPR_NEST_MAX		_SC_EXPR_NEST_MAX
    _SC_LINE_MAX,
#define	_SC_LINE_MAX			_SC_LINE_MAX
    _SC_RE_DUP_MAX,
#define	_SC_RE_DUP_MAX			_SC_RE_DUP_MAX
    _SC_CHARCLASS_NAME_MAX,
#define	_SC_CHARCLASS_NAME_MAX		_SC_CHARCLASS_NAME_MAX

    _SC_2_VERSION,
#define	_SC_2_VERSION			_SC_2_VERSION
    _SC_2_C_BIND,
#define	_SC_2_C_BIND			_SC_2_C_BIND
    _SC_2_C_DEV,
#define	_SC_2_C_DEV			_SC_2_C_DEV
    _SC_2_FORT_DEV,
#define	_SC_2_FORT_DEV			_SC_2_FORT_DEV
    _SC_2_FORT_RUN,
#define	_SC_2_FORT_RUN			_SC_2_FORT_RUN
    _SC_2_SW_DEV,
#define	_SC_2_SW_DEV			_SC_2_SW_DEV
    _SC_2_LOCALEDEF,
#define	_SC_2_LOCALEDEF			_SC_2_LOCALEDEF

    _SC_PII,
#define	_SC_PII				_SC_PII
    _SC_PII_XTI,
#define	_SC_PII_XTI			_SC_PII_XTI
    _SC_PII_SOCKET,
#define	_SC_PII_SOCKET			_SC_PII_SOCKET
    _SC_PII_INTERNET,
#define	_SC_PII_INTERNET		_SC_PII_INTERNET
    _SC_PII_OSI,
#define	_SC_PII_OSI			_SC_PII_OSI
    _SC_POLL,
#define	_SC_POLL			_SC_POLL
    _SC_SELECT,
#define	_SC_SELECT			_SC_SELECT
    _SC_UIO_MAXIOV,
#define	_SC_UIO_MAXIOV			_SC_UIO_MAXIOV
    _SC_IOV_MAX = _SC_UIO_MAXIOV ,
#define _SC_IOV_MAX			_SC_IOV_MAX
    _SC_PII_INTERNET_STREAM,
#define	_SC_PII_INTERNET_STREAM		_SC_PII_INTERNET_STREAM
    _SC_PII_INTERNET_DGRAM,
#define	_SC_PII_INTERNET_DGRAM		_SC_PII_INTERNET_DGRAM
    _SC_PII_OSI_COTS,
#define	_SC_PII_OSI_COTS		_SC_PII_OSI_COTS
    _SC_PII_OSI_CLTS,
#define	_SC_PII_OSI_CLTS		_SC_PII_OSI_CLTS
    _SC_PII_OSI_M,
#define	_SC_PII_OSI_M			_SC_PII_OSI_M
    _SC_T_IOV_MAX,
#define	_SC_T_IOV_MAX			_SC_T_IOV_MAX

    /* Values according to POSIX 1003.1c (POSIX threads).  */
    _SC_THREADS,
#define	_SC_THREADS			_SC_THREADS
    _SC_THREAD_SAFE_FUNCTIONS,
#define _SC_THREAD_SAFE_FUNCTIONS	_SC_THREAD_SAFE_FUNCTIONS
    _SC_GETGR_R_SIZE_MAX,
#define	_SC_GETGR_R_SIZE_MAX		_SC_GETGR_R_SIZE_MAX
    _SC_GETPW_R_SIZE_MAX,
#define	_SC_GETPW_R_SIZE_MAX		_SC_GETPW_R_SIZE_MAX
    _SC_LOGIN_NAME_MAX,
#define	_SC_LOGIN_NAME_MAX		_SC_LOGIN_NAME_MAX
    _SC_TTY_NAME_MAX,
#define	_SC_TTY_NAME_MAX		_SC_TTY_NAME_MAX
    _SC_THREAD_DESTRUCTOR_ITERATIONS,
#define	_SC_THREAD_DESTRUCTOR_ITERATIONS _SC_THREAD_DESTRUCTOR_ITERATIONS
    _SC_THREAD_KEYS_MAX,
#define	_SC_THREAD_KEYS_MAX		_SC_THREAD_KEYS_MAX
    _SC_THREAD_STACK_MIN,
#define	_SC_THREAD_STACK_MIN		_SC_THREAD_STACK_MIN
    _SC_THREAD_THREADS_MAX,
#define	_SC_THREAD_THREADS_MAX		_SC_THREAD_THREADS_MAX
    _SC_THREAD_ATTR_STACKADDR,
#define	_SC_THREAD_ATTR_STACKADDR	_SC_THREAD_ATTR_STACKADDR
    _SC_THREAD_ATTR_STACKSIZE,
#define	_SC_THREAD_ATTR_STACKSIZE	_SC_THREAD_ATTR_STACKSIZE
    _SC_THREAD_PRIORITY_SCHEDULING,
#define	_SC_THREAD_PRIORITY_SCHEDULING	_SC_THREAD_PRIORITY_SCHEDULING
    _SC_THREAD_PRIO_INHERIT,
#define	_SC_THREAD_PRIO_INHERIT		_SC_THREAD_PRIO_INHERIT
    _SC_THREAD_PRIO_PROTECT,
#define	_SC_THREAD_PRIO_PROTECT		_SC_THREAD_PRIO_PROTECT
    _SC_THREAD_PROCESS_SHARED,
#define	_SC_THREAD_PROCESS_SHARED	_SC_THREAD_PROCESS_SHARED

    _SC_NPROCESSORS_CONF,
#define _SC_NPROCESSORS_CONF		_SC_NPROCESSORS_CONF
    _SC_NPROCESSORS_ONLN,
#define _SC_NPROCESSORS_ONLN		_SC_NPROCESSORS_ONLN
    _SC_PHYS_PAGES,
#define _SC_PHYS_PAGES			_SC_PHYS_PAGES
    _SC_AVPHYS_PAGES,
#define _SC_AVPHYS_PAGES		_SC_AVPHYS_PAGES
    _SC_ATEXIT_MAX,
#define _SC_ATEXIT_MAX			_SC_ATEXIT_MAX
    _SC_PASS_MAX,
#define _SC_PASS_MAX			_SC_PASS_MAX

    _SC_XOPEN_VERSION,
#define _SC_XOPEN_VERSION		_SC_XOPEN_VERSION
    _SC_XOPEN_XCU_VERSION,
#define _SC_XOPEN_XCU_VERSION		_SC_XOPEN_XCU_VERSION
    _SC_XOPEN_UNIX,
#define _SC_XOPEN_UNIX			_SC_XOPEN_UNIX
    _SC_XOPEN_CRYPT,
#define _SC_XOPEN_CRYPT			_SC_XOPEN_CRYPT
    _SC_XOPEN_ENH_I18N,
#define _SC_XOPEN_ENH_I18N		_SC_XOPEN_ENH_I18N
    _SC_XOPEN_SHM,
#define _SC_XOPEN_SHM			_SC_XOPEN_SHM

    _SC_2_CHAR_TERM,
#define _SC_2_CHAR_TERM			_SC_2_CHAR_TERM
    _SC_2_C_VERSION,
#define _SC_2_C_VERSION			_SC_2_C_VERSION
    _SC_2_UPE,
#define _SC_2_UPE			_SC_2_UPE

    _SC_XOPEN_XPG2,
#define _SC_XOPEN_XPG2			_SC_XOPEN_XPG2
    _SC_XOPEN_XPG3,
#define _SC_XOPEN_XPG3			_SC_XOPEN_XPG3
    _SC_XOPEN_XPG4,
#define _SC_XOPEN_XPG4			_SC_XOPEN_XPG4

    _SC_CHAR_BIT,
#define	_SC_CHAR_BIT			_SC_CHAR_BIT
    _SC_CHAR_MAX,
#define	_SC_CHAR_MAX			_SC_CHAR_MAX
    _SC_CHAR_MIN,
#define	_SC_CHAR_MIN			_SC_CHAR_MIN
    _SC_INT_MAX,
#define	_SC_INT_MAX			_SC_INT_MAX
    _SC_INT_MIN,
#define	_SC_INT_MIN			_SC_INT_MIN
    _SC_LONG_BIT,
#define	_SC_LONG_BIT			_SC_LONG_BIT
    _SC_WORD_BIT,
#define	_SC_WORD_BIT			_SC_WORD_BIT
    _SC_MB_LEN_MAX,
#define	_SC_MB_LEN_MAX			_SC_MB_LEN_MAX
    _SC_NZERO,
#define	_SC_NZERO			_SC_NZERO
    _SC_SSIZE_MAX,
#define	_SC_SSIZE_MAX			_SC_SSIZE_MAX
    _SC_SCHAR_MAX,
#define	_SC_SCHAR_MAX			_SC_SCHAR_MAX
    _SC_SCHAR_MIN,
#define	_SC_SCHAR_MIN			_SC_SCHAR_MIN
    _SC_SHRT_MAX,
#define	_SC_SHRT_MAX			_SC_SHRT_MAX
    _SC_SHRT_MIN,
#define	_SC_SHRT_MIN			_SC_SHRT_MIN
    _SC_UCHAR_MAX,
#define	_SC_UCHAR_MAX			_SC_UCHAR_MAX
    _SC_UINT_MAX,
#define	_SC_UINT_MAX			_SC_UINT_MAX
    _SC_ULONG_MAX,
#define	_SC_ULONG_MAX			_SC_ULONG_MAX
    _SC_USHRT_MAX,
#define	_SC_USHRT_MAX			_SC_USHRT_MAX

    _SC_NL_ARGMAX,
#define	_SC_NL_ARGMAX			_SC_NL_ARGMAX
    _SC_NL_LANGMAX,
#define	_SC_NL_LANGMAX			_SC_NL_LANGMAX
    _SC_NL_MSGMAX,
#define	_SC_NL_MSGMAX			_SC_NL_MSGMAX
    _SC_NL_NMAX,
#define	_SC_NL_NMAX			_SC_NL_NMAX
    _SC_NL_SETMAX,
#define	_SC_NL_SETMAX			_SC_NL_SETMAX
    _SC_NL_TEXTMAX,
#define	_SC_NL_TEXTMAX			_SC_NL_TEXTMAX

    _SC_XBS5_ILP32_OFF32,
#define _SC_XBS5_ILP32_OFF32		_SC_XBS5_ILP32_OFF32
    _SC_XBS5_ILP32_OFFBIG,
#define _SC_XBS5_ILP32_OFFBIG		_SC_XBS5_ILP32_OFFBIG
    _SC_XBS5_LP64_OFF64,
#define _SC_XBS5_LP64_OFF64		_SC_XBS5_LP64_OFF64
    _SC_XBS5_LPBIG_OFFBIG,
#define _SC_XBS5_LPBIG_OFFBIG		_SC_XBS5_LPBIG_OFFBIG

    _SC_XOPEN_LEGACY,
#define _SC_XOPEN_LEGACY		_SC_XOPEN_LEGACY
    _SC_XOPEN_REALTIME,
#define _SC_XOPEN_REALTIME		_SC_XOPEN_REALTIME
    _SC_XOPEN_REALTIME_THREADS,
#define _SC_XOPEN_REALTIME_THREADS	_SC_XOPEN_REALTIME_THREADS

    _SC_ADVISORY_INFO,
#define _SC_ADVISORY_INFO		_SC_ADVISORY_INFO
    _SC_BARRIERS,
#define _SC_BARRIERS			_SC_BARRIERS
    _SC_BASE,
#define _SC_BASE			_SC_BASE
    _SC_C_LANG_SUPPORT,
#define _SC_C_LANG_SUPPORT		_SC_C_LANG_SUPPORT
    _SC_C_LANG_SUPPORT_R,
#define _SC_C_LANG_SUPPORT_R		_SC_C_LANG_SUPPORT_R
    _SC_CLOCK_SELECTION,
#define _SC_CLOCK_SELECTION		_SC_CLOCK_SELECTION
    _SC_CPUTIME,
#define _SC_CPUTIME			_SC_CPUTIME
    _SC_THREAD_CPUTIME,
#define _SC_THREAD_CPUTIME		_SC_THREAD_CPUTIME
    _SC_DEVICE_IO,
#define _SC_DEVICE_IO			_SC_DEVICE_IO
    _SC_DEVICE_SPECIFIC,
#define _SC_DEVICE_SPECIFIC		_SC_DEVICE_SPECIFIC
    _SC_DEVICE_SPECIFIC_R,
#define _SC_DEVICE_SPECIFIC_R		_SC_DEVICE_SPECIFIC_R
    _SC_FD_MGMT,
#define _SC_FD_MGMT			_SC_FD_MGMT
    _SC_FIFO,
#define _SC_FIFO			_SC_FIFO
    _SC_PIPE,
#define _SC_PIPE			_SC_PIPE
    _SC_FILE_ATTRIBUTES,
#define _SC_FILE_ATTRIBUTES		_SC_FILE_ATTRIBUTES
    _SC_FILE_LOCKING,
#define _SC_FILE_LOCKING		_SC_FILE_LOCKING
    _SC_FILE_SYSTEM,
#define _SC_FILE_SYSTEM			_SC_FILE_SYSTEM
    _SC_MONOTONIC_CLOCK,
#define _SC_MONOTONIC_CLOCK		_SC_MONOTONIC_CLOCK
    _SC_MULTI_PROCESS,
#define _SC_MULTI_PROCESS		_SC_MULTI_PROCESS
    _SC_SINGLE_PROCESS,
#define _SC_SINGLE_PROCESS		_SC_SINGLE_PROCESS
    _SC_NETWORKING,
#define _SC_NETWORKING			_SC_NETWORKING
    _SC_READER_WRITER_LOCKS,
#define _SC_READER_WRITER_LOCKS		_SC_READER_WRITER_LOCKS
    _SC_SPIN_LOCKS,
#define _SC_SPIN_LOCKS			_SC_SPIN_LOCKS
    _SC_REGEXP,
#define _SC_REGEXP			_SC_REGEXP
    _SC_REGEX_VERSION,
#define _SC_REGEX_VERSION		_SC_REGEX_VERSION
    _SC_SHELL,
#define _SC_SHELL			_SC_SHELL
    _SC_SIGNALS,
#define _SC_SIGNALS			_SC_SIGNALS
    _SC_SPAWN,
#define _SC_SPAWN			_SC_SPAWN
    _SC_SPORADIC_SERVER,
#define _SC_SPORADIC_SERVER		_SC_SPORADIC_SERVER
    _SC_THREAD_SPORADIC_SERVER,
#define _SC_THREAD_SPORADIC_SERVER	_SC_THREAD_SPORADIC_SERVER
    _SC_SYSTEM_DATABASE,
#define _SC_SYSTEM_DATABASE		_SC_SYSTEM_DATABASE
    _SC_SYSTEM_DATABASE_R,
#define _SC_SYSTEM_DATABASE_R		_SC_SYSTEM_DATABASE_R
    _SC_TIMEOUTS,
#define _SC_TIMEOUTS			_SC_TIMEOUTS
    _SC_TYPED_MEMORY_OBJECTS,
#define _SC_TYPED_MEMORY_OBJECTS	_SC_TYPED_MEMORY_OBJECTS
    _SC_USER_GROUPS,
#define _SC_USER_GROUPS			_SC_USER_GROUPS
    _SC_USER_GROUPS_R,
#define _SC_USER_GROUPS_R		_SC_USER_GROUPS_R
    _SC_2_PBS,
#define _SC_2_PBS			_SC_2_PBS
    _SC_2_PBS_ACCOUNTING,
#define _SC_2_PBS_ACCOUNTING		_SC_2_PBS_ACCOUNTING
    _SC_2_PBS_LOCATE,
#define _SC_2_PBS_LOCATE		_SC_2_PBS_LOCATE
    _SC_2_PBS_MESSAGE,
#define _SC_2_PBS_MESSAGE		_SC_2_PBS_MESSAGE
    _SC_2_PBS_TRACK,
#define _SC_2_PBS_TRACK			_SC_2_PBS_TRACK
    _SC_SYMLOOP_MAX,
#define _SC_SYMLOOP_MAX			_SC_SYMLOOP_MAX
    _SC_STREAMS,
#define _SC_STREAMS			_SC_STREAMS
    _SC_2_PBS_CHECKPOINT,
#define _SC_2_PBS_CHECKPOINT		_SC_2_PBS_CHECKPOINT

    _SC_V6_ILP32_OFF32,
#define _SC_V6_ILP32_OFF32		_SC_V6_ILP32_OFF32
    _SC_V6_ILP32_OFFBIG,
#define _SC_V6_ILP32_OFFBIG		_SC_V6_ILP32_OFFBIG
    _SC_V6_LP64_OFF64,
#define _SC_V6_LP64_OFF64		_SC_V6_LP64_OFF64
    _SC_V6_LPBIG_OFFBIG,
#define _SC_V6_LPBIG_OFFBIG		_SC_V6_LPBIG_OFFBIG

    _SC_HOST_NAME_MAX,
#define _SC_HOST_NAME_MAX		_SC_HOST_NAME_MAX
    _SC_TRACE,
#define _SC_TRACE			_SC_TRACE
    _SC_TRACE_EVENT_FILTER,
#define _SC_TRACE_EVENT_FILTER		_SC_TRACE_EVENT_FILTER
    _SC_TRACE_INHERIT,
#define _SC_TRACE_INHERIT		_SC_TRACE_INHERIT
    _SC_TRACE_LOG,
#define _SC_TRACE_LOG			_SC_TRACE_LOG

    _SC_LEVEL1_ICACHE_SIZE,
#define _SC_LEVEL1_ICACHE_SIZE		_SC_LEVEL1_ICACHE_SIZE
    _SC_LEVEL1_ICACHE_ASSOC,
#define _SC_LEVEL1_ICACHE_ASSOC		_SC_LEVEL1_ICACHE_ASSOC
    _SC_LEVEL1_ICACHE_LINESIZE,
#define _SC_LEVEL1_ICACHE_LINESIZE	_SC_LEVEL1_ICACHE_LINESIZE
    _SC_LEVEL1_DCACHE_SIZE,
#define _SC_LEVEL1_DCACHE_SIZE		_SC_LEVEL1_DCACHE_SIZE
    _SC_LEVEL1_DCACHE_ASSOC,
#define _SC_LEVEL1_DCACHE_ASSOC		_SC_LEVEL1_DCACHE_ASSOC
    _SC_LEVEL1_DCACHE_LINESIZE,
#define _SC_LEVEL1_DCACHE_LINESIZE	_SC_LEVEL1_DCACHE_LINESIZE
    _SC_LEVEL2_CACHE_SIZE,
#define _SC_LEVEL2_CACHE_SIZE		_SC_LEVEL2_CACHE_SIZE
    _SC_LEVEL2_CACHE_ASSOC,
#define _SC_LEVEL2_CACHE_ASSOC		_SC_LEVEL2_CACHE_ASSOC
    _SC_LEVEL2_CACHE_LINESIZE,
#define _SC_LEVEL2_CACHE_LINESIZE	_SC_LEVEL2_CACHE_LINESIZE
    _SC_LEVEL3_CACHE_SIZE,
#define _SC_LEVEL3_CACHE_SIZE		_SC_LEVEL3_CACHE_SIZE
    _SC_LEVEL3_CACHE_ASSOC,
#define _SC_LEVEL3_CACHE_ASSOC		_SC_LEVEL3_CACHE_ASSOC
    _SC_LEVEL3_CACHE_LINESIZE,
#define _SC_LEVEL3_CACHE_LINESIZE	_SC_LEVEL3_CACHE_LINESIZE
    _SC_LEVEL4_CACHE_SIZE,
#define _SC_LEVEL4_CACHE_SIZE		_SC_LEVEL4_CACHE_SIZE
    _SC_LEVEL4_CACHE_ASSOC,
#define _SC_LEVEL4_CACHE_ASSOC		_SC_LEVEL4_CACHE_ASSOC
    _SC_LEVEL4_CACHE_LINESIZE,
#define _SC_LEVEL4_CACHE_LINESIZE	_SC_LEVEL4_CACHE_LINESIZE
    /* Leave room here, maybe we need a few more cache levels some day.  */

    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE  + 50,
#define _SC_IPV6			_SC_IPV6
    _SC_RAW_SOCKETS,
#define _SC_RAW_SOCKETS			_SC_RAW_SOCKETS

    _SC_V7_ILP32_OFF32,
#define _SC_V7_ILP32_OFF32		_SC_V7_ILP32_OFF32
    _SC_V7_ILP32_OFFBIG,
#define _SC_V7_ILP32_OFFBIG		_SC_V7_ILP32_OFFBIG
    _SC_V7_LP64_OFF64,
#define _SC_V7_LP64_OFF64		_SC_V7_LP64_OFF64
    _SC_V7_LPBIG_OFFBIG,
#define _SC_V7_LPBIG_OFFBIG		_SC_V7_LPBIG_OFFBIG

    _SC_SS_REPL_MAX,
#define _SC_SS_REPL_MAX			_SC_SS_REPL_MAX

    _SC_TRACE_EVENT_NAME_MAX,
#define _SC_TRACE_EVENT_NAME_MAX	_SC_TRACE_EVENT_NAME_MAX
    _SC_TRACE_NAME_MAX,
#define _SC_TRACE_NAME_MAX		_SC_TRACE_NAME_MAX
    _SC_TRACE_SYS_MAX,
#define _SC_TRACE_SYS_MAX		_SC_TRACE_SYS_MAX
    _SC_TRACE_USER_EVENT_MAX,
#define _SC_TRACE_USER_EVENT_MAX	_SC_TRACE_USER_EVENT_MAX

    _SC_XOPEN_STREAMS,
#define _SC_XOPEN_STREAMS		_SC_XOPEN_STREAMS

    _SC_THREAD_ROBUST_PRIO_INHERIT,
#define _SC_THREAD_ROBUST_PRIO_INHERIT	_SC_THREAD_ROBUST_PRIO_INHERIT
    _SC_THREAD_ROBUST_PRIO_PROTECT
#define _SC_THREAD_ROBUST_PRIO_PROTECT	_SC_THREAD_ROBUST_PRIO_PROTECT
  };

/* Values for the NAME argument to `confstr'.  */
enum
  {
    _CS_PATH,			/* The default search path.  */
#define _CS_PATH		_CS_PATH

    _CS_V6_WIDTH_RESTRICTED_ENVS,
#define _CS_V6_WIDTH_RESTRICTED_ENVS	_CS_V6_WIDTH_RESTRICTED_ENVS
#define _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS	_CS_V6_WIDTH_RESTRICTED_ENVS

    _CS_GNU_LIBC_VERSION,
#define _CS_GNU_LIBC_VERSION	_CS_GNU_LIBC_VERSION
    _CS_GNU_LIBPTHREAD_VERSION,
#define _CS_GNU_LIBPTHREAD_VERSION	_CS_GNU_LIBPTHREAD_VERSION

    _CS_V5_WIDTH_RESTRICTED_ENVS,
#define _CS_V5_WIDTH_RESTRICTED_ENVS	_CS_V5_WIDTH_RESTRICTED_ENVS
#define _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS	_CS_V5_WIDTH_RESTRICTED_ENVS

    _CS_V7_WIDTH_RESTRICTED_ENVS,
#define _CS_V7_WIDTH_RESTRICTED_ENVS	_CS_V7_WIDTH_RESTRICTED_ENVS
#define _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS	_CS_V7_WIDTH_RESTRICTED_ENVS

    _CS_LFS_CFLAGS = 1000,
#define _CS_LFS_CFLAGS	_CS_LFS_CFLAGS
    _CS_LFS_LDFLAGS,
#define _CS_LFS_LDFLAGS	_CS_LFS_LDFLAGS
    _CS_LFS_LIBS,
#define _CS_LFS_LIBS		_CS_LFS_LIBS
    _CS_LFS_LINTFLAGS,
#define _CS_LFS_LINTFLAGS	_CS_LFS_LINTFLAGS
    _CS_LFS64_CFLAGS,
#define _CS_LFS64_CFLAGS	_CS_LFS64_CFLAGS
    _CS_LFS64_LDFLAGS,
#define _CS_LFS64_LDFLAGS	_CS_LFS64_LDFLAGS
    _CS_LFS64_LIBS,
#define _CS_LFS64_LIBS	_CS_LFS64_LIBS
    _CS_LFS64_LINTFLAGS,
#define _CS_LFS64_LINTFLAGS	_CS_LFS64_LINTFLAGS

    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
#define _CS_XBS5_ILP32_OFF32_CFLAGS _CS_XBS5_ILP32_OFF32_CFLAGS
    _CS_XBS5_ILP32_OFF32_LDFLAGS,
#define _CS_XBS5_ILP32_OFF32_LDFLAGS _CS_XBS5_ILP32_OFF32_LDFLAGS
    _CS_XBS5_ILP32_OFF32_LIBS,
#define _CS_XBS5_ILP32_OFF32_LIBS _CS_XBS5_ILP32_OFF32_LIBS
    _CS_XBS5_ILP32_OFF32_LINTFLAGS,
#define _CS_XBS5_ILP32_OFF32_LINTFLAGS _CS_XBS5_ILP32_OFF32_LINTFLAGS
    _CS_XBS5_ILP32_OFFBIG_CFLAGS,
#define _CS_XBS5_ILP32_OFFBIG_CFLAGS _CS_XBS5_ILP32_OFFBIG_CFLAGS
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,
#define _CS_XBS5_ILP32_OFFBIG_LDFLAGS _CS_XBS5_ILP32_OFFBIG_LDFLAGS
    _CS_XBS5_ILP32_OFFBIG_LIBS,
#define _CS_XBS5_ILP32_OFFBIG_LIBS _CS_XBS5_ILP32_OFFBIG_LIBS
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,
#define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS _CS_XBS5_ILP32_OFFBIG_LINTFLAGS
    _CS_XBS5_LP64_OFF64_CFLAGS,
#define _CS_XBS5_LP64_OFF64_CFLAGS _CS_XBS5_LP64_OFF64_CFLAGS
    _CS_XBS5_LP64_OFF64_LDFLAGS,
#define _CS_XBS5_LP64_OFF64_LDFLAGS _CS_XBS5_LP64_OFF64_LDFLAGS
    _CS_XBS5_LP64_OFF64_LIBS,
#define _CS_XBS5_LP64_OFF64_LIBS _CS_XBS5_LP64_OFF64_LIBS
    _CS_XBS5_LP64_OFF64_LINTFLAGS,
#define _CS_XBS5_LP64_OFF64_LINTFLAGS _CS_XBS5_LP64_OFF64_LINTFLAGS
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,
#define _CS_XBS5_LPBIG_OFFBIG_CFLAGS _CS_XBS5_LPBIG_OFFBIG_CFLAGS
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,
#define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS _CS_XBS5_LPBIG_OFFBIG_LDFLAGS
    _CS_XBS5_LPBIG_OFFBIG_LIBS,
#define _CS_XBS5_LPBIG_OFFBIG_LIBS _CS_XBS5_LPBIG_OFFBIG_LIBS
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,
#define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS

    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,
#define _CS_POSIX_V6_ILP32_OFF32_CFLAGS _CS_POSIX_V6_ILP32_OFF32_CFLAGS
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,
#define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS _CS_POSIX_V6_ILP32_OFF32_LDFLAGS
    _CS_POSIX_V6_ILP32_OFF32_LIBS,
#define _CS_POSIX_V6_ILP32_OFF32_LIBS _CS_POSIX_V6_ILP32_OFF32_LIBS
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,
#define _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,
#define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,
#define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,
#define _CS_POSIX_V6_ILP32_OFFBIG_LIBS _CS_POSIX_V6_ILP32_OFFBIG_LIBS
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,
#define _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS
    _CS_POSIX_V6_LP64_OFF64_CFLAGS,
#define _CS_POSIX_V6_LP64_OFF64_CFLAGS _CS_POSIX_V6_LP64_OFF64_CFLAGS
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,
#define _CS_POSIX_V6_LP64_OFF64_LDFLAGS _CS_POSIX_V6_LP64_OFF64_LDFLAGS
    _CS_POSIX_V6_LP64_OFF64_LIBS,
#define _CS_POSIX_V6_LP64_OFF64_LIBS _CS_POSIX_V6_LP64_OFF64_LIBS
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,
#define _CS_POSIX_V6_LP64_OFF64_LINTFLAGS _CS_POSIX_V6_LP64_OFF64_LINTFLAGS
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,
#define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,
#define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,
#define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS _CS_POSIX_V6_LPBIG_OFFBIG_LIBS
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,
#define _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS

    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,
#define _CS_POSIX_V7_ILP32_OFF32_CFLAGS _CS_POSIX_V7_ILP32_OFF32_CFLAGS
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,
#define _CS_POSIX_V7_ILP32_OFF32_LDFLAGS _CS_POSIX_V7_ILP32_OFF32_LDFLAGS
    _CS_POSIX_V7_ILP32_OFF32_LIBS,
#define _CS_POSIX_V7_ILP32_OFF32_LIBS _CS_POSIX_V7_ILP32_OFF32_LIBS
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,
#define _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,
#define _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,
#define _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,
#define _CS_POSIX_V7_ILP32_OFFBIG_LIBS _CS_POSIX_V7_ILP32_OFFBIG_LIBS
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,
#define _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS
    _CS_POSIX_V7_LP64_OFF64_CFLAGS,
#define _CS_POSIX_V7_LP64_OFF64_CFLAGS _CS_POSIX_V7_LP64_OFF64_CFLAGS
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,
#define _CS_POSIX_V7_LP64_OFF64_LDFLAGS _CS_POSIX_V7_LP64_OFF64_LDFLAGS
    _CS_POSIX_V7_LP64_OFF64_LIBS,
#define _CS_POSIX_V7_LP64_OFF64_LIBS _CS_POSIX_V7_LP64_OFF64_LIBS
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,
#define _CS_POSIX_V7_LP64_OFF64_LINTFLAGS _CS_POSIX_V7_LP64_OFF64_LINTFLAGS
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,
#define _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,
#define _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,
#define _CS_POSIX_V7_LPBIG_OFFBIG_LIBS _CS_POSIX_V7_LPBIG_OFFBIG_LIBS
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,
#define _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS

    _CS_V6_ENV,
#define _CS_V6_ENV			_CS_V6_ENV
    _CS_V7_ENV
#define _CS_V7_ENV			_CS_V7_ENV
  };
# 610 "/usr/include/unistd.h" 2 3


/* Get file-specific configuration information about PATH.  */
extern long int pathconf (__const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;

/* Get file-specific configuration about descriptor FD.  */
extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Get the value of the system variable NAME.  */
extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__ )) ;


/* Get the value of the string-valued system variable NAME.  */
extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__ )) ;



/* Get the process ID of the calling process.  */
extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Get the process ID of the calling process's parent.  */
extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Get the process group ID of the calling process.
   This function is different on old BSD. */

extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__ )) ;








/* Get the process group ID of process PID.  */
extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__ )) ;

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__ )) ;



/* Set the process group ID of the process matching PID to PGID.
   If PID is zero, the current process's process group ID is set.
   If PGID is zero, the process ID of the process is used.  */
extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__ )) ;


/* Both System V and BSD have `setpgrp' functions, but with different
   calling conventions.  The BSD function is the same as POSIX.1 `setpgid'
   (above).  The System V function takes no arguments and puts the calling
   process in its on group like `setpgid (0, 0)'.

   New programs should always use `setpgid' instead.

   The default in GNU is to provide the System V function.  The BSD
   function is available under -D_BSD_SOURCE.  */



/* Set the process group ID of the calling process to its own PID.
   This is exactly the same as `setpgid (0, 0)'.  */
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Favor BSD.  */
# 684 "/usr/include/unistd.h" 3

/* Use SVID or BSD.  */

/* Create a new session with the calling process as its leader.
   The process group IDs of the session and the calling process
   are set to the process ID of the calling process, which is returned.  */
extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__ )) ;


/* Return the session ID of the given process.  */
extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__ )) ;


/* Get the real user ID of the calling process.  */
extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Get the effective user ID of the calling process.  */
extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Get the real group ID of the calling process.  */
extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Get the effective group ID of the calling process.  */
extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* If SIZE is zero, return the number of supplementary groups
   the calling process is in.  Otherwise, fill in the group IDs
   of its supplementary groups in LIST and return the number written.  */
extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__ ))   ;






/* Set the user ID of the calling process to UID.
   If the calling process is the super-user, set the real
   and effective user IDs, and the saved set-user-ID to UID;
   if not, the effective user ID is set to UID.  */
extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__ )) ;


/* Set the real user ID of the calling process to RUID,
   and the effective user ID of the calling process to EUID.  */
extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__ )) ;



/* Set the effective user ID of the calling process to UID.  */
extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__ )) ;
/* Use BSD.  */

/* Set the group ID of the calling process to GID.
   If the calling process is the super-user, set the real
   and effective group IDs, and the saved set-group-ID to GID;
   if not, the effective group ID is set to GID.  */
extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__ )) ;


/* Set the real group ID of the calling process to RGID,
   and the effective group ID of the calling process to EGID.  */
extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__ )) ;



/* Set the effective group ID of the calling process to GID.  */
extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__ )) ;
/* Use BSD.  */

# 773 "/usr/include/unistd.h" 3



/* Clone the calling process, creating an exact copy.
   Return -1 for errors, 0 to the new process,
   and the process ID of the new process to the old process.  */
extern __pid_t fork (void) __attribute__ ((__nothrow__)) ;



/* Clone the calling process, but without copying the whole address space.
   The calling process is suspended until the new process exits or is
   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
   and the process ID of the new process to the old process.  */
extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__ )) ;
/* Use BSD or XPG < 7. */


/* Return the pathname of the terminal FD is open on, or NULL on errors.
   The returned storage is good only until the next call to this function.  */
extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Store at most BUFLEN characters of the pathname of the terminal FD is
   open on in BUF.  Return 0 on success, otherwise an error number.  */
extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (2) ))   ;

/* Return 1 if FD is a valid descriptor associated
   with a terminal, zero if not.  */
extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__ )) ;



/* Return the index into the active-logins file (utmp) for
   the controlling terminal.  */
extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__ )) ;



/* Make a link to FROM named TO.  */
extern int link (__const char *__from, __const char *__to)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) ))   ;


/* Like link but relative paths in TO and FROM are interpreted relative
   to FROMFD and TOFD respectively.  */
extern int linkat (int __fromfd, __const char *__from, int __tofd,
		   __const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (2, 4) ))   ;



/* Make a symbolic link to FROM named TO.  */
extern int symlink (__const char *__from, __const char *__to)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) ))   ;

/* Read the contents of the symbolic link PATH into no more than
   LEN bytes of BUF.  The contents are not null-terminated.
   Returns the number of characters read, or -1 for errors.  */
extern ssize_t readlink (__const char *__restrict __path,
			 char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 2) ))   ;
/* Use BSD.  */


/* Like symlink but a relative path in TO is interpreted relative to TOFD.  */
extern int symlinkat (__const char *__from, int __tofd,
		      __const char *__to) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1, 3) ))   ;

/* Like readlink but a relative PATH is interpreted relative to FD.  */
extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
			   char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (2, 3) ))   ;


/* Remove the link NAME.  */
extern int unlink (__const char *__name) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;


/* Remove the link NAME relative to FD.  */
extern int unlinkat (int __fd, __const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (2) )) ;


/* Remove the directory PATH.  */
extern int rmdir (__const char *__path) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;


/* Return the foreground process group ID of FD.  */
extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Set the foreground process group ID of FD set PGRP_ID.  */
extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__ )) ;


/* Return the login name of the user.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern char *getlogin (void);

/* Return at most NAME_LEN characters of the login name of the user in NAME.
   If it cannot be determined or some other error occurred, return the error
   code.  Otherwise return 0.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__  (1) )) ;



/* Set the login name returned by `getlogin'.  */
extern int setlogin (__const char *__name) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;




/* Get definitions and prototypes for functions to process the
   arguments in ARGV (ARGC of them, minus the program name) for
   options given in OPTS.  */
#define __need_getopt
#include <getopt.h>
# 1 "/usr/include/getopt.h" 1 3
/* Declarations for getopt.
   Copyright (C) 1989-1994,1996-1999,2001,2003,2004,2009,2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */







/* If __GNU_LIBRARY__ is not already defined, either we are being used
   standalone, or this is the first header included in the source file.
   If we are being used with glibc, we need to include <features.h>, but
   that does not exist if we are standalone.  So: if __GNU_LIBRARY__ is
   not defined, include <ctype.h>, which will pull in <features.h> for us
   if it's from glibc.  (Why ctype.h?  It's guaranteed to exist and it
   doesn't flood the namespace with stuff the way some other headers do.)  */




# 47 "/usr/include/getopt.h" 3






/* For communication from `getopt' to the caller.
   When `getopt' finds an option that takes an argument,
   the argument value is returned here.
   Also, when `ordering' is RETURN_IN_ORDER,
   each non-option ARGV-element is returned here.  */

extern char *optarg;

/* Index in ARGV of the next element to be scanned.
   This is used for communication to and from the caller
   and for communication between successive calls to `getopt'.

   On entry to `getopt', zero means this is the first call; initialize.

   When `getopt' returns -1, this is the index of the first of the
   non-option elements that the caller should itself scan.

   Otherwise, `optind' communicates from one call to the next
   how much of ARGV has been scanned so far.  */

extern int optind;

/* Callers store zero here to inhibit the error message `getopt' prints
   for unrecognized options.  */

extern int opterr;

/* Set to an option character which was unrecognized.  */

extern int optopt;

/* need getopt */
# 121 "/usr/include/getopt.h" 3



/* Get definitions and prototypes for functions to process the
   arguments in ARGV (ARGC of them, minus the program name) for
   options given in OPTS.

   Return the option character from OPTS just read.  Return -1 when
   there are no more options.  For unrecognized options, or options
   missing arguments, `optopt' is set to the option letter, and '?' is
   returned.

   The OPTS string is a list of characters which are recognized option
   letters, optionally followed by colons, specifying that that letter
   takes an argument, to be placed in `optarg'.

   If a letter in OPTS is followed by two colons, its argument is
   optional.  This behavior is specific to the GNU `getopt'.

   The argument `--' causes premature termination of argument
   scanning, explicitly telling `getopt' that there are no more
   options.

   If OPTS begins with `--', then non-option arguments are treated as
   arguments to the option '\0'.  This behavior is specific to the GNU
   `getopt'.  */


/* Many other libraries have conflicting prototypes for getopt, with
   differences in the consts, in stdlib.h.  To avoid compilation
   errors, only prototype getopt for the GNU C library.  */
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__ )) ;

# 169 "/usr/include/getopt.h" 3

/* not __GNU_LIBRARY__ *//* __GNU_LIBRARY__ */



# 184 "/usr/include/getopt.h" 3






/* Make sure we later can get all the definitions and declarations.  */
#undef __need_getopt

/* getopt.h */
# 894 "/usr/include/unistd.h" 2 3





/* Put the name of the current host in no more than LEN bytes of NAME.
   The result is null-terminated if LEN is large enough for the full
   name and the terminator.  */
extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;




/* Set the name of the current host to NAME, which is LEN bytes long.
   This call is restricted to the super-user.  */
extern int sethostname (__const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;

/* Set the current machine's Internet number to ID.
   This call is restricted to the super-user.  */
extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__ ))   ;


/* Get and set the NIS (aka YP) domain name, if any.
   Called just like `gethostname' and `sethostname'.
   The NIS domain name is usually the empty string when not using NIS.  */
extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;
extern int setdomainname (__const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;


/* Revoke access permissions to all processes currently communicating
   with the control terminal, and then send a SIGHUP signal to the process
   group of the control terminal.  */
extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Revoke the access of all descriptors currently open on FILE.  */
extern int revoke (__const char *__file) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;


/* Enable statistical profiling, writing samples of the PC into at most
   SIZE bytes of SAMPLE_BUFFER; every processor clock tick while profiling
   is enabled, the system examines the user PC and increments
   SAMPLE_BUFFER[((PC - OFFSET) / 2) * SCALE / 65536].  If SCALE is zero,
   disable profiling.  Returns zero on success, -1 on error.  */
extern int profil (unsigned short int *__sample_buffer, size_t __size,
		   size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) )) ;


/* Turn accounting on if NAME is an existing file.  The system will then write
   a record for each process as it terminates, to this file.  If NAME is NULL,
   turn accounting off.  This call is restricted to the super-user.  */
extern int acct (__const char *__name) __attribute__ ((__nothrow__ , __leaf__ )) ;


/* Successive calls return the shells listed in `/etc/shells'.  */
extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__ )) ;
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__ )) ; /* Discard cached info.  */
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__ )) ; /* Rewind and re-read the file.  */


/* Put the program in the background, and dissociate from the controlling
   terminal.  If NOCHDIR is zero, do `chdir ("/")'.  If NOCLOSE is zero,
   redirects stdin, stdout, and stderr to /dev/null.  */
extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__ ))   ;
/* Use BSD || X/Open.  */



/* Make PATH be the root directory (the starting point for absolute paths).
   This call is restricted to the super-user.  */
extern int chroot (__const char *__path) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;

/* Prompt with PROMPT and read a string from the terminal without echoing.
   Uses /dev/tty if possible; otherwise stderr and stdin.  */
extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__  (1) )) ;
/* Use BSD || X/Open.  */



/* Make all changes done to FD actually appear on disk.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int fsync (int __fd);
/* Use BSD || X/Open || Unix98.  */











/* Return identifier for the current host.  */
extern long int gethostid (void);

/* Make all changes done to all files actually appear on disk.  */
extern void sync (void) __attribute__ ((__nothrow__ , __leaf__ )) ;



/* Return the number of bytes in a page.  This is the system's page size,
   which is not necessarily the same as the hardware page size.  */
extern int getpagesize (void)  __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__const__));


/* Return the maximum number of file descriptors
   the current process could possibly have.  */
extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__ )) ;


/* Use BSD || X/Open Unix.  */




/* Truncate FILE to LENGTH bytes.  */

extern int truncate (__const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__nonnull__  (1) ))   ;
# 1028 "/usr/include/unistd.h" 3






/* Use BSD || X/Open Unix || POSIX 2008.  */



/* Truncate the file FD is open on to LENGTH bytes.  */

extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__ ))   ;












/* Use BSD || X/Open Unix || POSIX 2003.  */





/* Set the end of accessible data space (aka "the break") to ADDR.
   Returns zero on success and -1 for errors (with errno set).  */
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__ ))   ;

/* Increase or decrease the end of accessible data space by DELTA bytes.
   If successful, returns the address the previous end of data space
   (i.e. the beginning of the new space, if DELTA > 0);
   returns (void *) -1 for errors (with errno set).  */
extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__ )) ;




/* Invoke `system call' number SYSNO, passing it the remaining arguments.
   This is completely system-dependent, and not often useful.

   In Unix, `syscall' sets `errno' for all errors and most calls return -1
   for errors; in many systems you cannot pass arguments or get return
   values for all system calls (`pipe', `fork', and `getppid' typically
   among them).

   In Mach, all system calls take normal arguments and always return an
   error code (zero for success).  */
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__ )) ;

/* Use misc.  */



/* NOTE: These declarations also appear in <fcntl.h>; be sure to keep both
   files consistent.  Some systems have them there and some here, and some
   software depends on the macros being defined without including both.  */

/* `lockf' is a simpler interface to the locking facilities of `fcntl'.
   LEN is always relative to the current file position.
   The CMD argument is one of the following.

   This function is a cancellation point and therefore not marked with
   __THROW.  */

#define F_ULOCK 0	/* Unlock a previously locked region.  */
#define F_LOCK  1	/* Lock a region for exclusive use.  */
#define F_TLOCK 2	/* Test and lock a region for exclusive use.  */
#define F_TEST  3	/* Test a region for other processes locks.  */


extern int lockf (int __fd, int __cmd, __off_t __len)  ;











/* Use misc and F_LOCK not already defined.  */


# 1131 "/usr/include/unistd.h" 3



/* Synchronize at least the data part of a file with the underlying
   media.  */
extern int fdatasync (int __fildes);
/* Use POSIX199309 */


/* XPG4.2 specifies that prototypes for the encryption functions must
   be defined here.  */
# 1158 "/usr/include/unistd.h" 3



/* The Single Unix specification demands this prototype to be here.
   It is also found in <stdio.h>.  */

/* Return the name of the controlling terminal.  */
extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__ )) ;



/* Define some macros helping to catch buffer overflows.  */




 

/* unistd.h  */
# 34 "local.h" 2




extern int strcasecmp( const char *,
                       const char * );






/* __VMS */
# 60 "local.h"



/********* End of Configurable stuff ***********/

/* FL_PATH_MAX */








#define FL_FLEN           256


/* There are two ways to handle motion events, one is to constantly
 * query the server for mouse position, and the other is to use
 * motion events. The first way obviously is slow and expensive
 * if runs across network. The latter however suffers with stepping
 * events.
 */

/*#define NO_MSG_INFO */

/* ifndef local.h } */


/*
 * Local variables:
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
# 35 "flinternal.h" 2

#include "ulib.h"
# 1 "ulib.h" 1
/*
 *
 *  This file is part of the XForms library package.
 *
 * XForms is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1, or
 * (at your option) any later version.
 *
 * XForms is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with XForms. If not, see <http://www.gnu.org/licenses/>.
 */


/**
 * \file ulib.h
 *
 * Macros and Prototypes for the utilities routines
 */


#define TC_ULIB_H

#include <stdio.h>      /* for FILE */
#include <errno.h>
# 1 "/usr/include/errno.h" 1 3
/* Copyright (C) 1991,92,93,94,95,96,97,2002 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.5 Errors	<errno.h>
 */



/* The includer defined __need_Emath if he wants only the definitions
   of EDOM and ERANGE, and not everything else.  */

#define _ERRNO_H	1
#include <features.h>


 

/* Get the error number constants from the system-specific file.
   This file will test __need_Emath and _ERRNO_H.  */
#include <bits/errno.h>
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3
/* Error constants.  Linux specific version.
   Copyright (C) 1996-1999, 2005, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */



#undef EDOM
#undef EILSEQ
#undef ERANGE
#include <linux/errno.h>
# 1 "/usr/include/linux/errno.h" 1 3

#define _LINUX_ERRNO_H

#include <asm/errno.h>
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3
#include <asm-generic/errno.h>
# 1 "/usr/include/asm-generic/errno.h" 1 3

#define _ASM_GENERIC_ERRNO_H

#include <asm-generic/errno-base.h>
# 1 "/usr/include/asm-generic/errno-base.h" 1 3

#define _ASM_GENERIC_ERRNO_BASE_H

#define	EPERM		 1	/* Operation not permitted */
#define	ENOENT		 2	/* No such file or directory */
#define	ESRCH		 3	/* No such process */
#define	EINTR		 4	/* Interrupted system call */
#define	EIO		 5	/* I/O error */
#define	ENXIO		 6	/* No such device or address */
#define	E2BIG		 7	/* Argument list too long */
#define	ENOEXEC		 8	/* Exec format error */
#define	EBADF		 9	/* Bad file number */
#define	ECHILD		10	/* No child processes */
#define	EAGAIN		11	/* Try again */
#define	ENOMEM		12	/* Out of memory */
#define	EACCES		13	/* Permission denied */
#define	EFAULT		14	/* Bad address */
#define	ENOTBLK		15	/* Block device required */
#define	EBUSY		16	/* Device or resource busy */
#define	EEXIST		17	/* File exists */
#define	EXDEV		18	/* Cross-device link */
#define	ENODEV		19	/* No such device */
#define	ENOTDIR		20	/* Not a directory */
#define	EISDIR		21	/* Is a directory */
#define	EINVAL		22	/* Invalid argument */
#define	ENFILE		23	/* File table overflow */
#define	EMFILE		24	/* Too many open files */
#define	ENOTTY		25	/* Not a typewriter */
#define	ETXTBSY		26	/* Text file busy */
#define	EFBIG		27	/* File too large */
#define	ENOSPC		28	/* No space left on device */
#define	ESPIPE		29	/* Illegal seek */
#define	EROFS		30	/* Read-only file system */
#define	EMLINK		31	/* Too many links */
#define	EPIPE		32	/* Broken pipe */
#define	EDOM		33	/* Math argument out of domain of func */
#define	ERANGE		34	/* Math result not representable */


# 4 "/usr/include/asm-generic/errno.h" 2 3


#define	EDEADLK		35	/* Resource deadlock would occur */
#define	ENAMETOOLONG	36	/* File name too long */
#define	ENOLCK		37	/* No record locks available */
#define	ENOSYS		38	/* Function not implemented */
#define	ENOTEMPTY	39	/* Directory not empty */
#define	ELOOP		40	/* Too many symbolic links encountered */
#define	EWOULDBLOCK	EAGAIN	/* Operation would block */
#define	ENOMSG		42	/* No message of desired type */
#define	EIDRM		43	/* Identifier removed */
#define	ECHRNG		44	/* Channel number out of range */
#define	EL2NSYNC	45	/* Level 2 not synchronized */
#define	EL3HLT		46	/* Level 3 halted */
#define	EL3RST		47	/* Level 3 reset */
#define	ELNRNG		48	/* Link number out of range */
#define	EUNATCH		49	/* Protocol driver not attached */
#define	ENOCSI		50	/* No CSI structure available */
#define	EL2HLT		51	/* Level 2 halted */
#define	EBADE		52	/* Invalid exchange */
#define	EBADR		53	/* Invalid request descriptor */
#define	EXFULL		54	/* Exchange full */
#define	ENOANO		55	/* No anode */
#define	EBADRQC		56	/* Invalid request code */
#define	EBADSLT		57	/* Invalid slot */

#define	EDEADLOCK	EDEADLK

#define	EBFONT		59	/* Bad font file format */
#define	ENOSTR		60	/* Device not a stream */
#define	ENODATA		61	/* No data available */
#define	ETIME		62	/* Timer expired */
#define	ENOSR		63	/* Out of streams resources */
#define	ENONET		64	/* Machine is not on the network */
#define	ENOPKG		65	/* Package not installed */
#define	EREMOTE		66	/* Object is remote */
#define	ENOLINK		67	/* Link has been severed */
#define	EADV		68	/* Advertise error */
#define	ESRMNT		69	/* Srmount error */
#define	ECOMM		70	/* Communication error on send */
#define	EPROTO		71	/* Protocol error */
#define	EMULTIHOP	72	/* Multihop attempted */
#define	EDOTDOT		73	/* RFS specific error */
#define	EBADMSG		74	/* Not a data message */
#define	EOVERFLOW	75	/* Value too large for defined data type */
#define	ENOTUNIQ	76	/* Name not unique on network */
#define	EBADFD		77	/* File descriptor in bad state */
#define	EREMCHG		78	/* Remote address changed */
#define	ELIBACC		79	/* Can not access a needed shared library */
#define	ELIBBAD		80	/* Accessing a corrupted shared library */
#define	ELIBSCN		81	/* .lib section in a.out corrupted */
#define	ELIBMAX		82	/* Attempting to link in too many shared libraries */
#define	ELIBEXEC	83	/* Cannot exec a shared library directly */
#define	EILSEQ		84	/* Illegal byte sequence */
#define	ERESTART	85	/* Interrupted system call should be restarted */
#define	ESTRPIPE	86	/* Streams pipe error */
#define	EUSERS		87	/* Too many users */
#define	ENOTSOCK	88	/* Socket operation on non-socket */
#define	EDESTADDRREQ	89	/* Destination address required */
#define	EMSGSIZE	90	/* Message too long */
#define	EPROTOTYPE	91	/* Protocol wrong type for socket */
#define	ENOPROTOOPT	92	/* Protocol not available */
#define	EPROTONOSUPPORT	93	/* Protocol not supported */
#define	ESOCKTNOSUPPORT	94	/* Socket type not supported */
#define	EOPNOTSUPP	95	/* Operation not supported on transport endpoint */
#define	EPFNOSUPPORT	96	/* Protocol family not supported */
#define	EAFNOSUPPORT	97	/* Address family not supported by protocol */
#define	EADDRINUSE	98	/* Address already in use */
#define	EADDRNOTAVAIL	99	/* Cannot assign requested address */
#define	ENETDOWN	100	/* Network is down */
#define	ENETUNREACH	101	/* Network is unreachable */
#define	ENETRESET	102	/* Network dropped connection because of reset */
#define	ECONNABORTED	103	/* Software caused connection abort */
#define	ECONNRESET	104	/* Connection reset by peer */
#define	ENOBUFS		105	/* No buffer space available */
#define	EISCONN		106	/* Transport endpoint is already connected */
#define	ENOTCONN	107	/* Transport endpoint is not connected */
#define	ESHUTDOWN	108	/* Cannot send after transport endpoint shutdown */
#define	ETOOMANYREFS	109	/* Too many references: cannot splice */
#define	ETIMEDOUT	110	/* Connection timed out */
#define	ECONNREFUSED	111	/* Connection refused */
#define	EHOSTDOWN	112	/* Host is down */
#define	EHOSTUNREACH	113	/* No route to host */
#define	EALREADY	114	/* Operation already in progress */
#define	EINPROGRESS	115	/* Operation now in progress */
#define	ESTALE		116	/* Stale NFS file handle */
#define	EUCLEAN		117	/* Structure needs cleaning */
#define	ENOTNAM		118	/* Not a XENIX named type file */
#define	ENAVAIL		119	/* No XENIX semaphores available */
#define	EISNAM		120	/* Is a named type file */
#define	EREMOTEIO	121	/* Remote I/O error */
#define	EDQUOT		122	/* Quota exceeded */

#define	ENOMEDIUM	123	/* No medium found */
#define	EMEDIUMTYPE	124	/* Wrong medium type */
#define	ECANCELED	125	/* Operation Canceled */
#define	ENOKEY		126	/* Required key not available */
#define	EKEYEXPIRED	127	/* Key has expired */
#define	EKEYREVOKED	128	/* Key has been revoked */
#define	EKEYREJECTED	129	/* Key was rejected by service */

/* for robust mutexes */
#define	EOWNERDEAD	130	/* Owner died */
#define	ENOTRECOVERABLE	131	/* State not recoverable */

#define ERFKILL		132	/* Operation not possible due to RF-kill */

#define EHWPOISON	133	/* Memory page has hardware error */


# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3

# 4 "/usr/include/linux/errno.h" 2 3




# 25 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3


/* Linux has no ENOTSUP error code.  */
#define ENOTSUP EOPNOTSUPP

/* Older Linux versions also had no ECANCELED error code.  */




/* Support for error codes to support robust mutexes was added later, too.  */










/* Function to get address of global `errno' variable.  */
extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__ ))  __attribute__ ((__const__));


/* When using threads, errno is a per-thread value.  */
#define errno (*__errno_location ())

/* !__ASSEMBLER__ */
/* _ERRNO_H */

/* !_ERRNO_H && __need_Emath */







# 36 "/usr/include/errno.h" 2 3

#undef	__need_Emath



/* Declare the `errno' variable, unless it's defined as a macro by
   bits/errno.h.  This is the case in GNU, where it is a per-thread
   variable.  This redeclaration using the macro still works, but it
   will be a function declaration without a prototype and may trigger
   a -Wstrict-prototypes warning.  */




/* __USE_GNU */






/* _ERRNO_H */

 

/* _ERRNO_H */

/* The Hurd <bits/errno.h> defines `error_t' as an enumerated type so
   that printing `error_t' values in the debugger shows the names.  We
   might need this definition sometimes even if this file was included
   before.  */







# 30 "ulib.h" 2



/* !def FL_EXPORT */
# 43 "ulib.h"



/***************** Portable IO operations *******************{**/

int fli_readint( FILE * );
int fli_readpint( FILE * );
int fli_readhexint( FILE * );
int fli_fget4MSBF( FILE * );
int fli_fput4MSBF( int,
                         FILE * );
int fli_fget2LSBF( FILE * );
int fli_fput2LSBF( int,
                   FILE * );
int fli_fget2MSBF( FILE * );
int fli_fput2MSBF( int,
                   FILE * );
int fli_fget4LSBF( FILE *);
int fli_fput4LSBF( int,
                   FILE * );


/********** End of  Portable IO *******************}**/

char * fli_de_space( char * );
char * fli_space_de( char * );
char * fli_de_space_de( char * );
char * fli_nuke_all_non_alnum( char * );


/*********************************************************************
 * Basic error handling routines
 ********************************************************************/

/* Message levels (verbosity). Error generating routine should
 * have a (positive) control parameter specifying how loud
 * to bark (i.e., amount of messages generated) */

#define ML_ERR     -1
#define ML_WARN     0
#define ML_INFO1    1
#define ML_INFO2    2
#define ML_DEBUG    3
#define ML_TRACE    4

FL_ERROR_FUNC fli_error_setup( int,
                               const char *,
                               int );

extern FL_ERROR_FUNC efp_;
extern FL_ERROR_FUNC user_error_function_;


/* Define the actual names that will be used */

#define M_err   \
    ( efp_ = fli_error_setup( ML_ERR,   __FILE__, __LINE__ ) ), efp_

#define M_warn   \
    ( efp_ = fli_error_setup( ML_WARN,  __FILE__, __LINE__ ) ), efp_

#define M_info   \
    ( efp_ = fli_error_setup( ML_INFO1, __FILE__, __LINE__ ) ), efp_

#define M_info2  \
    ( efp_ = fli_error_setup( ML_INFO2, __FILE__, __LINE__ ) ), efp_

#define M_debug  \
    ( efp_ = fli_error_setup( ML_DEBUG, __FILE__, __LINE__ ) ), efp_

#define M_trace  \
    ( efp_ = fli_error_setup( ML_TRACE, __FILE__, __LINE__ ) ), efp_


/****** Misc. control routines **********/

void fli_set_msg_threshold( int );

const char *fli_get_syserror_msg( void );


/* TC_ULIB_H */


/*
 * Local variables:
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
# 36 "flinternal.h" 2



/*  macros  and constants */

/* FL_DEBUG controls some conditional compilations. Even if the code
 * is compiled in, it still needs -debug level on the command line
 * to activate the message output. FL_DEBUG less than ML_ERR probably
 * is not a good idea. Only when making real production executables
 * should FL_DEBUG be less than ML_ERR (say ML_ERR-1)
 *
 *   ML_ERR    -- print some error messages
 *   ML_WARN    -- print some error messages
 *   ML_INFO1  -- some messages
 *   ML_INFO2  -- more messages
 *   ML_DEBUG  -- debugging code compiled in
 *   ML_TRACE  -- can be unbearable
 */


#define FL_DEBUG   ML_WARN



/* Mask for all possible events */

#define AllEventsMask   ( ( OwnerGrabButtonMask << 1 ) - 1 )


/* There are two ways to handle interaction. One is to process object
 * Q only if there are no more event pending. This can result in
 * an event entered into object Q more than once if the connection
 * is slow and clicking is rapid. If subsequently the object is
 * hidden or deleted/freed, problem occurs as the callback will
 * still be processed. To fix this, need to flush the object Q
 * when hiding/deleting objects. Also if an object is entered
 * multiple times, and its status changed each time, when the
 * Q is handled, we get wrong status.
 *
 * The other way to handle the interaction is to process object
 * Q as soon as the status of the object is changed. This is
 * the correct behavior. However, a change in status is typically
 * preceeded by a redraw (say mouse release on button), and due to
 * the X buffering mechnism, the redraw probably not get shown yet
 * when the callback is evoked. To fix this, an explicit flush
 * is needed. This can be time consuming. Also objects that do
 * not have callbacks may be handled out of order (after the one's
 * having callbacks). */


#define DELAYED_ACTION



/* If we want to have gamma correction as a built-in feature.
 * Probably useless */

#define DO_GAMMA_CORRECTION


/* XForms internal colormap */

typedef struct {
    const char     * name;
    FL_COLOR         index;
    unsigned short   r;
    unsigned short   g;
    unsigned short   b;
    unsigned short   a;
    int              grayval;
} FLI_IMAP;

#define BadPixel  FL_NoColor

#define Clamp( v, vmin, vmax ) ( ( v ) < ( vmin ) ? \
                                 ( vmin ) : ( ( v ) > ( vmax ) ? \
                                              ( vmax ) :( v ) ) )

#define IsValidClass( o, c ) ( ( o ) && ( o )->objclass == ( c ) )

#define fli_safe_free( p )   \
    do { if ( p ) {          \
             fl_free( p );   \
             p = NULL;       \
          }                  \
       } while( 0 )

#define fli_class( i )     fl_state[ i ].vclass
#define fli_depth( i )     fl_state[ i ].depth
#define fli_visual( i )    fl_state[ i ].xvinfo->visual
#define fli_colormap( i )  fl_state[ i ].colormap
#define fli_map( i )       fl_state[ i ].colormap
#define fli_dithered( i )  fl_state[ i ].dithered

enum {
    FLI_FIND_INPUT,
    FLI_FIND_AUTOMATIC,
    FLI_FIND_MOUSE,
    FLI_FIND_CANVAS,
    FLI_FIND_KEYSPECIAL,
    FLI_FIND_RETURN
};

/* events.c or event related */

void fli_obj_queue_delete( void );

void fli_event_queue_delete( void );

void fli_object_qenter( FL_OBJECT *,
                        int );

void fli_filter_returns( FL_OBJECT * );

FL_OBJECT * fli_object_qread( void );

void fli_object_qflush( FL_FORM * );

void fli_object_qflush_object( FL_OBJECT * );

FL_OBJECT *fli_object_qtest( void );

void fli_treat_user_events( void );

void fli_treat_interaction_events( int );

void fli_compress_event( XEvent *,
                         unsigned long );

const char *fli_event_name( int );

XEvent * fli_xevent_name( const char *,
                          const XEvent * );

void fli_handle_idling( XEvent * xev,
                        long     msec,
                        int      do_idle_cb );

/* Variables defined in handling.c */

extern FL_FORM * mouseform;         /* the current form under mouse */
extern FL_FORM * keyform;           /* keyboard focus form */

extern FL_OBJECT * fli_pushobj;
extern FL_OBJECT * fli_mouseobj;

extern FL_Coord fli_mousex,
                fli_mousey;
extern unsigned int fli_keymask;

extern unsigned int fli_query_age;


/* Misc. utilitnes */

FL_FORM * fli_find_event_form( XEvent * );

void fli_print_version( int );

/* from forms.c and object.c */

void fli_scale_form( FL_FORM *,
                     double,
                     double );

void fli_handle_form( FL_FORM *,
                      int, int,
                      XEvent * );

FL_OBJECT *fli_end_group( void );

void fli_handle_object( FL_OBJECT *,
                        int,
                        FL_Coord,
                        FL_Coord,
                        int,
                        XEvent *,
                        int );

FL_OBJECT * fli_find_first( FL_FORM *,
                            int,
                            FL_Coord,
                            FL_Coord );

void fli_show_object( FL_OBJECT * );

void fli_recalc_intersections( FL_FORM * );

FL_OBJECT * fli_find_last( FL_FORM *,
                           int,
                           FL_Coord,
                           FL_Coord );

FL_OBJECT *fli_find_object( FL_OBJECT *,
                            int,
                            FL_Coord,
                            FL_Coord );

FL_OBJECT *fli_find_object_backwards( FL_OBJECT *,
                                      int,
                                      FL_Coord,
                                      FL_Coord );

void fli_insert_object( FL_OBJECT *,
                        FL_OBJECT * );

void fli_scale_object( FL_OBJECT *,
                       double     ,
                       double );

void fli_set_object_visibility( FL_OBJECT * obj,
                                int         vis );


int fli_mouse_wheel_to_keypress( int       * ev,
                                 int       * key,
                                 void      * xev );

void fli_notify_object( FL_OBJECT * obj,
                        int         reason );

/* double buffering etc. */

void fli_free_flpixmap( FL_pixmap * );

void fli_create_object_pixmap( FL_OBJECT * );

void fli_show_object_pixmap( FL_OBJECT * );

void fli_create_form_pixmap( FL_FORM * );

void fli_show_form_pixmap( FL_FORM * );

/* windowing support */

void fli_default_xswa( void );

Window fli_cmap_winopen( Window,
                         Colormap,
                         const char * );

Window fli_create_window( Window,
                          Colormap,
                          const char * );

void fli_create_gc( Window );

enum {
    FLI_COMMAND_PROP = 1,
    FLI_PROP_SET     = ( 1 << 10 )  /* really set */
};

void fli_set_winproperty( Window,
                          unsigned int );

/* graphics related */

void fli_init_colormap( int );

void fli_free_colormap( int );

void fli_dump_state_info( int,
                          const char * );

void fli_init_stipples( void );

void fli_draw_button( FL_OBJECT * );

/* for fdesign */

const char * fli_query_colorname( FL_COLOR );

long fli_query_namedcolor( const char *s );

void fli_free_xtext_workmem( void );

int fli_get_pos_in_string( int,
                           FL_Coord,
                           FL_Coord,
                           FL_Coord,
                           FL_Coord,
                           int,
                           int,
                           FL_Coord,
                           FL_Coord,
                           const char *,
                           int *,
                           int *,
                           int * );

int fli_drw_stringTAB( Window,
                       GC,
                       int,
                       int,
                       int,
                       int,
                       const char *,
                       int,
                       int );

int fli_drw_string( int,
                    FL_Coord,
                    FL_Coord,
                    FL_Coord,
                    FL_Coord,
                    int,
                    FL_COLOR,
                    FL_COLOR,
                    FL_COLOR,
                    int,
                    int,
                    int,
                    int,
                    int,
                    const char *,
                    int,
                    int,
                    int,
                    FL_COLOR );

int fli_get_maxpixel_line( void );

int fli_get_string_widthTABfs( XFontStruct *,
                               const char *,
                               int );

void fli_init_font( void );

void fli_canonicalize_rect( FL_Coord *,
                            FL_Coord *,
                            FL_Coord *,
                            FL_Coord * );

void fli_get_goodie_title( FL_FORM *,
                           const char * );

void fli_add_q_icon( FL_Coord,
                     FL_Coord,
                     FL_Coord,
                     FL_Coord );

void fli_add_warn_icon( FL_Coord,
                        FL_Coord,
                        FL_Coord,
                        FL_Coord );

void fli_check_key_focus( const char *,
                          Window );

void fli_free_cmdline_args( void );

FL_RECT * fli_get_underline_rect( XFontStruct *,
                                  FL_Coord,
                                  FL_Coord,
                                  const char *,
                                  int );


/* Group some WM stuff into a structure for easy maintainance */

typedef struct {
    unsigned int pos_request;   /* USPOSITION or PPOSITION            */
} FLI_WM_STUFF;


/* Routines in sldraw.c. */

typedef struct {
    FL_Coord x;
    FL_Coord y;
    FL_Coord w;
    FL_Coord h;
} FLI_SCROLLBAR_KNOB;

enum {
    FLI_SLIDER_NONE = 0,
    FLI_SLIDER_BOX  = 1,
    FLI_SLIDER_KNOB = 2,
    FLI_SLIDER_ALL  = 3
};


void fli_calc_slider_size( FL_OBJECT *,
                           FLI_SCROLLBAR_KNOB * );

void fli_drw_slider( FL_OBJECT *,
                     FL_COLOR,
                     FL_COLOR,
                     const char *,
                     int );

void fli_drw_checkbox( int      type,
                       FL_Coord x,
                       FL_Coord y,
                       FL_Coord w,
                       FL_Coord h,
                       FL_COLOR col,
                       int      bw );

void fli_set_global_clipping( FL_Coord,
                              FL_Coord,
                              FL_Coord,
                              FL_Coord );

void fli_unset_global_clipping( void );

void fli_set_additional_clipping( FL_Coord,
                                  FL_Coord,
                                  FL_Coord,
                                  FL_Coord );

FL_RECT * fli_get_global_clip_rect( void );


/* Application windows */

typedef struct fli_win_ {
    struct fli_win_ * next;
    Window            win;
    FL_APPEVENT_CB    pre_emptive;      /* always gets called first if set */
    FL_APPEVENT_CB    callback[ 36  ];
    void            * pre_emptive_data;
    void            * user_data[ 36  ];
    FL_APPEVENT_CB    default_callback;
    unsigned long     mask;
} FLI_WIN;

extern FLI_WIN * fl_app_win;

void fli_set_form_window( FL_FORM * );

void fli_unmap_canvas_window( FL_OBJECT * );

FL_APPEVENT_CB fli_set_preemptive_callback( Window,
                                            FL_APPEVENT_CB,
                                            void * );

unsigned long fli_xevent_to_mask( int );

int fli_initialize_program_visual( void );


#define FLI_TIMER_RES           50  /* resolution of FL_STEP event */


/* Currently only one idle procedure is permitted, so the next
 * field is of no much use */

typedef struct fli_idle_cb_ {
    FL_APPEVENT_CB        callback;
    void                * data;
} FLI_IDLE_REC;

typedef struct fli_io_event_ {
    struct fli_io_event_ * next;
    FL_IO_CALLBACK         callback;
    void                 * data;
    unsigned int           mask;
    int                    source;
} FLI_IO_REC;


/* signals */


typedef RETSIGTYPE ( * FLI_OSSIG_HANDLER )( int );


typedef struct fli_signallist_ {
    struct fli_signallist_ * next;
    FL_SIGNAL_HANDLER        callback;



    FLI_OSSIG_HANDLER        ocallback; /* default OS signal handler */

    void                   * data;
    int                      signum;
    int                      caught;
} FLI_SIGNAL_REC;

void fli_remove_all_signal_callbacks( void );

/* timeouts */

typedef struct fli_timeout_ {
    int                    id;
    struct fli_timeout_  * next;
    struct fli_timeout_  * prev;
    long                   start_sec,
                           start_usec;
    long                   ms_to_wait;
    FL_TIMEOUT_CALLBACK    callback;
    void                 * data;
} FLI_TIMEOUT_REC;

void fli_remove_all_timeouts( void );

/*
 *  Intenal controls.
 */

typedef struct fli_context_ {
    FL_FORM_ATCLOSE      atclose;           /* what to do if WM_DELETE_WINDOW */
    void               * close_data;
    FLI_IDLE_REC       * idle_rec;          /* idle callback record   */
    FLI_IO_REC         * io_rec;            /* async IO record        */
    FLI_SIGNAL_REC     * signal_rec;        /* list of app signals    */
    FLI_TIMEOUT_REC    * timeout_rec;       /* timeout callbacks      */
    int                  idle_delta;        /* timer resolution       */
    int                  last_event;        /* last event received    */
    long                 mouse_button;      /* push/release record    */
    int                  pup_id;            /* current active pup id  */
    FL_FORM            * modal;             /* current modal form     */
    long                 max_request_size;  /* max protocol size      */
    int                  num_io;
    int                  hscb,
                         vscb;              /* default scrollbar      */
    long                 ext_request_size;  /* extended request size  */
    int                  tooltip_time;

    XIM                  xim;               /* input method           */
    XIC                  xic;               /* input context          */




    unsigned int         navigate_mask;     /* input field            */
    long                 reserverd[ 6 ];
} FLI_CONTEXT;

/* Some X info that helps to make the windowing system independent
 * API work (fl_color() etc. */

typedef struct {
    Display       * display;
    Window          win;
    GC              gc,
                    textgc;
    GC              miscgc;
    int             isRGBColor;
    int             isMBFont;       /* multi-byte font       */
    unsigned long   bktextcolor;
    int             newpix;
    int             fdesc;          /* font descent          */
    int             fasc;           /* font ascent           */
    int             fheight;        /* font height           */
    Colormap        colormap;
    XFontStruct   * fs;
    unsigned long   color;          /* last color. cache     */
    unsigned long   textcolor;      /* last textcolor. cache */
    unsigned long   bkcolor;
    int             screen;
} FLI_TARGET;


typedef struct {
    FL_FORM      ** forms;             /* all forms, visible and hidden */
    int             formnumb;          /* number of visible forms */
    int             hidden_formnumb;   /* number of hidden forms */
    size_t          auto_count;
    int             unmanaged_count;

    FL_Coord        mousex,            /* last recorded mouse position */
                    mousey;
    unsigned int    keymask;           /* state of buttons and modifier keys */
    unsigned int    query_age;         /* age of recorded information */

    FL_FORM       * mouseform;         /* the current form under the mouse */
    FL_FORM       * keyform;           /* keyboard focus form */

    FL_OBJECT * pushobj;               /* latest pushed object */
    FL_OBJECT * mouseobj;              /* object under the mouse */
} FLI_INTERNAL;

extern FLI_INTERNAL fli_int;


void fli_init_context( void );


#include "extern.h"
# 1 "extern.h" 1
/*
 *  This file is part of the XForms library package.
 *
 * XForms is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1, or
 * (at your option) any later version.
 *
 * XForms is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with XForms. If not, see <http://www.gnu.org/licenses/>.
 */


/**
 * \file extern.h
 *
 *  This file is part of the XForms library package.
 *  Copyright (c) 1996-1998  T.C. Zhao and Mark Overmars
 *  All rights reserved.
 *
 * All global variables used in forms.  Should not be used
 * by application programs.  There is no guarantee that these
 * variables exist in future version of XForms
 */


#define FL_EXTERN_H_MAKING_FORMS_ONLY

extern Pixmap fli_gray_pattern[ ];
extern GC fli_bwgc[ ];
extern GC fli_whitegc;
extern XKeyboardControl fli_keybdcontrol;
extern unsigned long fli_keybdmask;

extern FL_OBJECT *fli_current_group;

#define FLI_INACTIVE_PATTERN fli_gray_pattern[ 1 ]

extern Display *fl_display;
extern Window fl_root,
              fl_vroot;
extern int fl_screen;

extern int fl_vmode;

extern int fl_scrh,
           fl_scrw;

extern float fli_dpi;
extern FL_IOPT fli_cntl;
extern int fli_inverted_y;

extern FLI_CONTEXT * fli_context;
extern FLI_TARGET * flx;
extern long fli_requested_vid;
extern int fli_no_connection;
extern char fli_curfnt[ 127 ];
extern FLI_WIN *fli_app_win;

extern void fli_drw_tbox( int,
                          FL_Coord,
                          FL_Coord,
                          FL_Coord,
                          FL_Coord,
                          FL_COLOR,
                          int );


/* !def EXTERN.H */


/*
 * Local variables:
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
# 617 "flinternal.h" 2



void fli_watch_io( FLI_IO_REC *,
                   long );

int fli_do_shortcut( FL_FORM *,
                     int,
                     FL_Coord,
                     FL_Coord,
                     XEvent * );

int fli_test_lalign( int          align,
                     const char * txt );

void fli_get_hv_align( int,
                       int *,
                       int * );

void fli_get_outside_align( int,
                            int,
                            int,
                            int,
                            int,
                            int *,
                            int *,
                            int * );

void fli_init_symbols( void );

void fli_release_symbols( void );

int fli_handle_event_callbacks( XEvent * );


/* Some macros to test how an object can be moved or resized, depending on
   its gravity settings (ULC = uppler left hand cornner, LRC = lower right
   hand corner) */

#define ULC_POS_LEFT_FIXED( obj )                \
    (    ( obj )->nwgravity == FL_NorthWest      \
      || ( obj )->nwgravity == FL_West           \
      || ( obj )->nwgravity == FL_SouthWest )

#define ULC_POS_RIGHT_FIXED( obj )               \
    (    ( obj )->nwgravity == FL_NorthEast      \
      || ( obj )->nwgravity == FL_East           \
      || ( obj )->nwgravity == FL_SouthEast )

#define LRC_POS_LEFT_FIXED( obj )                \
    (    ( obj )->segravity == FL_NorthWest      \
      || ( obj )->segravity == FL_West           \
      || ( obj )->segravity == FL_SouthWest )

#define LRC_POS_RIGHT_FIXED( obj )               \
    (    ( obj )->segravity == FL_NorthEast      \
      || ( obj )->segravity == FL_East           \
      || ( obj )->segravity == FL_SouthEast )

#define HAS_FIXED_HORI_ULC_POS( obj )                             \
    ( ULC_POS_LEFT_FIXED( obj ) || ULC_POS_RIGHT_FIXED( obj ) )

#define HAS_FIXED_HORI_LRC_POS( obj )                             \
    ( LRC_POS_LEFT_FIXED( obj ) || LRC_POS_RIGHT_FIXED( obj ) )

#define HAS_FIXED_WIDTH( obj )                                          \
    ( HAS_FIXED_HORI_ULC_POS( obj ) && HAS_FIXED_HORI_LRC_POS( obj ) ) 


#define ULC_POS_TOP_FIXED( obj )                 \
    (    ( obj )->nwgravity == FL_NorthWest      \
      || ( obj )->nwgravity == FL_North          \
      || ( obj )->nwgravity == FL_NorthEast )

#define ULC_POS_BOTTOM_FIXED( obj )              \
    (    ( obj )->nwgravity == FL_SouthWest      \
      || ( obj )->nwgravity == FL_South          \
      || ( obj )->nwgravity == FL_SouthEast )

#define LRC_POS_TOP_FIXED( obj )                 \
    (    ( obj )->segravity == FL_NorthWest      \
      || ( obj )->segravity == FL_North          \
      || ( obj )->segravity == FL_NorthEast )

#define LRC_POS_BOTTOM_FIXED( obj )              \
    (    ( obj )->segravity == FL_SouthWest      \
      || ( obj )->segravity == FL_South          \
      || ( obj )->segravity == FL_SouthEast )

#define HAS_FIXED_VERT_ULC_POS( obj )                             \
    ( ULC_POS_TOP_FIXED( obj ) || ULC_POS_BOTTOM_FIXED( obj ) )

#define HAS_FIXED_VERT_LRC_POS( obj )                             \
    ( LRC_POS_TOP_FIXED( obj ) || LRC_POS_BOTTOM_FIXED( obj ) )

#define HAS_FIXED_HEIGHT( obj )                                         \
    ( HAS_FIXED_VERT_ULC_POS( obj ) && HAS_FIXED_VERT_LRC_POS( obj ) ) 



#define XK_PageUp    XK_Prior
#define XK_PageDn    XK_Next

#define XK_PageUp    XK_Prior
#define XK_PageDn    XK_Next


/* some header has XK_XP_Left etc */



#define IsHome( k )     ( k == XK_Home  || k == XK_Begin || k == XK_KP_Home )
#define IsLeft( k )     ( k == XK_Left  || k == XK_KP_Left )
#define IsRight( k )    ( k == XK_Right || k == XK_KP_Right )
#define IsUp( k )       ( k == XK_Up    || k == XK_KP_Up )
#define IsDown( k )     ( k == XK_Down  || k == XK_KP_Down )
#define IsEnd( k )      ( k == XK_End   || k == XK_KP_End )
#define IsPageDown( k ) ( k == XK_Next  || k == XK_Page_Down || k == XK_KP_Page_Down )
#define IsPageUp( k )   ( k == XK_Prior || k == XK_Page_Up || k==XK_KP_Page_Up)

# 748 "flinternal.h"


#define FLI_HALFPAGE_UP        0x10000000
#define FLI_HALFPAGE_DOWN      0x20000000
#define FLI_NLINES_UP          0x30000000
#define FLI_NLINES_DOWN        0x40000000
#define FLI_1LINE_UP           0x50000000
#define FLI_1LINE_DOWN         0x60000000
#define IsHalfPageUp( k )      ( ( k ) == FLI_HALFPAGE_UP )
#define IsHalfPageDown( k )    ( ( k ) == FLI_HALFPAGE_DOWN )
#define IsNLinesUp( k )        ( ( k ) == FLI_NLINES_UP )
#define IsNLinesDown( k )      ( ( k ) == FLI_NLINES_DOWN )
#define Is1LineUp( k )         ( ( k ) == FLI_1LINE_UP )
#define Is1LineDown( k )       ( ( k ) == FLI_1LINE_DOWN )


void fli_hide_and_get_region( FL_OBJECT *,
                              Region    * );

int fli_convert_shortcut( const char *,
                          long * );

int fli_get_underline_pos( const char *,
                           const char * );

int fli_get_visible_forms_index( FL_FORM * );

void fli_recount_auto_objects( void );

int fli_get_tabpixels( XFontStruct * );

int fli_get_default_scrollbarsize( FL_OBJECT * );

void fli_set_app_name( const char *,
                       const char * );

void fli_hide_composite( FL_OBJECT *,
                         Region    * );

void fli_show_composite( FL_OBJECT * );

void fli_deactivate_composite( FL_OBJECT * );

void fli_activate_composite( FL_OBJECT * );

void fli_delete_composite( FL_OBJECT * ob );

void fli_free_composite( FL_OBJECT * ob );

void fli_set_composite_gravity( FL_OBJECT *,
                                unsigned int,
                                unsigned int );

void fli_set_composite_resize( FL_OBJECT *,
                               unsigned int );

void fli_composite_has_been_resized( FL_OBJECT * );

void fli_parse_goodies_label( FL_OBJECT *,
                              const char * );

int fli_goodies_preemptive( FL_FORM *,
                            void * );

void fli_get_goodies_font( int *,
                           int * );

void fli_handle_goodie_font( FL_OBJECT *,
                             FL_OBJECT * );

void fli_goodies_cleanup( void );

void fli_msg_cleanup( void );

void fli_alert_cleanup( void );

void fli_choice_cleanup( void );

void fli_question_cleanup( void );

void fli_input_cleanup( void );

void fli_sinput_cleanup( void );

void fli_handle_timeouts( long * );

#define FL_IS_NONSQRBOX( t ) (    t == FL_SHADOW_BOX          \
                               || t == FL_NO_BOX              \
                               || t == FL_RFLAT_BOX           \
                               || t == FL_ROUNDED_BOX         \
                               || t == FL_OVAL_BOX            \
                               || t == FL_ROUNDED3D_UPBOX     \
                               || t == FL_ROUNDED3D_DOWNBOX )

enum {
    FLI_TRIANGLE_UPBOX1,
    FLI_TRIANGLE_UPBOX2,
    FLI_TRIANGLE_UPBOX3,
    FLI_TRIANGLE_UPBOX4,
    FLI_TRIANGLE_UPBOX6,
    FLI_TRIANGLE_UPBOX7,
    FLI_TRIANGLE_UPBOX8,
    FLI_TRIANGLE_UPBOX9,
    FLI_TRIANGLE_DOWNBOX1,
    FLI_TRIANGLE_DOWNBOX2,
    FLI_TRIANGLE_DOWNBOX3,
    FLI_TRIANGLE_DOWNBOX4,
    FLI_TRIANGLE_DOWNBOX6,
    FLI_TRIANGLE_DOWNBOX7,
    FLI_TRIANGLE_DOWNBOX8,
    FLI_TRIANGLE_DOWNBOX9
};

FL_RECT * fli_intersect_rects( const FL_RECT *,
                               const FL_RECT * );

void fli_xyplot_nice_label( float,
                            int,
                            float,
                                   char * );

void fli_xyplot_compute_data_bounds( FL_OBJECT *,
                                     int *,
                                     int *,
                                     int );

int fli_xyplot_interpolate( FL_OBJECT *,
                            int,
                            int,
                            int );

void fli_insert_composite_after( FL_OBJECT *,
                                 FL_OBJECT * );

void fli_add_composite( FL_OBJECT * );

void fli_insert_composite( FL_OBJECT *,
                           FL_OBJECT * );

int fli_is_watched_io( int );

const char * fli_object_class_name( FL_OBJECT * );

char * fli_read_line( FILE * fp );

char * fli_sstrcpy( char       * dest,
                    const char * src,
                    size_t       n );

void fli_set_form_icon_data( FL_FORM *,
                             char ** );

char *fli_getcwd( char *,
                  int );

void fli_replacepup_text( int,
                          int,
                          const char * );

int fli_valuator_handle_drag( FL_OBJECT *,
                              double );

int fli_valuator_handle_release( FL_OBJECT *,
                                 double );

void *fli_init_valuator( FL_OBJECT * );

double fli_valuator_round_and_clamp( FL_OBJECT *,
                                     double );

double fli_clamp( double,
                  double,
                  double );

void fli_inherit_attributes( FL_OBJECT *,
                             FL_OBJECT * );

int fli_boxtype2frametype( int );

void fli_xvisual2flstate( FL_State *,
                          XVisualInfo * );

int fli_find_closest_color( int,
                            int,
                            int,
                            XColor *,
                            int,
                            unsigned long * );

void fli_rgbmask_to_shifts( unsigned long,
                            unsigned int *,
                            unsigned int * );

void fli_show_tooltip( const char *,
                       int,
                       int );

void fli_hide_tooltip( void );

int fli_is_tooltip_form( FL_FORM * );

void fli_do_radio_push( FL_OBJECT *,
                        FL_Coord,
                        FL_Coord,
                        int,
                        void *,
                        int );

long fli_getpid( void );

void fli_xlinestyle( Display *,
                     GC,
                     int );

#define FLI_BROKEN_BOX  ( 1 << 10 )

FLI_TARGET * fli_internal_init( void );

void fli_switch_target( FLI_TARGET * );

void fli_restore_target( void );

void fli_draw_text_inside( int align,
                           FL_Coord,
                           FL_Coord,
                           FL_Coord,
                           FL_Coord,
                           const char *,
                           int,
                           int,
                           FL_COLOR,
                           FL_COLOR,
                           int );

/* Misc. stuff */

void fli_add_vertex( FL_Coord x,
                     FL_Coord y );

void fli_add_float_vertex( float x,
                           float y );

void fli_reset_vertex( void );

void fli_endpolygon( void );

void fli_endclosedline( void );

void fli_endline( void );

const char * fli_get_xevent_name( const XEvent * );

void fli_set_input_navigate( unsigned int mask );

void fli_adjust_browser_scrollbar( FL_OBJECT * );

FL_POPUP * fli_popup_add( Window,
                          const char *,
                          const char * );

FL_POPUP_ENTRY * fli_popup_add_entries( FL_POPUP *,
                                        const char *,
                                        va_list,
                                        const char *,
                                        int );

FL_POPUP_ENTRY * fli_popup_insert_entries( FL_POPUP *,
                                           FL_POPUP_ENTRY *,
                                           const char *,
                                           va_list,
                                           const char *,
                                           int );

FL_POPUP_ENTRY * fli_popup_insert_items( FL_POPUP       *,
                                         FL_POPUP_ENTRY *,
                                         FL_POPUP_ITEM  *,
                                         const char * );

void fli_popup_init( void );

void fli_popup_finish( void );

int fli_check_popup_exists( FL_POPUP * );

int fli_check_popup_entry_exists( FL_POPUP_ENTRY * );

FL_POPUP_RETURN * fli_set_popup_return( FL_POPUP_ENTRY * );

void fli_popup_reset_counter( FL_POPUP * );

void fli_free_cursors( void );

void fli_free_fselectors( void );


/*  Some utility stuff */

typedef struct {
    int          val;
    const char * name;
} FLI_VN_PAIR;

int fli_get_vn_value( FLI_VN_PAIR * vn_pair,
                      const char  * name );

const char * fli_get_vn_name( FLI_VN_PAIR * vn_pair,
                              int           val );



#define IsTab( ksym )  ( ksym == XK_ISO_Left_Tab || ksym== XK_Tab )







void fli_set_tab_color( FL_OBJECT * obj,
                        FL_COLOR    col1,
                        FL_COLOR    col2 );

void fli_set_tab_lcolor( FL_OBJECT * obj,
                         FL_COLOR    lcol );

void fli_set_tab_lsize( FL_OBJECT * obj,
                        int         lsize );

void fli_set_tab_lstyle( FL_OBJECT * obj,
                         int         lstyle );

void fli_set_tab_lalign( FL_OBJECT * obj,
                         int         align );

void fli_set_tab_bw( FL_OBJECT * obj,
                     int         bw );
void fli_textcolor( FL_COLOR col );

void fli_bk_textcolor( FL_COLOR col );

char * fli_fix_dirname( char * dir );

Cursor fli_get_cursor_byname( int name );

void fli_hide_canvas( FL_OBJECT * ob );

const char * fli_vclass_name( int n );

int fli_vclass_val( const char * v );

void fli_set_ul_property( int prop,
                          int thickness );

int fli_is_valid_dir( const char * name );


/* ! defined FL_INTERNAL_H */


/*
 * Local variables:
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
# 35 "forms.c" 2

#include "private/flvasprintf.h"
# 1 "private/flvasprintf.h" 1
/*
 *  This file is part of the XForms library package.
 *
 *  XForms is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation; either version 2.1, or
 *  (at your option) any later version.
 *
 *  XForms is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with XForms.  If not, see <http://www.gnu.org/licenses/>.
 */



#define FLVASPRINTF_H





#include <stdio.h>
#include <stdarg.h>
#include "flsnprintf.h"
# 1 "private/flsnprintf.h" 1
/*
 *  This file is part of the XForms library package.
 *
 *  XForms is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation; either version 2.1, or
 *  (at your option) any later version.
 *
 *  XForms is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with XForms.  If not, see <http://www.gnu.org/licenses/>.
 */


/**
 * \file flsnprintf.h
 */


#define FL_SNPRINTF_H

#include <stdio.h>

# 47 "private/flsnprintf.h"


int fli_portable_snprintf( char *,
                           size_t,
                           const char *,
                                     ... );

int fli_portable_vsnprintf( char *,
                            size_t,
                            const char *,
                            va_list );

#define fli_snprintf  fli_portable_snprintf
#define fli_vsnprintf fli_portable_vsnprintf

/* HAVE_SNPRINTF */

/* NOT FL_SNPRINTF_H */


/*
 * Local variables:
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
# 28 "private/flvasprintf.h" 2









/* Macro for allocating a buffer and filling it with a string
 * constructed from a format string and an unspecified number
 * of arguments. It expects a char pointer first (which will
 * be set to the address of the memory allocated for the resulting
 * string) and a (const) char pointer with a printf-like format
 * string (if the pointer to the format string is NULL memory is
 * obtained for the empty string). Of course, the function from
 * which the macro is invoked from must be a variadic function,
 * called with the appropriate number of types of arguments for
 * the format string.
 *
 * On success the first argument will be set to a buffer long
 * enough and containing the intended string. If there wasn't
 * enough memory available an attempted is make to at least
 * allocate memory for the empty string. If even this fails
 * the first macro argument is set to NULL.
 *
 * Of course it's the responsibility of whatever invoked
 * this macro to release the memory allocated here at the
 * appropriate time.
 *
 * The best function to use here would be vasprintf(), which
 * exactly does what we need. Older systems may not have it -
 * in this case 'HAVE_VASPRINTF isn't defined. Unfortunately,
 * we can't use the implementation from the flsnprintf.c file
 * since it doesn't get compiled in the way this file is made
 * up (and for good reasonsm the way the necessary va_copy()
 * function gets defined is broken in more than one way). But
 * we can use fli_vsnprintf() from that file, though with some
 * difficulties.
 *
 * For such systems we need a way to not "use up" the va_list
 * by initializing it and then passing it to some function
 * (that's actually the rationale for using a macro here
 * instead of a function!), so we must do the memory allo-
 * cation here (if necessary repeatedly) and only call
 * fli_vsnprintf().
 *
 * So the whole existence of this macro is due to backward
 * compatibility with old (pre C99) compilers that may have
 * a uncommon way of defining a va_list. Messy, isnt' it?
 *
 * BTW, all locally used variables have names starting with 'l1I_'
 * since this is a prefix no sane person would ever use - we try to
 * avoid compiler warnings about local variables shadowing already
 * defined ones.
 */

# 110 "private/flvasprintf.h"


#define EXPAND_FORMAT_STRING( buf, fmt )                                    \
do {                                                                        \
    if ( ! fmt || ! *fmt )                                                  \
        buf = NULL;                                                         \
    else if ( ! strchr( fmt, '%' ) )                                        \
    {                                                                       \
        if ( ( buf = fl_malloc( strlen( fmt ) + 1 ) ) )                     \
            strcpy( buf, fmt );                                             \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        int l1I_min_needed = strlen( fmt ) + 1;                             \
        int l1I_len = l1I_min_needed;                                       \
        char *l1I_p;                                                        \
                                                                            \
        for ( l1I_p = strchr( fmt, '%' ); l1I_p;                            \
              l1I_p = strchr( ++l1I_p, '%' ) )                              \
            l1I_len += 16;                                                  \
                                                                            \
        if ( ( buf = fl_malloc( l1I_len ) ) )                               \
        {                                                                   \
            while ( 1 )                                                     \
            {                                                               \
                va_list l1I_ap;                                             \
                int l1I_written;                                            \
                                                                            \
                va_start( l1I_ap, fmt );                                    \
                l1I_written = fli_vsnprintf( buf, l1I_len, fmt, l1I_ap );   \
                va_end( l1I_ap );                                           \
                                                                            \
                /* Take care: older libc versions returned a negative       \
                   value if the buffer wasn't large enough space while      \
                   newer ones follow C99 and return the length of the       \
                   string needed (without the trailing '\0') */             \
                                                                            \
                if ( l1I_written > -1 && l1I_len > l1I_written )            \
                {                                                           \
                    if ( l1I_len != l1I_written + 1 )                       \
                    {                                                       \
                        l1I_p = buf;                                        \
                        if ( ! ( buf = fl_realloc( l1I_p,                   \
                                                   l1I_written + 1 ) ) )    \
                            buf = l1I_p;                                    \
                    }                                                       \
                    break;                                                  \
                }                                                           \
                                                                            \
                l1I_len = l1I_written < 0 ?                                 \
                          ( 2 * l1I_len ) : ( l1I_written + 16 );           \
                l1I_p = buf;                                                \
                if ( ! ( buf = fl_realloc( l1I_p, l1I_len ) ) )             \
                {                                                           \
                    fl_free( l1I_p );                                       \
                    break;                                                  \
                }                                                           \
            }                                                               \
        }                                                                   \
    }                                                                       \
                                                                            \
    if ( ! buf && ( buf = fl_malloc( 1 ) ) )                                \
            *buf = '\0';                                                    \
} while ( 0 )







/*
 * Local variables:
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
# 36 "forms.c" 2



#define PointToPixel( a )     FL_crnd( ( a ) * fli_dpi / 72.0   )
#define MMToPixel( a )        FL_crnd( ( a ) * fli_dpi / 25.4   )
#define CMMToPixel( a )       FL_crnd( ( a ) * fli_dpi / 2540.0 )
#define CPointToPixel( a )    FL_crnd( ( a ) * fli_dpi / 7200.0 )

static FL_FORM * create_new_form( FL_Coord,
                                  FL_Coord );
static void force_visible( FL_FORM * );
static void set_form_property( FL_FORM *,
                               unsigned int );
static void get_decoration_sizes_from_wm( Atom ,
                                          FL_FORM *,
                                          int *,
                                          int *,
                                          int *,
                                          int * );
static void get_decorations_sizes_from_parent( FL_FORM *,
                                               int *,
                                               int *,
                                               int *,
                                               int * );


static FL_FORM * fli_mainform;
static int nomainform;
static int reopened_group = 0;

FL_FORM * fli_fast_free_object = ((void *)0) ;    /* exported to objects.c */

static int has_initial;


/***************************************
 * Returns the index of a form in the list of visible forms
 * (or -1 if the form isn't in this list)
 ***************************************/

int
fli_get_visible_forms_index( FL_FORM * form )
{
    int i;

    for ( i = 0; i < fli_int.formnumb; i++ )
        if ( fli_int.forms[ i ] == form )
            return i;

    return -1;
}


/***************************************
 * Returns the index of a form in the list of hidden forms
 * (or -1 if the form isn't in this list)
 ***************************************/

static int
get_hidden_forms_index( FL_FORM * form )
{
    int i;

    for ( i = fli_int.formnumb;
          i < fli_int.formnumb + fli_int.hidden_formnumb; i++ )
        if ( fli_int.forms[ i ] == form )
            return i;

    return -1;
}


/***************************************
 * Extend the list of forms by one element and appends the
 * new forms address (listing it as invisible)
 ***************************************/

static void
add_form_to_hidden_list( FL_FORM * form )
{
    fli_int.forms = realloc( fli_int.forms,
                             ( fli_int.formnumb + fli_int.hidden_formnumb + 1 )
                             * sizeof *fli_int.forms );
    fli_int.forms[ fli_int.formnumb + fli_int.hidden_formnumb++ ] = form;
}


/***************************************
 * Moves a form from the list of hidden to the list of visible forms
 ***************************************/

static int
move_form_to_visible_list( FL_FORM * form )
{
    int i;

    /* Find the index of the hidden form */

    if (    fli_int.hidden_formnumb == 0
         || ( i = get_hidden_forms_index( form ) ) < 0 )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 137 ) ), efp_ ( "move_form_to_visble_list", "Form not in hidden list" );
        return -1;
    }
        
    /* If it's not at the very start of the hidden list exchange it
       with the one at the start */

    if ( i != fli_int.formnumb )
    {
        fli_int.forms[ i ] = fli_int.forms[ fli_int.formnumb ];
        fli_int.forms[ fli_int.formnumb ] = form;
    }

    fli_int.hidden_formnumb--;

    if ( form->num_auto_objects > 0 )
        fli_int.auto_count++;

    return ++fli_int.formnumb;
}


/***************************************
 * Moves a form from the list of visible to the list of hidden forms
 ***************************************/

static int
move_form_to_hidden_list( FL_FORM * form )
{
    int i;

    /* Find the index of the form to be moved to the hidden list */

    if (    fli_int.formnumb == 0
         || ( i = fli_get_visible_forms_index( form ) ) < 0 )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 173 ) ), efp_ ( "move_form_to_hidden_list", "Form not in visible list" );
        return -1;
    }

    /* Unless the form is the last in the visible list exchange it with
       the form at the end of the visible list */

    if ( i != --fli_int.formnumb )
    {
        fli_int.forms[ i ] = fli_int.forms[ fli_int.formnumb ];
        fli_int.forms[ fli_int.formnumb ] = form;
    }

    fli_int.hidden_formnumb++;

    if ( form->num_auto_objects > 0 )
    {
        if ( fli_int.auto_count == 0 )
            ( efp_ = fli_error_setup( -1 ,   "forms.c", 191 ) ), efp_ ( "move_form_to_hidden_list", "Bad auto count" );
        else
            fli_int.auto_count--;
    }

    return fli_int.formnumb;
}


/***************************************
 * Removes a form from the list of hidden forms,
 * shortening the list in the process
 ***************************************/

int
remove_form_from_hidden_list( FL_FORM * form )
{
    int i;

    /* Find the index of the form to be removed completely from the
       hidden list */

    if (    fli_int.hidden_formnumb == 0
         || ( i = get_hidden_forms_index( form ) ) < 0 )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 216 ) ), efp_ ( "remove_form_from_hidden_list", "Form not in hidden list" );
        return -1;
    }

    /* If it's not the form at the end of the hidden list exchange it with
       the one at the end */

    if ( i != fli_int.formnumb + --fli_int.hidden_formnumb )
        fli_int.forms[ i ] =
                   fli_int.forms[ fli_int.formnumb + fli_int.hidden_formnumb ];

    /* Shorten the list of visible and hidden forms by one element */

    fli_int.forms = fl_realloc( fli_int.forms,
                                ( fli_int.formnumb + fli_int.hidden_formnumb )
                                * sizeof *fli_int.forms );

    return fli_int.formnumb;
}


/***************************************
 * Returns the (visible) form that's shown in 'win'
 ***************************************/

FL_FORM *
fl_win_to_form( Window win )
{
    int i;

    if ( win == 0L  )
        return ((void *)0) ;

    for ( i = 0; i < fli_int.formnumb; i++ )
        if ( fli_int.forms[ i ]->window == win )
            return fli_int.forms[ i ];

    return ((void *)0) ;
}


/***************************************
 * Creates a new, empty form
 ***************************************/

static FL_FORM *
create_new_form( FL_Coord w,
                 FL_Coord h )
{
    FL_FORM *form;

    form = fl_calloc( 1, sizeof *form );

    /* Convert non-pixel unit into pixles */

    switch ( fli_cntl.coordUnit )
    {
        case FL_COORD_PIXEL :
            break;

        case FL_COORD_MM :
            w = ( ( FL_Coord ) ( (   (   w   ) * fli_dpi / 25.4     ) > 0 ? ( (   (   w   ) * fli_dpi / 25.4     ) + 0.5 ) : ( (   (   w   ) * fli_dpi / 25.4     ) - 0.5 ) ) )  ;
            h = ( ( FL_Coord ) ( (   (   h   ) * fli_dpi / 25.4     ) > 0 ? ( (   (   h   ) * fli_dpi / 25.4     ) + 0.5 ) : ( (   (   h   ) * fli_dpi / 25.4     ) - 0.5 ) ) )  ;
            break;

        case FL_COORD_POINT :
            w = ( ( FL_Coord ) ( (   (   w   ) * fli_dpi / 72.0     ) > 0 ? ( (   (   w   ) * fli_dpi / 72.0     ) + 0.5 ) : ( (   (   w   ) * fli_dpi / 72.0     ) - 0.5 ) ) )  ;
            h = ( ( FL_Coord ) ( (   (   h   ) * fli_dpi / 72.0     ) > 0 ? ( (   (   h   ) * fli_dpi / 72.0     ) + 0.5 ) : ( (   (   h   ) * fli_dpi / 72.0     ) - 0.5 ) ) )  ;
            break;

        case FL_COORD_centiPOINT :
            w = ( ( FL_Coord ) ( (   (   w   ) * fli_dpi / 7200.0   ) > 0 ? ( (   (   w   ) * fli_dpi / 7200.0   ) + 0.5 ) : ( (   (   w   ) * fli_dpi / 7200.0   ) - 0.5 ) ) )  ;
            h = ( ( FL_Coord ) ( (   (   h   ) * fli_dpi / 7200.0   ) > 0 ? ( (   (   h   ) * fli_dpi / 7200.0   ) + 0.5 ) : ( (   (   h   ) * fli_dpi / 7200.0   ) - 0.5 ) ) )  ;
            break;

        case FL_COORD_centiMM :
            w = ( ( FL_Coord ) ( (   (   w   ) * fli_dpi / 2540.0   ) > 0 ? ( (   (   w   ) * fli_dpi / 2540.0   ) + 0.5 ) : ( (   (   w   ) * fli_dpi / 2540.0   ) - 0.5 ) ) )  ;
            h = ( ( FL_Coord ) ( (   (   h   ) * fli_dpi / 2540.0   ) > 0 ? ( (   (   h   ) * fli_dpi / 2540.0   ) + 0.5 ) : ( (   (   h   ) * fli_dpi / 2540.0   ) - 0.5 ) ) )  ;
            break;

        default :
            ( efp_ = fli_error_setup( -1 ,   "forms.c", 297 ) ), efp_ ( "create_new_form", "Unknown unit: %d, using pixel",
                   fli_cntl.coordUnit );
            fli_cntl.coordUnit = FL_COORD_PIXEL;
    }

    /* Initialize pointers and non-zero defaults */

    form->w_hr = form->w    = w;
    form->h_hr = form->h    = h;

    form->handle_dec_x      = 0;
    form->handle_dec_y      = 0;

    form->num_auto_objects  = 0;
    form->deactivated       = 1;
    form->form_callback     = ((void *)0) ;
    form->compress_mask     =   (1L<<15)  | (1L<<13) 
                              | (1L<<6) ;
    form->key_callback      = ((void *)0) ;
    form->push_callback     = ((void *)0) ;
    form->crossing_callback = ((void *)0) ;
    form->focusobj          = ((void *)0) ;
    form->first             = ((void *)0) ;
    form->last              = ((void *)0) ;
    form->hotx              = form->hoty = -1;
    form->use_pixmap        = fli_cntl.doubleBuffer;
    form->label             = ((void *)0) ;
    form->flpixmap          = ((void *)0) ;
    form->u_vdata           = ((void *)0) ;
    form->close_callback    = ((void *)0) ;
    form->close_data        = ((void *)0) ;
    form->icon_pixmap       = form->icon_mask = 0L ;
    form->in_redraw         = 0;
    form->needs_full_redraw = 1;

    return form;
}


/***************************************
 * Starts a form definition
 ***************************************/

FL_FORM *
fl_bgn_form( int      type,
             FL_Coord w,
             FL_Coord h )
{
    if ( ! fli_no_connection && ! flx->display )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 347 ) ), efp_ ( "fl_bgn_form", "Missing or failed call of fl_initialize()" );
        exit( 1 );
    }

    /* Check that we're not already in a form definition - the error is
       a serious one and can't be fixed easily as it might be due to a
       bad recursion */

    if ( fl_current_form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 357 ) ), efp_ ( "fl_bgn_form", "You forgot to call fl_end_form" );
        exit( 1 );
    }

    /* Create a new form */

    fl_current_form = create_new_form( w, h );

    /* Add it to the list of still hidden forms */

    add_form_to_hidden_list( fl_current_form );

    /* Each form has an empty box, covering the whole form as its first
       object */

    fl_add_box( type, 0, 0, w, h, "" );

    return fl_current_form;
}


/***************************************
 * Ends a form definition
 ***************************************/

void
fl_end_form( void )
{
    FL_FORM * f = fl_current_form;

    if ( ! fl_current_form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 389 ) ), efp_ ( "fl_end_form", "No current form" );
        return;
    }

    if ( fli_current_group )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 395 ) ), efp_ ( "fl_end_form", "You forgot to call fl_end_group." );
        fl_end_group( );
    }

    fl_current_form = ((void *)0) ;

    /* Now is the proper time for calculating the overlaps of objects */

    fli_recalc_intersections( f );

    if ( f->visible && ! f->frozen )
        fl_redraw_form( f );
}


/***************************************
 * Reopens a form for adding further objects
 ***************************************/

FL_FORM *
fl_addto_form( FL_FORM * form )
{
    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 419 ) ), efp_ ( "fl_addto_form", "NULL form" );
        return ((void *)0) ;
    }

    /* We can't open a form for adding objects when another form has already
       been opened for the same purpose */

    if ( fl_current_form && fl_current_form != form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 428 ) ), efp_ ( "fl_addto_form", "You forgot to call fl_end_form" );
        return ((void *)0) ;
    }

    if ( fl_current_form )
        ( efp_ = fli_error_setup( 0 ,  "forms.c", 433 ) ), efp_ ( "fl_addto_form", "Form was never closed." );

    return fl_current_form = form;
}


/***************************************
 * Starts a group definition by adding an object of type FL_BEGIN_GROUP
 ***************************************/

FL_OBJECT *
fl_bgn_group( void )
{
    static int id = 1;

    if ( ! fl_current_form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 450 ) ), efp_ ( "fl_bgn_group", "NULL form" );
        return ((void *)0) ;
    }

    if ( fli_current_group )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 456 ) ), efp_ ( "fl_bgn_group", "You forgot to call fl_end_group." );
        fl_end_group( );
    }

    fli_current_group = fl_make_object( 10000 , 0, 0, 10, 10, 0,
                                        "", ((void *)0)  );
    fli_current_group->group_id = id++;

    /* Temporarily set the object class to something invalid since
       fl_add_object() will not add objects of class FL_BEGIN_GROUP */

    fli_current_group->objclass = FL_INVALID_CLASS;
    fl_add_object( fl_current_form, fli_current_group );
    fli_current_group->objclass = 10000 ;

    return fli_current_group;
}


/***************************************
 * Ends a group definition by adding an object of type FL_END_GROUP
 ***************************************/

FL_OBJECT *
fli_end_group( void )
{
    FL_OBJECT *obj;
    int id;

    if ( ! fl_current_form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 487 ) ), efp_ ( "fl_end_group", "NULL form" );
        return ((void *)0) ;
    }

    if ( ! fli_current_group )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 493 ) ), efp_ ( "fl_end_group", "NULL group." );
        return ((void *)0) ;
    }

    obj = fli_current_group;
    id = obj->group_id;
    fli_current_group = ((void *)0) ;

    if ( ! reopened_group )
    {
        obj = fl_make_object( 20000 , 0, 0, 0, 0, 0, "", ((void *)0)  );
        obj->group_id = id;

        /* Temporarily set the object class to something invalid since
           fl_add_object() will not add objects of class FL_END_GROUP */

        obj->objclass = FL_INVALID_CLASS;
        fl_add_object( fl_current_form, obj );
        obj->objclass = 20000 ;
    }

    if ( reopened_group == 2 )
        fl_end_form( );

    reopened_group = 0;

    return obj;
}


/***************************************
 * Necessary since the public interface function for ending a group
 * doesn't have a return value
 ***************************************/

void
fl_end_group( void )
{
    fli_end_group( );
}


/***************************************
 * "Freezes" all (shown) forms
 ***************************************/

void
fl_freeze_all_forms( void )
{
    int i;

    for ( i = 0; i < fli_int.formnumb; i++ )
        fl_freeze_form( fli_int.forms[ i ] );
}


/***************************************
 * "Unfreezes" all (shown) forms
 ***************************************/

void
fl_unfreeze_all_forms( void )
{
    int i;

    for ( i = 0; i < fli_int.formnumb; i++ )
        fl_unfreeze_form( fli_int.forms[ i ] );
}


/***************************************
 * Corrects the shape of the form based on the shape of its window
 ***************************************/

static void
reshape_form( FL_FORM * form )
{
    FL_Coord w,
             h,
             dummy;
    int top,
        right,
        bottom,
        left;

    if (    ( ! form->handle_dec_x && ! form->handle_dec_y )
         || form->wm_border == FL_NOBORDER )
    {
        fl_get_wingeometry( form->window, &form->x, &form->y, &w, &h );
        fl_set_form_size( form, w, h );
        return;
    }

    fl_get_decoration_sizes( form, &top, &right, &bottom, &left );

    if ( form->handle_dec_x && ! form->handle_dec_y )
    {
        fl_get_wingeometry( form->window, &dummy, &form->y, &w, &h );
        form->x -= left;
    }
    else if ( ! form->handle_dec_x && form->handle_dec_y )
    {
        fl_get_wingeometry( form->window, &form->x, &dummy, &w, &h );
        form->y -= bottom;
    }
    else
    {
        fl_get_wingeometry( form->window, &dummy, &dummy, &w, &h );
        form->x -= left;
        form->y -= bottom;
    }

    XMoveWindow( flx->display, form->window, form->x, form->y );
    fl_set_form_size( form, w, h );
}


/***************************************
 * Scale a form with the given scaling factors and take care of object
 * gravity. This one differs from fl_scale_form() in that we don't
 * reshape the window in any way. Most useful as a follow up to a
 * ConfigureNotify event
 ***************************************/

void
fli_scale_form( FL_FORM * form,
                double    xsc,
                double    ysc )
{
    FL_OBJECT *obj;
    double neww = form->w_hr * xsc,
           newh = form->h_hr * ysc;

    if ( ( (   neww - form->w   ) > 0 ? (   neww - form->w   ) : ( - (   neww - form->w   ) ) )  < 1 && ( (   newh - form->h   ) > 0 ? (   newh - form->h   ) : ( - (   newh - form->h   ) ) )  < 1 )
        return;

    form->w_hr = neww;
    form->h_hr = newh;

    form->w = ( ( FL_Coord ) ( (   neww   ) > 0 ? ( (   neww   ) + 0.5 ) : ( (   neww   ) - 0.5 ) ) ) ;
    form->h = ( ( FL_Coord ) ( (   newh   ) > 0 ? ( (   newh   ) + 0.5 ) : ( (   newh   ) - 0.5 ) ) ) ;

    if ( form->hotx >= 0 || form->hoty >= 0 )
    {
        form->hotx = form->hotx * xsc;
        form->hoty = form->hoty * ysc;
    }

    /* Need to handle different resizing request */

    for ( obj = form->first; obj; obj = obj->next )
    {
        double oldw = obj->fl2 - obj->fl1;
        double oldh = obj->ft2 - obj->ft1;

        /* Special case to keep the center of gravity of objects that have
           no gravity set and aren't to be resized */

        if (    obj->resize == FL_RESIZE_NONE
             && obj->segravity == FL_NoGravity
             && obj->nwgravity == FL_NoGravity )
        {
            obj->fl1 += ( xsc - 1 ) * ( obj->fl1 + 0.5 * oldw );
            obj->ft1 += ( ysc - 1 ) * ( obj->ft1 + 0.5 * oldh );
            obj->fr1 = neww - obj->fl1;
            obj->fb1 = newh - obj->ft1;

            obj->fl2 = obj->fl1 + oldw;
            obj->ft2 = obj->ft1 + oldh;
            obj->fr2 = neww - obj->fl2;
            obj->fb2 = newh - obj->ft2;
        }
        else
        {
            /* In all other cases we recalculate the position of the upper left
               hand and the lower right hand corner of the object relative to
               all the borders of the form enclosing it, taking gravity and
               resizing setting into account. The results sometimes can be
               unexpected but hopefully are logically correct;-) */

            if ( (    (   obj   )->nwgravity == FL_NorthWest || (   obj   )->nwgravity == FL_West || (   obj   )->nwgravity == FL_SouthWest )  )
                obj->fr1 = neww - obj->fl1;
            else if ( (    (   obj   )->nwgravity == FL_NorthEast || (   obj   )->nwgravity == FL_East || (   obj   )->nwgravity == FL_SouthEast )  )
                obj->fl1 = neww - obj->fr1;

            if ( (    (   obj   )->segravity == FL_NorthWest || (   obj   )->segravity == FL_West || (   obj   )->segravity == FL_SouthWest )  )
                obj->fr2 = neww - obj->fl2;
            else if ( (    (   obj   )->segravity == FL_NorthEast || (   obj   )->segravity == FL_East || (   obj   )->segravity == FL_SouthEast )  )
                obj->fl2 = neww - obj->fr2;

            if ( ! ( (    (     obj     )->nwgravity == FL_NorthWest || (     obj     )->nwgravity == FL_West || (     obj     )->nwgravity == FL_SouthWest )  || (    (     obj     )->nwgravity == FL_NorthEast || (     obj     )->nwgravity == FL_East || (     obj     )->nwgravity == FL_SouthEast )  )  )
            {
                if ( ( (    (     obj     )->segravity == FL_NorthWest || (     obj     )->segravity == FL_West || (     obj     )->segravity == FL_SouthWest )  || (    (     obj     )->segravity == FL_NorthEast || (     obj     )->segravity == FL_East || (     obj     )->segravity == FL_SouthEast )  )  )
                {
                    if ( obj->resize & FL_RESIZE_X )
                        obj->fl1 = obj->fl2 - xsc * oldw;
                    else
                        obj->fl1 = obj->fl2 - oldw;
                }
                else
                    obj->fl1 *= xsc;
                    
                obj->fr1 = neww - obj->fl1;
            }

            if ( ! ( (    (     obj     )->segravity == FL_NorthWest || (     obj     )->segravity == FL_West || (     obj     )->segravity == FL_SouthWest )  || (    (     obj     )->segravity == FL_NorthEast || (     obj     )->segravity == FL_East || (     obj     )->segravity == FL_SouthEast )  )  )
            {
                if ( obj->resize & FL_RESIZE_X )
                    obj->fl2 = obj->fl1 + xsc * oldw;
                else
                    obj->fl2 = obj->fl1 + oldw;
    
                obj->fr2 = neww - obj->fl2;
            }
            
            if ( (    (   obj   )->nwgravity == FL_NorthWest || (   obj   )->nwgravity == FL_North || (   obj   )->nwgravity == FL_NorthEast )  )
                obj->fb1 = newh - obj->ft1;
            else if ( (    (   obj   )->nwgravity == FL_SouthWest || (   obj   )->nwgravity == FL_South || (   obj   )->nwgravity == FL_SouthEast )  )
                obj->ft1 = newh - obj->fb1;

            if ( (    (   obj   )->segravity == FL_NorthWest || (   obj   )->segravity == FL_North || (   obj   )->segravity == FL_NorthEast )  )
                obj->fb2 = newh - obj->ft2;
            else if ( (    (   obj   )->segravity == FL_SouthWest || (   obj   )->segravity == FL_South || (   obj   )->segravity == FL_SouthEast )  )
                obj->ft2 = newh - obj->fb2;

            if ( ! ( (    (     obj     )->nwgravity == FL_NorthWest || (     obj     )->nwgravity == FL_North || (     obj     )->nwgravity == FL_NorthEast )  || (    (     obj     )->nwgravity == FL_SouthWest || (     obj     )->nwgravity == FL_South || (     obj     )->nwgravity == FL_SouthEast )  )  )
            {
                if ( ( (    (     obj     )->segravity == FL_NorthWest || (     obj     )->segravity == FL_North || (     obj     )->segravity == FL_NorthEast )  || (    (     obj     )->segravity == FL_SouthWest || (     obj     )->segravity == FL_South || (     obj     )->segravity == FL_SouthEast )  )  )
                {
                    if ( obj->resize & FL_RESIZE_Y )
                        obj->ft1 = obj->ft2 - ysc * oldh;
                    else
                        obj->ft1 = obj->ft2 - oldh;
                }
                else
                    obj->ft1 *= ysc;

                obj->fb1 = newh - obj->ft1;
            }

            if ( ! ( (    (     obj     )->segravity == FL_NorthWest || (     obj     )->segravity == FL_North || (     obj     )->segravity == FL_NorthEast )  || (    (     obj     )->segravity == FL_SouthWest || (     obj     )->segravity == FL_South || (     obj     )->segravity == FL_SouthEast )  )  )
            {
                if ( obj->resize & FL_RESIZE_Y )
                    obj->ft2 = obj->ft1 + ysc * oldh;
                else
                    obj->ft2 = obj->ft1 + oldh;
    
                obj->fb2 = newh - obj->ft2;
            }
        }

        obj->x = ( ( FL_Coord ) ( (   obj->fl1   ) > 0 ? ( (   obj->fl1   ) + 0.5 ) : ( (   obj->fl1   ) - 0.5 ) ) ) ;
        obj->y = ( ( FL_Coord ) ( (   obj->ft1   ) > 0 ? ( (   obj->ft1   ) + 0.5 ) : ( (   obj->ft1   ) - 0.5 ) ) ) ;
        obj->w = ( ( FL_Coord ) ( (   obj->fl2 - obj->fl1   ) > 0 ? ( (   obj->fl2 - obj->fl1   ) + 0.5 ) : ( (   obj->fl2 - obj->fl1   ) - 0.5 ) ) ) ;
        obj->h = ( ( FL_Coord ) ( (   obj->ft2 - obj->ft1   ) > 0 ? ( (   obj->ft2 - obj->ft1   ) + 0.5 ) : ( (   obj->ft2 - obj->ft1   ) - 0.5 ) ) ) ;
    }

    /* Only notify objects now - parent objects might have to adjust
       sizes and positions of child objects and when objects get the
       resize notice immediately after resizing above then the parent
       object gets it first, sets a different size for the child, which
       then is overwritten */

    for ( obj = form->first; obj; obj = obj->next )
        fli_handle_object( obj, FL_RESIZED, 0, 0, 0, ((void *)0) , 0 );

    fli_recalc_intersections( form );
}


/***************************************
 * Externally visible routine to scale a form. Needs to reshape the window.
 ***************************************/

void
fl_scale_form( FL_FORM * form,
               double    xsc,
               double    ysc )
{
    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 774 ) ), efp_ ( "fl_scale_form", "NULL form" );
        return;
    }

    if (    ( ( FL_Coord ) ( (   form->w_hr * xsc   ) > 0 ? ( (   form->w_hr * xsc   ) + 0.5 ) : ( (   form->w_hr * xsc   ) - 0.5 ) ) )  == form->w
         && ( ( FL_Coord ) ( (   form->h_hr * ysc   ) > 0 ? ( (   form->h_hr * ysc   ) + 0.5 ) : ( (   form->h_hr * ysc   ) - 0.5 ) ) )  == form->h )
        return;

    fli_scale_form( form, xsc, ysc );

    /* Resize the window */

    if ( form->visible == FL_VISIBLE )
        fl_winresize( form->window, form->w, form->h );
}


/***************************************
 * Sets lower limits for the width and height of a form
 ***************************************/

void
fl_set_form_minsize( FL_FORM * form,
                     FL_Coord  w,
                     FL_Coord  h )
{
    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 802 ) ), efp_ ( "fl_set_form_minsize", "Null form" );
        return;
    }

    fl_winminsize( form->window, w, h );
}


/***************************************
 * Sets upper limits for the width and height of a form
 ***************************************/

void
fl_set_form_maxsize( FL_FORM * form,
                     FL_Coord  w,
                     FL_Coord  h )
{
    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 821 ) ), efp_ ( "fl_set_form_maxsize", "NULL form" );
        return;
    }

    fl_winmaxsize( form->window, w, h );
}


/***************************************
 * Switches double buffering for forms on or off (with double buffering
 * on we draw first to a pixmap for the form before copying that to the
 * forms window - can reduces flickering)
 ***************************************/

void
fl_set_form_dblbuffer( FL_FORM * form,
                       int       yesno )
{
    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 841 ) ), efp_ ( "fl_set_form_dblbuffer", "NULL form" );
        return;
    }

    if ( form->use_pixmap == yesno )
        return;

    /* If the form is currently frozen the redraw on unfreeze will only
       draw those objects that have been changed and thus have their
       'redraw' flag set. But when switching double buffering on there's
       no pixmap yet that already contains the non-modified objects. Thus
       in this case we must make sure all objects of the form get redrawn. */

    if ( yesno && form->frozen )
        form->needs_full_redraw = 1;

    form->use_pixmap = yesno;
}


/***************************************
 * Sets the size of a form
 ***************************************/

void
fl_set_form_size( FL_FORM * form,
                  FL_Coord  w,
                  FL_Coord  h )
{
    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 872 ) ), efp_ ( "fl_set_form_size", "NULL form" );
        return;
    }

    if ( w != form->w || h != form->h )
        fl_scale_form( form, w / form->w_hr, h / form->h_hr );
}


/***************************************
 * Sets the position of a form
 ***************************************/

void
fl_set_form_position( FL_FORM * form,
                      FL_Coord  x,
                      FL_Coord  y )
{
    FL_Coord oldx,
             oldy;

    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 895 ) ), efp_ ( "fl_set_form_position", "NULL form" );
        return;
    }

    oldx = form->x;
    oldy = form->y;

    /* Negative values for x or y are interpreted as meaning that the
       position is that of the right or bottom side of the form relative
       to the right or bottom side to the screen. May have to be corrected
       for the right or bottom border decoration widths. */

    if ( x >= 0 )
    {
        form->x = x;
        form->handle_dec_x = 0;
    }
    else
    {
        form->x = fl_scrw - form->w + x;
        form->handle_dec_x = 1;
    }

    if ( y >= 0 )
    {
        form->y = y;
        form->handle_dec_y = 0;
    }
    else
    {
        form->y = fl_scrh - form->h + y;
        form->handle_dec_y = 1;
    }

    /* If the form is already shown move it */

    if ( form->visible == FL_VISIBLE )
    {
        int bottom = 0,
            left = 0,
            dummy;

        if (    ( form->handle_dec_x || form->handle_dec_y )
             && form->wm_border != FL_NOBORDER )
        {
            fl_get_decoration_sizes( form, &dummy, &dummy, &bottom, &left );

            if ( form->handle_dec_x )
                form->x -= left;

            if ( form->handle_dec_y )
                form->y -= bottom;
        }

        form->handle_dec_x = form->handle_dec_y = 0;

        if ( oldx != form->x || oldy != form->y )
            XMoveWindow( flx->display, form->window, form->x, form->y );
    }
}


/***************************************
 * Sets the background color of the form - a bit of a hack since it
 * actually uses the first or second object of the form...
 ***************************************/

void
fl_set_form_background_color( FL_FORM * form,
                              FL_COLOR  color )
{
    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 968 ) ), efp_ ( "fl_set_forms_background_color", "NULL form" );
        return;
    }

    /* If the empty box that all forms get as their first object on creation
       does not exist anymore we can't set a background color */

    if ( ! form->first )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 977 ) ), efp_ ( "fl_set_forms_background_color", "Form has no background" );
        return;
    }

    /* If there's no other object except the empty box or the first object
       isn't an empty box anymore set the color for this first object, otherwise
       for the next object. */

    if ( ! form->first->next || form->first->boxtype != FL_NO_BOX )
        fl_set_object_color( form->first, color, form->first->col2 );
    else
        fl_set_object_color( form->first->next, color,
                             form->first->next->col2 );
}


/***************************************
 * Returns the background color used for the form
 ***************************************/

FL_COLOR
fl_get_form_background_color( FL_FORM * form )
{
    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1002 ) ), efp_ ( "fl_get_forms_background_color", "NULL form" );
        return FL_COL1;
    }

    /* If the empty box that all forms get as their first object on creation
       does not exist anymore we can't set a background color */

    if ( ! form->first )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1011 ) ), efp_ ( "fl_get_forms_background_color", "Form has no background" );
        return FL_COL1;
    }

    if ( form->first->boxtype != FL_NO_BOX || ! form->first->next )
        return form->first->col1;
    else
        return form->first->next->col1;
}


/***************************************
 * Sets the position of the hotspot of a form
 ***************************************/

void
fl_set_form_hotspot( FL_FORM * form,
                     FL_Coord  x,
                     FL_Coord  y )
{
    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1033 ) ), efp_ ( "fl_set_form_hotspot", "NULL form" );
        return;
    }

    form->hotx = x;
    form->hoty = y;
}


/***************************************
 * Sets the position of the hotspot of a form
 * to the center of one of its objects
 ***************************************/

void
fl_set_form_hotobject( FL_FORM   * form,
                       FL_OBJECT * obj )
{
    if ( ! form  )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1053 ) ), efp_ ( "fl_set_form_hotobject", "NULL form" );
        return;
    }

    if ( ! obj )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1059 ) ), efp_ ( "fl_set_form_hotobject", "NULL object" );
        return;
    }

    if ( obj->form != form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1065 ) ), efp_ ( "fl_set_form_hotobject", "Object not part of form" );
        return;
    }

    fl_set_form_hotspot( form, obj->x + obj->w / 2, obj->y + obj->h / 2 );
}


/***************************************
 * Try to make sure a form is completely visible on the screen
 ***************************************/

static void
force_visible( FL_FORM * form )
{
    if ( form->x > fl_scrw - form->w )
        form->x = fl_scrw - form->w;

    if ( form->x < 0 )
        form->x = 0;

    if ( form->y > fl_scrh - form->h )
        form->y = fl_scrh - form->h;

    if ( form->y < 0 )
        form->y = 0;
}


/***************************************
 * Sets the name (label) of the form. If the form
 * is shown it's also the form's window title.
 ***************************************/

void
fl_set_form_title( FL_FORM *    form,
                   const char * name )
{
    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1105 ) ), efp_ ( "fl_set_form_title", "NULL form" );
        return;
    }

    if ( form->label != name )
    {
        if ( form->label )
            fl_free( form->label );
        form->label = fl_strdup( name ? name : "" );
    }

    if ( form->window )
        fl_wintitle( form->window, form->label );
}


/***************************************
 * Sets the name (label) of the form using a format string
 ***************************************/

void
fl_set_form_title_f( FL_FORM *    form,
                     const char * fmt,
                     ... )
{
    char *buf;

    do { if ( !   fmt   || ! *  fmt   )   buf  = ((void *)0) ; else if ( ! strchr(   fmt  , '%' ) ) { if ( (   buf  = fl_malloc( strlen(   fmt   ) + 1 ) ) ) strcpy(   buf ,   fmt   ); } else { int l1I_min_needed = strlen(   fmt   ) + 1; int l1I_len = l1I_min_needed; char *l1I_p; for ( l1I_p = strchr(   fmt  , '%' ); l1I_p; l1I_p = strchr( ++l1I_p, '%' ) ) l1I_len += 16; if ( (   buf  = fl_malloc( l1I_len ) ) ) { while ( 1 ) { va_list l1I_ap; int l1I_written; __builtin_va_start(  l1I_ap ,    fmt    ) ; l1I_written = fli_portable_vsnprintf (   buf , l1I_len,   fmt  , l1I_ap ); __builtin_va_end(  l1I_ap  ) ; if ( l1I_written > -1 && l1I_len > l1I_written ) { if ( l1I_len != l1I_written + 1 ) { l1I_p =   buf ; if ( ! (   buf  = fl_realloc( l1I_p, l1I_written + 1 ) ) )   buf  = l1I_p; } break; } l1I_len = l1I_written < 0 ? ( 2 * l1I_len ) : ( l1I_written + 16 ); l1I_p =   buf ; if ( ! (   buf  = fl_realloc( l1I_p, l1I_len ) ) ) { fl_free( l1I_p ); break; } } } } if ( !   buf  && (   buf  = fl_malloc( 1 ) ) ) *  buf  = '\0'; } while ( 0 ) ;
    fl_set_form_title( form, buf );
    fl_free( buf );
}   


/***************************************
 * Creates the window for a form (but doesn't show it yet, use
 * fl_show_form_window() for that), returns the window handle
 ***************************************/

Window
fl_prepare_form_window( FL_FORM    * form,
                        int          place,
                        int          border,
                        const char * name )
{
    long screenw,
         screenh,
         dont_fix_size = 0;
    FL_Coord mx,
             my;

    if ( border == 0 )
        border = FL_FULLBORDER;

    if ( fl_current_form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1160 ) ), efp_ ( "fl_prepare_form_window", "You forgot to call fl_end_form() %s",
               name ? name : "" );
        fl_current_form = ((void *)0) ;
    }

    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1167 ) ), efp_ ( "fl_prepare_form", "NULL form" );
        return 0L ;
    }

    if ( form->visible != FL_INVISIBLE )
        return form->window;

    /* Try to move the form from the part of the list for hidden forms to
       that at the start for visible forms */

    move_form_to_visible_list( form );

    if ( form->label != name )
    {
        if ( form->label )
            fl_free( form->label );
        form->label = fl_strdup( name ? name : "" );
    }

    if ( border == FL_NOBORDER )
        fli_int.unmanaged_count++;

    form->wm_border = border;
    form->deactivated = 0;
    screenw = fl_scrw;
    screenh = fl_scrh;

    fl_get_mouse( &mx, &my, &fli_int.keymask );

    if ( ( dont_fix_size = place & FL_FREE_SIZE ) )
        place &= ~ FL_FREE_SIZE;

    if ( place == FL_PLACE_SIZE )
        fl_winsize ( form->w, form->h );
    else if ( place == FL_PLACE_ASPECT )
        fl_winaspect( 0, form->w, form->h );
    else if ( place == FL_PLACE_POSITION )
    {
        fl_winposition ( form->x, form->y );
        fl_initial_winsize( form->w, form->h );
    }
    else if ( place != FL_PLACE_FREE )
    {
        FL_Coord  nmx,
                 nmy;

        switch ( place )
        {
            case FL_PLACE_CENTER:
            case ( FL_PLACE_CENTER | FL_FREE_SIZE ) :
                form->x = ( screenw - form->w ) / 2;
                form->y = ( screenh - form->h ) / 2;
                break;

            case FL_PLACE_MOUSE:
                form->x = mx - form->w / 2;
                form->y = my - form->h / 2;
                break;

            case FL_PLACE_FULLSCREEN:
                form->x = 0;
                form->y = 0;
                fl_set_form_size( form, screenw, screenh );
                break;

            case FL_PLACE_HOTSPOT:
                if ( form->hotx < 0 || form->hoty < 0 )    /* not set */
                {
                    form->hotx = form->w / 2;
                    form->hoty = form->h / 2;
                }

                form->x = mx - form->hotx;
                form->y = my - form->hoty;

                force_visible( form );

                nmx = form->x + form->hotx;
                nmy = form->y + form->hoty;

                if ( nmx != mx || nmy != my )
                    fl_set_mouse( nmx, nmy );

                break;

            case FL_PLACE_GEOMETRY :
                if ( form->x < 0 )
                {
                    form->x = screenw - form->w + form->x;
                    form->handle_dec_x = 1;
                }
                if ( form->y < 0 )
                {
                    form->y = screenh - form->h + form->y;
                    form->handle_dec_y = 1;
                }
                break;
        }

        /* Final check. Make sure form is visible */

        if ( place != FL_PLACE_GEOMETRY )
            force_visible( form );

        if ( dont_fix_size && place != FL_PLACE_GEOMETRY )
            fl_initial_wingeometry( form->x, form->y, form->w, form->h );
        else
            fl_wingeometry ( form->x, form->y, form->w, form->h );
    }
    else if ( place == FL_PLACE_FREE )
    {
        fl_initial_winsize( form->w, form->h );
        if ( has_initial )
            fl_initial_wingeometry( form->x, form->y, form->w, form->h );
    }
    else
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1284 ) ), efp_ ( "fl_prepare_form_window", "Unknown requests: %d", place );
        fl_initial_wingeometry( form->x, form->y, form->w, form->h );
    }

    /* Window managers typically do not allow dragging transient windows */

    if ( border != FL_FULLBORDER )
    {
        if ( place == FL_PLACE_ASPECT || place == FL_PLACE_FREE )
        {
            form->x = mx - form->w / 2;
            form->y = my - form->h / 2;
            force_visible( form );
            fl_winposition  ( form->x, form->y );
        }

        if ( border == FL_NOBORDER )
            fl_noborder( );
        else
            fl_transient( );
    }

    if ( place == FL_PLACE_ICONIC )
        fl_initial_winstate( 3  );
    if ( form->icon_pixmap )
        fl_winicon( 0, form->icon_pixmap, form->icon_mask );

    has_initial = 0;
    fli_init_colormap( fl_vmode );

    form->window = fli_create_window( fl_root, fl_state[   fl_vmode   ].colormap , name );
    fl_winicontitle( form->window, name );

    if ( border == FL_FULLBORDER || form->prop & FLI_COMMAND_PROP )
        set_form_property( form, FLI_COMMAND_PROP );

    return form->window;
}


/***************************************
 ***************************************/

Window
fl_prepare_form_window_f( FL_FORM    * form,
                          int          place,
                          int          border,
                          const char * fmt,
                          ... )
{
    Window w;
    char *buf;

    do { if ( !   fmt   || ! *  fmt   )   buf  = ((void *)0) ; else if ( ! strchr(   fmt  , '%' ) ) { if ( (   buf  = fl_malloc( strlen(   fmt   ) + 1 ) ) ) strcpy(   buf ,   fmt   ); } else { int l1I_min_needed = strlen(   fmt   ) + 1; int l1I_len = l1I_min_needed; char *l1I_p; for ( l1I_p = strchr(   fmt  , '%' ); l1I_p; l1I_p = strchr( ++l1I_p, '%' ) ) l1I_len += 16; if ( (   buf  = fl_malloc( l1I_len ) ) ) { while ( 1 ) { va_list l1I_ap; int l1I_written; __builtin_va_start(  l1I_ap ,    fmt    ) ; l1I_written = fli_portable_vsnprintf (   buf , l1I_len,   fmt  , l1I_ap ); __builtin_va_end(  l1I_ap  ) ; if ( l1I_written > -1 && l1I_len > l1I_written ) { if ( l1I_len != l1I_written + 1 ) { l1I_p =   buf ; if ( ! (   buf  = fl_realloc( l1I_p, l1I_written + 1 ) ) )   buf  = l1I_p; } break; } l1I_len = l1I_written < 0 ? ( 2 * l1I_len ) : ( l1I_written + 16 ); l1I_p =   buf ; if ( ! (   buf  = fl_realloc( l1I_p, l1I_len ) ) ) { fl_free( l1I_p ); break; } } } } if ( !   buf  && (   buf  = fl_malloc( 1 ) ) ) *  buf  = '\0'; } while ( 0 ) ;
    w = fl_prepare_form_window( form, place, border, buf );
    fl_free( buf );
    return w;
}


/***************************************
 * Maps (displays) a form's window created with fl_prepare_form_window()
 ***************************************/

Window
fl_show_form_window( FL_FORM * form )
{
    FL_OBJECT *obj;

    if ( ! form  )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1355 ) ), efp_ ( "fl_show_form_window", "NULL form" );
        return 0L ;
    }

    if ( form->window == 0L  || form->visible != FL_INVISIBLE )
        return form->window;

    fl_winshow( form->window );
    form->visible = FL_VISIBLE;
    reshape_form( form );
    fl_redraw_form( form );

    /* TODO: somehow formbrowser objects get drawn incorrectly the first
       time round so, for the time being, we redraw it once again... */

    for ( obj = form->first; obj; obj = obj->next )
        if ( obj->objclass == FL_FORMBROWSER )
            fl_redraw_object( obj );

    if ( ! form->focusobj )
        for ( obj = form->first; obj; obj = obj->next )
            if ( obj->input && obj->active )
            {
                fl_set_focus_object( form, obj );
                break;
            }

    return form->window;
}


/***************************************
 * Makes a new form visible by creating a window for it
 * and mapping it. Returns the form's window handle.
 ***************************************/

Window
fl_show_form( FL_FORM *    form,
              int          place,
              int          border,
              const char * name )
{
    if ( ! form  )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1399 ) ), efp_ ( "fl_show_form", "NULL form" );
        return 0L ;
    }

    fl_prepare_form_window( form, place, border, name );
    form->in_redraw = 0;
    return fl_show_form_window( form );
}


/***************************************
 ***************************************/

Window
fl_show_form_f( FL_FORM    * form,
                int          place,
                int          border,
                const char * fmt,
                ... )
{
    Window w;
    char *buf;

    do { if ( !   fmt   || ! *  fmt   )   buf  = ((void *)0) ; else if ( ! strchr(   fmt  , '%' ) ) { if ( (   buf  = fl_malloc( strlen(   fmt   ) + 1 ) ) ) strcpy(   buf ,   fmt   ); } else { int l1I_min_needed = strlen(   fmt   ) + 1; int l1I_len = l1I_min_needed; char *l1I_p; for ( l1I_p = strchr(   fmt  , '%' ); l1I_p; l1I_p = strchr( ++l1I_p, '%' ) ) l1I_len += 16; if ( (   buf  = fl_malloc( l1I_len ) ) ) { while ( 1 ) { va_list l1I_ap; int l1I_written; __builtin_va_start(  l1I_ap ,    fmt    ) ; l1I_written = fli_portable_vsnprintf (   buf , l1I_len,   fmt  , l1I_ap ); __builtin_va_end(  l1I_ap  ) ; if ( l1I_written > -1 && l1I_len > l1I_written ) { if ( l1I_len != l1I_written + 1 ) { l1I_p =   buf ; if ( ! (   buf  = fl_realloc( l1I_p, l1I_written + 1 ) ) )   buf  = l1I_p; } break; } l1I_len = l1I_written < 0 ? ( 2 * l1I_len ) : ( l1I_written + 16 ); l1I_p =   buf ; if ( ! (   buf  = fl_realloc( l1I_p, l1I_len ) ) ) { fl_free( l1I_p ); break; } } } } if ( !   buf  && (   buf  = fl_malloc( 1 ) ) ) *  buf  = '\0'; } while ( 0 ) ;
    w = fl_show_form( form, place, border, buf );
    fl_free( buf );
    return w;
}


/***************************************
 * Hides a particular form by unmapping and destroying its window
 ***************************************/

static void
close_form_window( Window win )
{
    XEvent xev;

    XUnmapWindow( flx->display, win );
    XDestroyWindow( flx->display, win );
    XSync( flx->display, 0 );

    while ( XCheckWindowEvent( flx->display, win, ( ( (1L<<24)  << 1 ) - 1 ) , &xev ) )
        fli_xevent_name( "Eaten", &xev );

    /* Give subwindows a chance to handle destroy event promptly, take care
       the window of the form doesn't exist anymore! */

    while ( XCheckTypedEvent( flx->display, 17 , &xev ) )
    {
        FL_FORM *form;

        if ( ( form = fli_find_event_form( &xev ) ) )
        {
            form->window = 0L ;
            fl_hide_form( form );
        }
        else
            fl_XPutBackEvent( &xev );
    }
}


/***************************************
 ***************************************/

static FL_FORM *
property_set( unsigned int prop )
{
    int i;

    for ( i = 0; i < fli_int.formnumb; i++ )
        if (    fli_int.forms[ i ]->prop & prop
             && fli_int.forms[ i ]->prop & FLI_PROP_SET )
            return fli_int.forms[ i ];

    return ((void *)0) ;
}


/***************************************
 ***************************************/

static void
set_form_property( FL_FORM *    form,
                   unsigned int prop )
{
    if ( ! form  )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1489 ) ), efp_ ( "set_form_property", "NULL form" );
        return;
    }

    if ( property_set( prop ) )
        return;

    if ( ! ( prop & FLI_COMMAND_PROP ) )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1498 ) ), efp_ ( "set_form_property", "Unknown form property request %u",
               prop );
        return;
    }

    if ( form->window )
    {
        fli_set_winproperty( form->window, FLI_COMMAND_PROP );
        form->prop |= FLI_PROP_SET;
    }

    form->prop |= FLI_COMMAND_PROP;
    fli_mainform = form;
}


/***************************************
 ***************************************/

void
fl_hide_form( FL_FORM * form )
{
    Window owin;
    FL_OBJECT *o;

    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1525 ) ), efp_ ( "fl_hide_form", "NULL form" );
        return;
    }

    if ( fli_get_visible_forms_index( form ) < 0 )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1531 ) ), efp_ ( "fl_hide_form", "Hiding unknown form" );
        return;
    }

    if ( form->visible == FL_BEING_HIDDEN )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1537 ) ), efp_ ( "fl_hide_form", "Recursive call?" );
        return;
    }

    form->visible = FL_BEING_HIDDEN;
    fli_set_form_window( form );

    /* Checking mouseobj->form is necessary as it might be deleted from a
       form */

    if ( fli_int.mouseobj && fli_int.mouseobj->form == form )
    {
        fli_handle_object( fli_int.mouseobj, FL_LEAVE, 0, 0, 0, ((void *)0) , 1 );
        fli_int.mouseobj = ((void *)0) ;
    }

    if ( fli_int.pushobj && fli_int.pushobj->form == form )
    {
        fli_handle_object( fli_int.pushobj, FL_RELEASE, 0, 0, 0, ((void *)0) , 1 );
        fli_int.pushobj = ((void *)0) ;
    }

    if ( form->focusobj )
    {
        fli_handle_object( form->focusobj, FL_UNFOCUS, 0, 0, 0, ((void *)0) , 0 );
        form->focusobj = ((void *)0) ;
    }

    /* Get canvas objects to unmap their windows (but only for those that
       aren't childs, those will be dealt with by their parents) */

    for ( o = form->first; o; o = o->next )
        if (    ( o->objclass == FL_CANVAS || o->objclass == FL_GLCANVAS )
             && ! o->parent )
            fli_unmap_canvas_window( o );


    fli_object_qflush( form );


    /* Free backing store pixmap but keep the pointer */

    fli_free_flpixmap( form->flpixmap );

    if ( fli_int.mouseform && fli_int.mouseform->window == form->window )
        fli_int.mouseform = ((void *)0) ;

    form->deactivated = 1;
    form->visible = FL_INVISIBLE;
    owin = form->window;
    form->window = 0L ;

    fli_hide_tooltip( );

    /* If the forms window is None it already has been closed */

    if ( owin )
        close_form_window( owin );

    if ( flx->win == owin )
        flx->win = 0L ;

    /* Move the form from the part of the list for visible forms to the
       part of hidden forms at the end of the array */

    move_form_to_hidden_list( form );

    if ( form->wm_border == FL_NOBORDER )
    {
        fli_int.unmanaged_count--;
        if ( fli_int.unmanaged_count < 0 )
        {
            ( efp_ = fli_error_setup( -1 ,   "forms.c", 1609 ) ), efp_ ( "fl_hide_form", "Bad unmanaged count" );
            fli_int.unmanaged_count = 0;
        }
    }

    /* Need to re-establish command property */

    if ( fli_int.formnumb && form->prop & FLI_COMMAND_PROP )
        set_form_property( *fli_int.forms, FLI_COMMAND_PROP );

    if ( form == fli_int.keyform )
        fli_int.keyform = ((void *)0) ;
}


/***************************************
 * Frees the memory used by a form, together with all its objects.
 ***************************************/

void
fl_free_form( FL_FORM * form )
{
    /* Check whether ok to free */

    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1635 ) ), efp_ ( "fl_free_form", "NULL form" );
        return;
    }

    if ( form->visible == FL_VISIBLE )
    {
        ( efp_ = fli_error_setup( 0 ,  "forms.c", 1641 ) ), efp_ ( "fl_free_form", "Freeing visible form" );
        fl_hide_form( form );
    }

    if ( get_hidden_forms_index( form ) < 0 )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1647 ) ), efp_ ( "fl_free_form", "Freeing unknown form" );
        return;
    }

    /* Free all objects of the form */

    fli_fast_free_object = form;

    while ( form->first )
        fl_free_object( form->first );

    fli_fast_free_object = ((void *)0) ;

    if ( form->flpixmap )
    {
        fli_free_flpixmap( form->flpixmap );
        fl_free( form->flpixmap );
    }

    if ( form->label )
    {
        fl_free( form->label );
        form->label = ((void *)0) ;
    }

    if ( form == fli_mainform )
        fli_mainform = ((void *)0) ;

    /* Free the form and remove it from the list of existing forms */

    fl_free( form );

    remove_form_from_hidden_list( form );
}


/***************************************
 * Returns if a form is active
 ***************************************/

int
fl_form_is_activated( FL_FORM * form )
{
    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1692 ) ), efp_ ( "fl_form_is_activated", "NULL form" );
        return 0;
    }

    return form->deactivated == 0;
}


/***************************************
 * Activates a form (form only becomes activated if this function has
 * been called as many times as fl_deactive_form()).
 ***************************************/

void
fl_activate_form( FL_FORM * form )
{
    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1710 ) ), efp_ ( "fl_activate_form", "NULL form" );
        return;
    }

    if ( form->deactivated )
    {
        form->deactivated--;

        if ( ! form->deactivated && form->activate_callback )
            form->activate_callback( form, form->activate_data );
    }

    if ( form->child )
        fl_activate_form( form->child );
}


/***************************************
 * Deactivates a form (re-activation requires as many calls of
 * fl_activate_form() as there were calls of fl_deactivate_form()).
 ***************************************/

void
fl_deactivate_form( FL_FORM * form )
{
    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1737 ) ), efp_ ( "fl_deactivate_form", "NULL form" );
        return;
    }

    if (    ! form->deactivated
         && fli_int.mouseobj
         && fli_int.mouseobj->form == form )
        fli_handle_object( fli_int.mouseobj, FL_LEAVE, 0, 0, 0, ((void *)0) , 1 );

    if ( ! form->deactivated && form->deactivate_callback )
        form->deactivate_callback( form, form->deactivate_data );

    form->deactivated++;

    if ( form->child )
        fl_deactivate_form( form->child );
}


/***************************************
 * Installs handler to be called on (final) re-activation of the form
 ***************************************/

FL_FORM_ATACTIVATE
fl_set_form_atactivate( FL_FORM            * form,
                        FL_FORM_ATACTIVATE   cb,
                        void *               data )
{
    FL_FORM_ATACTIVATE old = ((void *)0) ;

    if ( ! form  )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1769 ) ), efp_ ( "fl_set_form_atactivate", "NULL form" );
        return ((void *)0) ;
    }

    old = form->activate_callback;
    form->activate_callback = cb;
    form->activate_data = data;

    return old;
}


/***************************************
 * Installs handler to be called on (first) deactivation of the form
 ***************************************/

FL_FORM_ATDEACTIVATE
fl_set_form_atdeactivate( FL_FORM              * form,
                          FL_FORM_ATDEACTIVATE   cb,
                          void                 * data )
{
    FL_FORM_ATDEACTIVATE old = ((void *)0) ;

    if ( ! form  )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1794 ) ), efp_ ( "fl_set_form_atdeactivate", "NULL form" );
        return ((void *)0) ;
    }

    old = form->deactivate_callback;
    form->deactivate_callback = cb;
    form->deactivate_data = data;

    return old;
}


/***************************************
 * Activates all forms
 ***************************************/

void
fl_activate_all_forms( void )
{
    int i;

    for ( i = 0; i < fli_int.formnumb; i++ )
        fl_activate_form( fli_int.forms[ i ] );
}


/***************************************
 * Deactivates all forms
 ***************************************/

void
fl_deactivate_all_forms( void )
{
    int i;

    for ( i = 0; i < fli_int.formnumb; i++ )
        fl_deactivate_form( fli_int.forms[ i ] );
}


/***************************************
 * Installs handler to be called on close of the form
 ***************************************/

FL_FORM_ATCLOSE
fl_set_form_atclose( FL_FORM         * form,
                     FL_FORM_ATCLOSE   fmclose,
                     void            * data )
{
    FL_FORM_ATCLOSE old;

    if ( ! form  )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1847 ) ), efp_ ( "fl_set_form_atclose", "NULL form" );
        return ((void *)0) ;
    }

    old = form->close_callback;
    form->close_callback = fmclose;
    form->close_data = data;

    return old;
}


/***************************************
 * Installs handler to be called on end of application by the user
 * using some window manager method to close a window
 ***************************************/

FL_FORM_ATCLOSE
fl_set_atclose( FL_FORM_ATCLOSE   fmclose,
                void            * data )
{
    FL_FORM_ATCLOSE old = fli_context->atclose;

    fli_context->atclose = fmclose;
    fli_context->close_data = data;

    return old;
}


/***************************************
 ***************************************/

void
fl_set_form_geometry( FL_FORM  * form,
                      FL_Coord   x,
                      FL_Coord   y,
                      FL_Coord   w,
                      FL_Coord   h )
{
    fl_set_form_position( form, x, y );
    fl_set_form_size( form, w, h );

    /* This alters the windowing defaults */

    fl_initial_wingeometry( form->x, form->y, form->w, form->h );
    has_initial = 1;
}


/***************************************
 * Register pre-emptive event handlers
 ***************************************/

FL_RAW_CALLBACK
fl_register_raw_callback( FL_FORM         * form,
                          unsigned long     mask,
                          FL_RAW_CALLBACK   rcb )
{
    FL_RAW_CALLBACK old_rcb = ((void *)0) ;
    int valid = 0;

    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1911 ) ), efp_ ( "fl_register_raw_callback", "Null form" );
        return ((void *)0) ;
    }

    if ( ( mask & (   (1L<<0)  | (1L<<1)  | (1L<<2)  | (1L<<3)  | (1L<<4)  | (1L<<5)  | (1L<<13)  | (1L<<6)  )  ) == (   (1L<<0)  | (1L<<1)  | (1L<<2)  | (1L<<3)  | (1L<<4)  | (1L<<5)  | (1L<<13)  | (1L<<6)  )  )
    {
        old_rcb = form->all_callback;
        form->evmask = mask;
        form->all_callback = rcb;
        return old_rcb;
    }

    if ( mask & ( (1L<<0)  | (1L<<1)  ) )
    {
        form->evmask |= mask & ( (1L<<0)  | (1L<<1)  );
        old_rcb = form->key_callback;
        form->key_callback = rcb;
        valid = 1;
    }

    if ( mask & ( (1L<<2)  | (1L<<3)  ) )
    {
        form->evmask |= mask & ( (1L<<2)  | (1L<<3)  );
        old_rcb = form->push_callback;
        form->push_callback = rcb;
        valid = 1;
    }

    if ( mask & ( (1L<<4)  | (1L<<5)  ) )
    {
        form->evmask |= mask & ( (1L<<4)  | (1L<<5)  );
        old_rcb = form->crossing_callback;
        form->crossing_callback = rcb;
        valid = 1;
    }

    if ( mask & ( (1L<<13)  | (1L<<6)  ) )
    {
        form->evmask |= mask & ( (1L<<13)  | (1L<<6)  );
        old_rcb = form->motion_callback;
        form->motion_callback = rcb;
        valid = 1;
    }

    if ( ! valid )          /* unsupported mask */
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1956 ) ), efp_ ( "fl_register_raw_callback", "Unsupported mask 0x%x", mask );

    return old_rcb;
}


/***************************************
 ***************************************/

void
fl_set_form_event_cmask( FL_FORM *     form,
                         unsigned long cmask )
{
    if ( form )
        form->compress_mask = cmask;
}


/***************************************
 ***************************************/

unsigned long
fl_get_form_event_cmask( FL_FORM * form )
{
    return form ? form->compress_mask : 0UL;
}


/***************************************
 * Sets the callback routine for the form
 ***************************************/

void
fl_set_form_callback( FL_FORM            * form,
                      FL_FORMCALLBACKPTR   callback,
                      void *               d )
{
    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 1995 ) ), efp_ ( "fl_set_form_callback", "NULL form" );
        return;
    }

    form->form_callback = callback;
    form->form_cb_data = d;
}


/***************************************
 ***************************************/

void
fl_set_form_icon( FL_FORM * form,
                  Pixmap    p,
                  Pixmap    m )
{
    if ( ! form )
        return;

    form->icon_pixmap = p;
    form->icon_mask = m;
    if ( form->window )
        fl_winicon( form->window, p, m );
}


/***************************************
 ***************************************/

void
fl_set_app_mainform( FL_FORM * form )
{
    fli_mainform = form;
    set_form_property( form, FLI_COMMAND_PROP );
}


/***************************************
 ***************************************/

FL_FORM *
fl_get_app_mainform( void )
{
    return nomainform ? ((void *)0)  : fli_mainform;
}


/***************************************
 ***************************************/

void
fl_set_app_nomainform( int flag )
{
    nomainform = flag;
}


/***************************************
 * Does a rescale of a form without taking into
 * account object gravity or resize settings
 ***************************************/

static void
simple_form_rescale( FL_FORM * form,
                     double    scale )
{
    FL_OBJECT *obj;

    form->w_hr *= scale;
    form->h_hr *= scale;

    form->w = ( ( FL_Coord ) ( (   form->w_hr   ) > 0 ? ( (   form->w_hr   ) + 0.5 ) : ( (   form->w_hr   ) - 0.5 ) ) ) ;
    form->h = ( ( FL_Coord ) ( (   form->h_hr   ) > 0 ? ( (   form->h_hr   ) + 0.5 ) : ( (   form->h_hr   ) - 0.5 ) ) ) ;

    for ( obj = form->first; obj; obj = obj->next )
        if ( obj->objclass != 10000  && obj->objclass != 20000  )
            fli_scale_object( obj, scale, scale );

    fli_recalc_intersections( form );

    fl_redraw_form( form );
}


/***************************************
 * Checks if the label of an object fits into it (after x- and
 * y-margin have been added). If not, all objects and the form
 * are enlarged by the necessary factor (but never by more than
 * a factor of 1.5).
 ***************************************/

void
fl_fit_object_label( FL_OBJECT * obj,
                     FL_Coord    xmargin,
                     FL_Coord    ymargin )
{
    int sw,
        sh,
        osize,
        bw;
    double factor,
           xfactor,
           yfactor;

    if ( fli_no_connection )
        return;

    if (    fl_is_outside_lalign( obj->align )
         || obj->type == 10000 
         || obj->type == 20000 
         || obj->parent
         || ! obj->label
         || ! *obj->label
         || *obj->label == '@' )
        return;

    fl_get_string_dimension( obj->lstyle, obj->lsize, obj->label,
                             strlen( obj->label ), &sw, &sh );

    bw = (    obj->boxtype == FL_UP_BOX
           || obj->boxtype == FL_DOWN_BOX
           || obj->boxtype == FL_EMBOSSED_BOX ) ?
        ( (   obj->bw   ) > 0 ? (   obj->bw   ) : ( - (   obj->bw   ) ) )  : 1;

    if (    obj->boxtype == FL_EMBOSSED_BOX )
        bw += bw > 2 ? bw - 2 : 1;

    if (    obj->objclass == FL_BUTTON
          && (    obj->type == FL_RETURN_BUTTON
               || obj->type == FL_MENU_BUTTON ) )
        sw += ( (   0.6 * obj->h  ) < (   0.6 * obj->w   ) ? (   0.6 * obj->h  ) : (   0.6 * obj->w   ) )  - 1;

    if ( obj->objclass == FL_BUTTON && obj->type == FL_LIGHTBUTTON )
        sw += ( ( FL_Coord ) 12 )  + 1;

    if (    sw <= obj->w - 2 * ( bw + xmargin )
         && sh <= obj->h - 2 * ( bw + ymargin ) )
        return;

    if ( ( osize = obj->w - 2 * ( bw + xmargin ) ) <= 0 )
        osize = 1;
    xfactor = ( double ) sw / osize;

    if ( ( osize = obj->h - 2 * ( bw + ymargin ) ) <= 0 )
        osize = 1;
    yfactor = ( double ) sh / osize;

    factor = ( (   xfactor  ) > (   yfactor   ) ? (   xfactor  ) : (   yfactor   ) ) ;

    factor = ( (   factor  ) < (   1.0  ) ? (   1.0  ) : ( (   factor  ) > (   1.5   ) ? (   1.5   ) : (   factor  ) ) ) ;

    /* Scale all objects without taking care of gravity etc. */

    if ( factor > 1.0 )
        simple_form_rescale( obj->form, factor );
}


/***************************************
 ***************************************/

void
fli_recount_auto_objects( void )
{
    int i;

    for ( fli_int.auto_count = i = 0; i < fli_int.formnumb; i++ )
        if ( fli_int.forms[ i ]->num_auto_objects > 0 )
            fli_int.auto_count++;
}


/***************************************
 * Reopens a group to allow addition of further objects
 ***************************************/

FL_OBJECT *
fl_addto_group( FL_OBJECT * group )
{
    if ( ! group )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 2177 ) ), efp_ ( "fl_addto_group", "NULL group." );
        return ((void *)0) ;
    }

    if ( group->objclass != 10000  )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 2183 ) ), efp_ ( "fl_addto_group", "Parameter is not a group object." );
        return ((void *)0) ;
    }

    if ( fl_current_form && fl_current_form != group->form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 2189 ) ), efp_ ( "fl_addto_group",
               "Can't switch to a group on a different form" );
        return ((void *)0) ;
    }

    if ( fli_current_group && fli_current_group != group )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 2196 ) ), efp_ ( "fl_addto_group", "You forgot to call fl_end_group" );
        return ((void *)0) ;
    }

    if ( fli_current_group )
        ( efp_ = fli_error_setup( 0 ,  "forms.c", 2201 ) ), efp_ ( "fl_addto_group", "Group was never closed" );

    reopened_group = fl_current_form ? 1 : 2;
    fl_current_form = group->form;
    return fli_current_group = group;
}


/***************************************
 * Returns if a form is visible
 ***************************************/

int
fl_form_is_visible( FL_FORM * form )
{
    if ( ! form )
    {
        ( efp_ = fli_error_setup( 0 ,  "forms.c", 2218 ) ), efp_ ( "fl_form_is_visible", "NULL form" );
        return FL_INVISIBLE;
    }

    return form->window ? form->visible : FL_INVISIBLE;
}


/***************************************
 * Similar to fit_object_label(), but will do it for all objects and
 * has a smaller maximum magnification factor (1.25 instead of 1.5).
 * Mainly intended for compensation for font size variations.
 ***************************************/

double
fl_adjust_form_size( FL_FORM * form )
{
    FL_OBJECT * obj;
    double xfactor,
           yfactor,
           max_factor,
           factor;
    int sw,
        sh,
        osize,
        bw;

    if ( fli_no_connection )
        return 1.0;

    max_factor = factor = 1.0;
    for ( obj = form->first; obj; obj = obj->next )
    {
        if (    fl_is_outside_lalign( obj->align )
             || obj->type == 10000 
             || obj->type == 20000 
             || obj->parent
             || ! obj->label
             || ! *obj->label
             || *obj->label == '@' )
            continue;

        fl_get_string_dimension( obj->lstyle, obj->lsize, obj->label,
                                 strlen( obj->label ), &sw, &sh );

        bw = (    obj->boxtype == FL_UP_BOX
               || obj->boxtype == FL_DOWN_BOX
               || obj->boxtype == FL_EMBOSSED_BOX ) ?
             ( (   obj->bw   ) > 0 ? (   obj->bw   ) : ( - (   obj->bw   ) ) )  : 1;

        if (    obj->boxtype == FL_EMBOSSED_BOX )
            bw += bw > 2 ? bw - 2 : 1;

        if (    obj->objclass == FL_BUTTON
             && (    obj->type == FL_RETURN_BUTTON
                  || obj->type == FL_MENU_BUTTON ) )
            sw += ( (   0.6 * obj->h  ) < (   0.6 * obj->w   ) ? (   0.6 * obj->h  ) : (   0.6 * obj->w   ) )  - 1;

        if ( obj->objclass == FL_BUTTON && obj->type == FL_LIGHTBUTTON )
            sw += ( ( FL_Coord ) 12 )  + 1;

        if (    sw <= obj->w - 2 * ( bw + 1 )
             && sh <= obj->h - 2 * ( bw + 1 ))
            continue;

        if ( ( osize = obj->w - 2 * ( bw + 1 ) ) <= 0 )
            osize = 1;
        xfactor = ( double ) sw / osize;

        if ( ( osize = obj->h - 2 * ( bw + 1 ) ) <= 0 )
            osize = 1;
        yfactor = ( double ) sh / osize;

        if ( ( factor = ( (   xfactor  ) > (   yfactor   ) ? (   xfactor  ) : (   yfactor   ) )  ) > max_factor )
            max_factor = factor;
    }

    /* Don't scale down and don't scale up by more than a factor of 1.25 */

    max_factor = ( (   max_factor  ) < (   1.0  ) ? (   1.0  ) : ( (   max_factor  ) > (   1.25   ) ? (   1.25   ) : (   max_factor  ) ) ) ;

    /* Scale all objects without taking care of gravity etc. */

    if ( max_factor > 1.0 )
        simple_form_rescale( form, max_factor );

    return max_factor;
}


/***************************************
 ***************************************/

void
fl_raise_form( FL_FORM * form )
{
    if ( form && form->window )
        XRaiseWindow( fl_display, form->window );
    else
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 2317 ) ), efp_ ( "fl_raise_form", "NULL form or form window not shown" );
}


/***************************************
 ***************************************/

void
fl_lower_form( FL_FORM * form )
{
    if ( form && form->window )
        XLowerWindow( fl_display, form->window );
    else
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 2330 ) ), efp_ ( "fl_lower_form", "NULL form or forn window not shown" );
}


/***************************************
 * Returns the sizes of the "decorations" the window manager puts around
 * a forms window. Returns 0 on success and 1 if the form isn't visible
 * or it's a form embedded into another form.
 * This tries to use the "_NET_FRAME_EXTENTS" atom which resonably recent
 * window managers in principle should set. For those window managers that
 * don't have that atom we try it with the old trick of searching up for
 * the enclosing parent window and using the geometry of this window (but
 * note: this doesn't work with window managers that don't reparent the
 * windows they manage, and we can't recognize that).
 ***************************************/

int
fl_get_decoration_sizes( FL_FORM * form,
                         int     * top,
                         int     * right,
                         int     * bottom,
                         int     * left )
{
    Atom a;

    if (    ! form
         || ! form->window
         || form->visible != FL_VISIBLE
         || form->parent )
        return 1;

    /* If the window manager knows about the '_NET_FRAME_EXTENTS' atom ask
       for the settings for the forms window, otherwise try by looking for
       the size of the enclosing parent window */

    if ( ( a = XInternAtom( fl_display , "_NET_FRAME_EXTENTS", 1  ) )
                                                                      != 0L  )
        get_decoration_sizes_from_wm( a, form, top, right, bottom, left );
    else
        get_decorations_sizes_from_parent( form, top, right, bottom, left );

    return 0;
}


/***************************************
 * Gets the decorations sizes via the _NET_FRAME_EXTENTS atom.
 ***************************************/

static
void
get_decoration_sizes_from_wm( Atom      a,
                              FL_FORM * form,
                              int     * top,
                              int     * right,
                              int     * bottom,
                              int     * left )
{
    Atom actual_type;
    int actual_format;
    unsigned long nitems;
    unsigned long bytes_after;
    static unsigned char *prop;

    XGetWindowProperty( fl_display , form->window, a, 0,
                        4, 0 , ((Atom) 6) ,
                        &actual_type, &actual_format, &nitems,
                        &bytes_after, &prop );

    /* If no properties are returne the window probably has no decorations */

    if (    actual_type == ((Atom) 6) 
         && actual_format == 32
         && nitems == 4 )
    {
        *top    = ( ( long * ) prop )[ 2 ];
        *right  = ( ( long * ) prop )[ 1 ];
        *bottom = ( ( long * ) prop )[ 3 ];
        *left   = ( ( long * ) prop )[ 0 ];
    }
    else
        *top = *right =*bottom = *left = 0;
}


/***************************************
 * Tries to get the size of the decorations of a form the traditional
 * way, asuming that the form window is the child of a parent window
 * that encloses also the decoration windows (assuming that the window
 * manager reparents the windows it manages, otherwise we'll report
 * back zero sized decorations without any chance of figuring out that
 * this is wrong;-(
 ***************************************/

static
void
get_decorations_sizes_from_parent( FL_FORM * form,
                                   int     * top,
                                   int     * right,
                                   int     * bottom,
                                   int     * left )
{
    Window cur_win = form->window;
    Window root;
    Window parent;
    Window *childs = ((void *)0) ;
    XWindowAttributes win_attr;
    XWindowAttributes frame_attr;
    Window wdummy;
    unsigned int udummy;

    /* Get the coordinates and size of the form's window */

    XGetWindowAttributes( fl_display , cur_win, &win_attr );

    /* Try to get its parent window */

    XQueryTree( fl_display , cur_win, &root, &parent, &childs,
                &udummy );

    /* Childs aren't used, get rid of them */

    if ( childs )
    {
        XFree( childs );
        childs = ((void *)0) ;
    }

    /* If there's no parent or the parent window is the root window
       we've got to assume that there are no decorations */

    if ( ! parent || parent == root )
    {
        *top = *right =*bottom = *left = 0;
        return;
    }

    /* Now translate the form window's coordiates (that are relative to
       its parent) to that relative to the root window and then find the
       top-most parent that isn't the root window itself */

    XTranslateCoordinates( fl_display , parent, root,
                           win_attr.x, win_attr.y,
                           &win_attr.x, &win_attr.y, &wdummy );

    while ( parent && parent != root )
    {
        cur_win = parent;
        XQueryTree( fl_display , cur_win, &root, &parent, &childs,
                    &udummy );

        if ( childs )
        {
            XFree( childs );
            childs = ((void *)0) ;
        }
    }

    /* Get the cordinates and sizes of the top-most window... */

    XGetWindowAttributes( fl_display , cur_win, &frame_attr );

    /* ...and finally calculate the decoration sizes */

    *top    = win_attr.y - frame_attr.y;
    *left   = win_attr.x - frame_attr.x;
    *bottom = frame_attr.height - win_attr.height - *top;
    *right  = frame_attr.width  - win_attr.width  - *left;
}


/***************************************
 * Returns if a form window is in iconified state
 ***************************************/

int
fl_form_is_iconified( FL_FORM * form )
{
    XWindowAttributes xwa;

    if ( ! form )
    {
        ( efp_ = fli_error_setup( -1 ,   "forms.c", 2512 ) ), efp_ ( "fl_form_is_iconified", "NULL form" );
        return 0;
    }

    if ( ! form->window || form->visible == FL_INVISIBLE )
        return 0;

    XGetWindowAttributes( fl_display , form->window, &xwa );

    return xwa.map_state != 2 ;
}


/*
 * Local variables:
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
